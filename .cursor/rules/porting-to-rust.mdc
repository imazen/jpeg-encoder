---
description: 
globs: 
alwaysApply: true
---
*(This file is managed by an AI, please describe desired changes.)*
# Rules for porting the C++ jpegli encoder algorithms to the Rust jpeg-encoder crate (workspace root)

Use cargo test

Be ABSOLUTELY MINIMAL in making changes outside of the src/jpegli/ directory, we want to preserve the jpeg-encoder API and make as few changes as needed to support the jpegli algorithm. Do NOT make tests pass by skipping or commenting them out. Be CORRECT. NEVER INFER A FILE's CONTENTS, READ IT.

And if changes fail to apply, reload files from disk since they must have been applied early.

1. The jpegli encoder source is in @jpegli/lib/jpegli jpegli/lib/jpegli
2. external/rust-lcms2 is the source for lcms2, and @lcms.md has info. external/image-png and external/image are useful for loading png files, if you lack utility functions for that. We have docs indexed for most crates we use.
3. We target stable Rust, and keep any unsafe code (like SIMD abstractions) simple; study jpeg-encoder and follow those patterns. Auto-vectorization is the goal.
4. Before porting a C++ component, we examine all the headers it references and build a list of all the functions it actually depends on, and add that info as comments in the C++ header.
5. We work methodically, search for a replacement in jpeg-encoder or create one, and try to create idomatic but performant and correct solutions.
6. We add new rules when we glean insight about jpegli, its structure, organization
7. We add rules whenever we establish a mapping from a C++ component to a rust component, including function signatures.
8. We always port tests and run them regularly.
9. Create new functions, and don't delete existing quanitzation tables or methods. We want to be able to compare and benchmark new and old, side by side.
10. We put testdata images in reference_dct/testdata/, see referenced_dct/dct.sh for ones we found most useful.AS


## Rule 9: Dependencies of jpegli/lib/jpegli/encode.cc

The main encoder implementation in `jpegli/lib/jpegli/encode.cc` depends on the following headers (relative to the jpegli subdir)

*   **C API:** `jpegli/lib/jpegli/encode.h`
*   **Standard Libraries:** `<algorithm>`, `<cstddef>`, `<cstdint>`, `<cstring>`, `<vector>`
*   **Jpegli Base:** `jpegli/lib/base/types.h`
*   **Jpegli Common:** `jpegli/lib/jpegli/common.h`, `jpegli/lib/jpegli/common_internal.h`, `jpegli/lib/jpegli/types.h`, `jpegli/lib/jpegli/error.h`, `jpegli/lib/jpegli/memory_manager.h`, `jpegli/lib/jpegli/simd.h`
*   **Jpegli Encoding Stages:**
    *   `jpegli/lib/jpegli/input.h`
    *   `jpegli/lib/jpegli/color_transform.h`
    *   `jpegli/lib/jpegli/downsample.h`
    *   `jpegli/lib/jpegli/adaptive_quantization.h`
    *   `jpegli/lib/jpegli/quant.h`
    *   `jpegli/lib/jpegli/entropy_coding.h`
    *   `jpegli/lib/jpegli/huffman.h`
    *   `jpegli/lib/jpegli/bitstream.h`, `jpegli/lib/jpegli/bit_writer.h`
    *   `jpegli/lib/jpegli/encode_streaming.h`, `jpegli/lib/jpegli/encode_finish.h`
*   **Internal Helpers:** `jpegli/lib/jpegli/encode_internal.h`

**Relevant Files from jpegli/lib/jpegli/ C++:**

| Feature                     | Jpegli Source (`jpegli/lib/jpegli/`)        |
| :-------------------------- | :----------------------------------- |
| Quantization (Base Tables)  | `quant.cc`                           |
| Quantization (Distance)   | `quant.cc`                           |
| Quantization (Zero Bias)  | `quant.cc`                           |
| Adaptive Quantization     | `adaptive_quantization.cc/.h`        |
| Float DCT                   | `dct-inl.h`                          |
| Encoder API/Logic         | `encode.cc/.h`                       |
| Encoding Loop Integration | `encode_streaming.cc`, `encode.cc` |
| Color Transform (YCbCr)   | `color_transform.cc/.h`              |
| Color Transform (XYB)     | `color_transform.cc/.h`              |
| Input Handling              | `input.cc/.h`                        |


These represent the primary modules involved in the JPEG encoding process within jpegli.


## Jpegli Algorithmic Differences vs. Standard libjpeg-turbo

Based on analysis of the `jpegli` encoder source code and its API (`encode.h`, `encode.cc`), here are some key algorithmic differences compared to a standard `libjpeg-turbo` implementation:

1.  **Adaptive Quantization:** Jpegli implements and enables *adaptive quantization* by default (`jpegli_enable_adaptive_quantization`, `ComputeAdaptiveQuantField`). This means it analyzes local image features (like edges and textures) and adjusts the quantization strength accordingly, aiming to preserve detail where it's visually important and save bits where it's not. Standard libjpeg uses non-adaptive quantization unless specific extensions (like Trellis quantization, often slower) are enabled.
2.  **Psychovisually Tuned Quantization Tables & Distance Metric:** Jpegli uses different default quantization tables than the standard Annex K tables used by libjpeg-turbo. These tables are likely derived from psychovisual modeling (related to the Butteraugli metric). Instead of just a `quality` factor (0-100), jpegli allows setting a target *Butteraugli distance* (`jpegli_set_distance`) which provides a more perceptually uniform measure of image quality/difference. While `jpegli_set_quality` exists for compatibility, it maps to an underlying distance. Libjpeg-turbo's quality setting directly scales the standard tables. Jpegli *can* use the standard tables if requested (`jpegli_use_standard_quant_tables`).
3.  **XYB Color Space Option:** Jpegli offers the option to use the perceptually optimized XYB color space (`jpegli_set_xyb_mode`) derived from JPEG XL. This can lead to better compression efficiency compared to the traditional YCbCr color space used by default in libjpeg-turbo for color images.
4.  **Default DCT Method:** Jpegli seems to default to a floating-point DCT (`cinfo->dct_method = JDCT_FLOAT;` in `InitializeCompressParams`). While libjpeg-turbo *supports* float DCT, its default and often faster options are integer DCTs (`JDCT_ISLOW`, `JDCT_IFAST`).
5.  **Different Defaults:** Jpegli uses different defaults for parameters like progressive scan scripts (`jpegli_set_progressive_level`, `SetDefaultScanScript`) aiming for potentially better compression or perceived quality out-of-the-box.

**In summary:** While `jpegli` maintains API compatibility with `libjpeg-turbo`, its internal algorithms are significantly enhanced with techniques focused on psychovisual optimization. It leverages adaptive quantization, perceptually derived quantization tables (Butteraugli-based), and the XYB color space to achieve higher quality compression for a given file size compared to standard JPEG encoders like `libjpeg-turbo`.


## Original `jpeg-encoder` Crate Structure Analysis

Based on analysis of the `jpeg-encoder` crate's source code (`lib.rs`, `encoder.rs`, and other non-jpegli modules), here's an outline of its structure before significant jpegli porting:

1.  **Main Entry Point (`lib.rs`, `encoder.rs`):**
    *   Defines the public API (`Encoder`, `ColorType`, `SamplingFactor`, etc.).
    *   The `Encoder` struct acts as the central orchestrator, holding configuration (quality, sampling, tables, progressive settings, writer) and managing the encoding process.
    *   Provides constructors (`new`, `new_file`) and configuration methods (`set_sampling_factor`, `set_quantization_tables`, `set_progressive`, etc.).
    *   The main `encode` and `encode_image` methods handle input validation, SIMD dispatch (using the `Operations` trait), and delegate to specific encoding routines.

2.  **Input Handling (`image_buffer.rs`):**
    *   Defines the `ImageBuffer` trait to abstract different input image formats (Grayscale, RGB, RGBA, CMYK, etc.).
    *   Provides concrete implementations for common color types based on `&[u8]` slices.
    *   Includes standard color conversion logic (`rgb_to_ycbcr`, `cmyk_to_ycck`).

3.  **Core JPEG Stages (Separate Modules):**
    *   **FDCT (`fdct.rs`):** Implements the Forward Discrete Cosine Transform, specifically the standard integer DCT (based on Loeffler/Ligtenberg/Moschytz, ported from libjpeg/mozjpeg).
    *   **Quantization (`quantization.rs`):** Defines `QuantizationTable` and `QuantizationTableType`. Handles creating tables based on quality (scaling standard Annex K or other predefined tables) or using custom tables.
    *   **Huffman Coding (`huffman.rs`, `writer.rs`):**
        *   `huffman.rs`: Defines `HuffmanTable`, provides default tables (Annex K), and includes logic (`new_optimized`) to build optimized tables based on coefficient frequencies.
        *   `writer.rs`: Contains logic within `JfifWriter` to encode quantized DCT coefficients using selected Huffman tables and write them to the bitstream.
    *   **Writing (`writer.rs`):**
        *   Defines the `JfifWrite` trait for output abstraction (supports `no_std`).
        *   `JfifWriter` handles writing all standard JPEG markers (SOI, EOI, SOF, DQT, DHT, SOS, DRI, RST, APPn) and manages bitstream buffering and byte stuffing.

4.  **Encoding Modes (`encoder.rs`):**
    *   Implements different encoding strategies based on configuration:
        *   `encode_image_interleaved`: Baseline encoding for compatible sampling factors.
        *   `encode_image_sequential`: Baseline encoding for incompatible sampling or optimization.
        *   `encode_image_progressive`: Progressive encoding using spectral selection.

5.  **SIMD Optimization (`avx2.rs`, `avx2/fdct.rs`, `avx2/ycbcr.rs`, `encoder.rs`):**
    *   Uses the `Operations` trait in `encoder.rs` to abstract potential SIMD implementations.
    *   Provides AVX2 optimized versions of integer FDCT (`avx2::fdct::fdct_avx2`) and RGB->YCbCr conversion (`avx2::ycbcr::*ImageAVX2`).
    *   The `AVX2Operations` struct implements `Operations` to select these AVX2 routines when the `simd` feature is enabled.

## Current `src/` Structure Overview

This describes the current state of the source files based on recent analysis, without asserting completion status.

*   **`src/lib.rs`:**
    *   Crate root, defines modules (`encoder`, `error`, `fdct`, `huffman`, `image_buffer`, `marker`, `quantization`, `writer`).
    *   Conditionally includes `avx2` and `jpegli` modules based on features.
    *   Re-exports public API types (`Encoder`, `ColorType`, `EncodingError`, `QuantizationTableType`, `SamplingFactor`, etc.).
    *   Contains extensive integration tests.

*   **`src/encoder.rs`:**
    *   Defines the main `Encoder` struct, holding configuration state (quality, quantization tables, Huffman tables, sampling factor, progressive settings, output writer).
    *   Includes jpegli-specific configuration fields: `jpegli_distance`, `use_float_dct`, `use_adaptive_quantization`.
    *   Provides public methods for configuration (`set_quality`, `set_jpegli_distance`, `set_float_dct`, `set_adaptive_quantization`, `set_sampling_factor`, etc.).
    *   Contains the primary encoding entry points (`encode`, `encode_image`) and internal orchestration logic (`encode_image_internal`).
    *   Dispatches to different encoding paths (`encode_image_interleaved`, `encode_image_sequential`, `encode_image_progressive`) based on settings.
    *   Defines the `Operations` trait used for SIMD dispatch (currently for FDCT and quantization). The `DefaultOperations` struct provides scalar implementations.
    *   Includes helper functions for color conversion setup (`init_components`), block processing (`encode_blocks`), Huffman table optimization (`optimize_huffman_table`), etc.
    *   Contains jpegli-specific logic like `quality_to_distance`, `new_with_jpegli_distance`, `compute_zero_bias_tables`.

*   **`src/image_buffer.rs`:**
    *   Defines the `ImageBuffer` trait for abstracting image input. Key methods: `get_jpeg_color_type`, `width`, `height`, `fill_buffers` (provides one row of component data), `get_adaptive_quant_channel` (provides Luma/Y channel for AQ).
    *   Provides implementations for common `&[u8]` slice formats (`GrayImage`, `RgbImage`, `RgbaImage`, `BgrImage`, `BgraImage`, `YCbCrImage`, `CmykImage`, `CmykAsYcckImage`, `YcckImage`).
    *   Contains standard `rgb_to_ycbcr` and `cmyk_to_ycck` fixed-point conversion functions.
    *   Implementations generally provide the `get_adaptive_quant_channel` method.

*   **`src/quantization.rs`:**
    *   Defines `QuantizationTableType` enum (Standard Annex K, Flat, other presets, `Custom`).
    *   Defines the `QuantizationTable` struct holding the 64 `u16` values and precomputed reciprocals/corrections for faster quantization.
    *   Provides `new_with_quality` constructor to scale a base table according to a 0-100 quality factor.
    *   Contains the `quantize` method for standard DCT coefficient quantization.
    *   Holds static arrays for various standard Luma and Chroma tables (`DEFAULT_LUMA_TABLES`, `DEFAULT_CHROMA_TABLES`).
    *   **Note:** Jpegli distance-based table generation (`new_with_jpegli_distance`) and zero-bias logic (`compute_zero_bias_tables`) are currently implemented directly in `src/encoder.rs`, not here.

*   **`src/fdct.rs`:**
    *   Contains the standard, portable integer Forward DCT implementation (`fdct`) based on the Loeffler/Ligtenberg/Moschytz algorithm (ported from libjpeg/mozjpeg).

*   **`src/huffman.rs`:**
    *   Defines `HuffmanTable` struct holding lookup tables and raw table data.
    *   Provides constructors for default Annex K tables (`default_luma_dc`, etc.).
    *   Contains `new_optimized` function to generate optimized tables from frequency counts.
    *   Includes static arrays for default Annex K table definitions.

*   **`src/writer.rs`:**
    *   Defines `JfifWrite` trait for output byte writing (works in `no_std`).
    *   Defines `JfifWriter` struct for managing bitstream output, handling bit buffering and byte stuffing.
    *   Provides methods for writing standard JPEG markers (APP0, DQT, DHT, SOF, SOS, DRI).
    *   Includes methods for Huffman encoding DC and AC coefficients (`write_dc`, `write_ac_block`, `write_block`).
    *   Defines the `ZIGZAG` coefficient ordering array.

*   **`src/marker.rs`:**
    *   Defines the `Marker` enum representing JPEG markers.
    *   Contains structs for segment headers (e.g., `SOF`, `SOSHeader`).

*   **`src/error.rs`:**
    *   Defines the `EncodingError` and `JpegError` enums for error handling.

*   **`src/avx2.rs`:**
    *   Root of the AVX2 SIMD module (conditional on `simd` feature).
    *   Declares `fdct` and `ycbcr` submodules.
    *   Defines `AVX2Operations` struct implementing the `Operations` trait, overriding `fdct` to use the AVX2 version.

*   **`src/avx2/fdct.rs`:**
    *   Contains AVX2-accelerated integer FDCT implementation (`fdct_avx2`) using intrinsics, ported from libjpeg-turbo/mozjpeg assembly.

*   **`src/avx2/ycbcr.rs`:**
    *   Contains AVX2-accelerated `ImageBuffer` implementations (`RgbImageAVX2`, etc.) providing faster `rgb_to_ycbcr` conversion using intrinsics.

*   **`src/jpegli/mod.rs`:**
    *   Root of the Jpegli-specific module (conditional on `jpegli` feature).
    *   Declares submodules: `adaptive_quantization`, `color_transform`, `fdct_jpegli`, `quant`, `tf`, `xyb`, `cms`.

*   **`src/jpegli/adaptive_quantization.rs`:**
    *   Contains the scalar Rust implementation of Jpegli's adaptive quantization algorithm.
    *   Key function: `compute_adaptive_quant_field`, which takes scaled Y channel data and distance, and produces the per-block quantization multiplier field.
    *   Includes helper functions mirroring Jpegli stages (`compute_pre_erosion_scalar`, `fuzzy_erosion_scalar`, `compute_mask_scalar`, etc.) and image processing utilities (`gaussian_blur_scalar`, `downsample_to_blocks`).

*   **`src/jpegli/fdct_jpegli.rs`:**
    *   Contains the scalar Rust implementation of Jpegli's floating-point FDCT (`forward_dct_float`).
    *   Uses a recursive approach (`DCT1DImplTrait`) and helper functions (`add_reverse`, `sub_reverse`, `multiply`, `b`, etc.).

  **`src/jpegli/quant.rs`:**
    *   Contains constants (e.g., default Jpegli tables, zero-bias values) and functions related to Jpegli's quantization logic, ported from C++. Handles quality-to-distance mapping and distance-based quantization table generation.

*   **`src/jpegli/color_transform.rs`, `src/jpegli/tf.rs`, `src/jpegli/xyb.rs`, `src/jpegli/cms.rs`:**
    *   **`color_transform.rs`**: Provides functions for basic color space conversions (Linear RGB <-> YCbCr, CMYK <-> YCCK, Gray -> RGB) operating on planar f32 data.
    *   **`tf.rs`**: Implements transfer functions (sRGB, PQ, HLG) for converting between linear and encoded values. Provides `before_transform` and `after_transform` wrappers used by `cms.rs`.
    *   **`xyb.rs`**: Implements the Opsin Absorbance (XYB) color transformation from linear RGB, including scaling.
    *   **`cms.rs`**: The main Color Management System interface using `lcms2`. Defines `ColorProfile` (wrapping ICC data and parsed info), `JxlCms` (managing the LCMS transform and pre/post processing TFs), and `set_fields_from_icc` (parsing profiles).


