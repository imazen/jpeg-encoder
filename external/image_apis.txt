pub mod image
pub mod image::buffer
pub struct image::buffer::EnumeratePixels<'a, P: image::Pixel + 'a> where <P as image::Pixel>::Subpixel: 'a
impl<'a, P: image::Pixel + 'a> core::iter::traits::exact_size::ExactSizeIterator for image::buffer::EnumeratePixels<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::EnumeratePixels<'a, P>::len(&self) -> usize
impl<'a, P: image::Pixel + 'a> core::iter::traits::iterator::Iterator for image::buffer::EnumeratePixels<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub type image::buffer::EnumeratePixels<'a, P>::Item = (u32, u32, &'a P)
pub fn image::buffer::EnumeratePixels<'a, P>::next(&mut self) -> core::option::Option<(u32, u32, &'a P)>
pub fn image::buffer::EnumeratePixels<'a, P>::size_hint(&self) -> (usize, core::option::Option<usize>)
impl<P: image::Pixel> core::clone::Clone for image::buffer::EnumeratePixels<'_, P>
pub fn image::buffer::EnumeratePixels<'_, P>::clone(&self) -> Self
impl<P: image::Pixel> core::fmt::Debug for image::buffer::EnumeratePixels<'_, P> where <P as image::Pixel>::Subpixel: core::fmt::Debug
pub fn image::buffer::EnumeratePixels<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::EnumeratePixels<'a, P>
impl<'a, P> core::marker::Send for image::buffer::EnumeratePixels<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Sync for image::buffer::EnumeratePixels<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Unpin for image::buffer::EnumeratePixels<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::EnumeratePixels<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> core::panic::unwind_safe::UnwindSafe for image::buffer::EnumeratePixels<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<I> core::iter::traits::collect::IntoIterator for image::buffer::EnumeratePixels<'a, P> where I: core::iter::traits::iterator::Iterator
pub type image::buffer::EnumeratePixels<'a, P>::IntoIter = I
pub type image::buffer::EnumeratePixels<'a, P>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::buffer::EnumeratePixels<'a, P>::into_iter(self) -> I
impl<IT, A, FromA, B, FromB, C, FromC> itertools::unziptuple::MultiUnzip<(FromA, FromB, FromC)> for image::buffer::EnumeratePixels<'a, P> where IT: core::iter::traits::iterator::Iterator<Item = (A, B, C)>, FromA: core::default::Default + core::iter::traits::collect::Extend<A>, FromB: core::default::Default + core::iter::traits::collect::Extend<B>, FromC: core::default::Default + core::iter::traits::collect::Extend<C>
pub fn image::buffer::EnumeratePixels<'a, P>::multiunzip(self) -> (FromA, FromB, FromC)
impl<T, U> core::convert::Into<U> for image::buffer::EnumeratePixels<'a, P> where U: core::convert::From<T>
pub fn image::buffer::EnumeratePixels<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::EnumeratePixels<'a, P> where U: core::convert::Into<T>
pub type image::buffer::EnumeratePixels<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::EnumeratePixels<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::EnumeratePixels<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::EnumeratePixels<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::EnumeratePixels<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::buffer::EnumeratePixels<'a, P> where T: core::clone::Clone
pub type image::buffer::EnumeratePixels<'a, P>::Owned = T
pub fn image::buffer::EnumeratePixels<'a, P>::clone_into(&self, target: &mut T)
pub fn image::buffer::EnumeratePixels<'a, P>::to_owned(&self) -> T
impl<T> core::any::Any for image::buffer::EnumeratePixels<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::EnumeratePixels<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::EnumeratePixels<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumeratePixels<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::EnumeratePixels<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumeratePixels<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::buffer::EnumeratePixels<'a, P> where T: core::clone::Clone
pub unsafe fn image::buffer::EnumeratePixels<'a, P>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::buffer::EnumeratePixels<'a, P>
pub fn image::buffer::EnumeratePixels<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::EnumeratePixels<'a, P>
pub type image::buffer::EnumeratePixels<'a, P>::Init = T
pub const image::buffer::EnumeratePixels<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::EnumeratePixels<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::EnumeratePixels<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::EnumeratePixels<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::EnumeratePixels<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::EnumeratePixels<'a, P>
impl<T> itertools::Itertools for image::buffer::EnumeratePixels<'a, P> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
pub struct image::buffer::EnumeratePixelsMut<'a, P: image::Pixel + 'a> where <P as image::Pixel>::Subpixel: 'a
impl<'a, P: image::Pixel + 'a> core::iter::traits::exact_size::ExactSizeIterator for image::buffer::EnumeratePixelsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::EnumeratePixelsMut<'a, P>::len(&self) -> usize
impl<'a, P: image::Pixel + 'a> core::iter::traits::iterator::Iterator for image::buffer::EnumeratePixelsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub type image::buffer::EnumeratePixelsMut<'a, P>::Item = (u32, u32, &'a mut P)
pub fn image::buffer::EnumeratePixelsMut<'a, P>::next(&mut self) -> core::option::Option<(u32, u32, &'a mut P)>
pub fn image::buffer::EnumeratePixelsMut<'a, P>::size_hint(&self) -> (usize, core::option::Option<usize>)
impl<P: image::Pixel> core::fmt::Debug for image::buffer::EnumeratePixelsMut<'_, P> where <P as image::Pixel>::Subpixel: core::fmt::Debug
pub fn image::buffer::EnumeratePixelsMut<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::EnumeratePixelsMut<'a, P>
impl<'a, P> core::marker::Send for image::buffer::EnumeratePixelsMut<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Send
impl<'a, P> core::marker::Sync for image::buffer::EnumeratePixelsMut<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Unpin for image::buffer::EnumeratePixelsMut<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::EnumeratePixelsMut<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> !core::panic::unwind_safe::UnwindSafe for image::buffer::EnumeratePixelsMut<'a, P>
impl<I> core::iter::traits::collect::IntoIterator for image::buffer::EnumeratePixelsMut<'a, P> where I: core::iter::traits::iterator::Iterator
pub type image::buffer::EnumeratePixelsMut<'a, P>::IntoIter = I
pub type image::buffer::EnumeratePixelsMut<'a, P>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::buffer::EnumeratePixelsMut<'a, P>::into_iter(self) -> I
impl<IT, A, FromA, B, FromB, C, FromC> itertools::unziptuple::MultiUnzip<(FromA, FromB, FromC)> for image::buffer::EnumeratePixelsMut<'a, P> where IT: core::iter::traits::iterator::Iterator<Item = (A, B, C)>, FromA: core::default::Default + core::iter::traits::collect::Extend<A>, FromB: core::default::Default + core::iter::traits::collect::Extend<B>, FromC: core::default::Default + core::iter::traits::collect::Extend<C>
pub fn image::buffer::EnumeratePixelsMut<'a, P>::multiunzip(self) -> (FromA, FromB, FromC)
impl<T, U> core::convert::Into<U> for image::buffer::EnumeratePixelsMut<'a, P> where U: core::convert::From<T>
pub fn image::buffer::EnumeratePixelsMut<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::EnumeratePixelsMut<'a, P> where U: core::convert::Into<T>
pub type image::buffer::EnumeratePixelsMut<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::EnumeratePixelsMut<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::EnumeratePixelsMut<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::EnumeratePixelsMut<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::EnumeratePixelsMut<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::buffer::EnumeratePixelsMut<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::EnumeratePixelsMut<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::EnumeratePixelsMut<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumeratePixelsMut<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::EnumeratePixelsMut<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumeratePixelsMut<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::buffer::EnumeratePixelsMut<'a, P>
pub fn image::buffer::EnumeratePixelsMut<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::EnumeratePixelsMut<'a, P>
pub type image::buffer::EnumeratePixelsMut<'a, P>::Init = T
pub const image::buffer::EnumeratePixelsMut<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::EnumeratePixelsMut<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::EnumeratePixelsMut<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::EnumeratePixelsMut<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::EnumeratePixelsMut<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::EnumeratePixelsMut<'a, P>
impl<T> itertools::Itertools for image::buffer::EnumeratePixelsMut<'a, P> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
pub struct image::buffer::EnumeratePixelsMutPar<'a, P> where P: image::Pixel + core::marker::Send + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync + 'a
impl<'a, P> rayon::iter::IndexedParallelIterator for image::buffer::EnumeratePixelsMutPar<'a, P> where P: image::Pixel + core::marker::Send + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync + 'a
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::drive<C: rayon::iter::plumbing::Consumer<Self::Item>>(self, consumer: C) -> <C as rayon::iter::plumbing::Consumer>::Result
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::len(&self) -> usize
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::with_producer<CB: rayon::iter::plumbing::ProducerCallback<Self::Item>>(self, callback: CB) -> <CB as rayon::iter::plumbing::ProducerCallback>::Output
impl<'a, P> rayon::iter::ParallelIterator for image::buffer::EnumeratePixelsMutPar<'a, P> where P: image::Pixel + core::marker::Send + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync + 'a
pub type image::buffer::EnumeratePixelsMutPar<'a, P>::Item = (u32, u32, &'a mut P)
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::drive_unindexed<C>(self, consumer: C) -> <C as rayon::iter::plumbing::Consumer>::Result where C: rayon::iter::plumbing::UnindexedConsumer<Self::Item>
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::opt_len(&self) -> core::option::Option<usize>
impl<P> core::fmt::Debug for image::buffer::EnumeratePixelsMutPar<'_, P> where P: image::Pixel + core::marker::Send + core::marker::Sync, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync + core::fmt::Debug
pub fn image::buffer::EnumeratePixelsMutPar<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::EnumeratePixelsMutPar<'a, P>
impl<'a, P> core::marker::Send for image::buffer::EnumeratePixelsMutPar<'a, P>
impl<'a, P> core::marker::Sync for image::buffer::EnumeratePixelsMutPar<'a, P>
impl<'a, P> core::marker::Unpin for image::buffer::EnumeratePixelsMutPar<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::EnumeratePixelsMutPar<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> !core::panic::unwind_safe::UnwindSafe for image::buffer::EnumeratePixelsMutPar<'a, P>
impl<T, U> core::convert::Into<U> for image::buffer::EnumeratePixelsMutPar<'a, P> where U: core::convert::From<T>
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::EnumeratePixelsMutPar<'a, P> where U: core::convert::Into<T>
pub type image::buffer::EnumeratePixelsMutPar<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::EnumeratePixelsMutPar<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::EnumeratePixelsMutPar<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::buffer::EnumeratePixelsMutPar<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::EnumeratePixelsMutPar<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::EnumeratePixelsMutPar<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::buffer::EnumeratePixelsMutPar<'a, P>
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::EnumeratePixelsMutPar<'a, P>
pub type image::buffer::EnumeratePixelsMutPar<'a, P>::Init = T
pub const image::buffer::EnumeratePixelsMutPar<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::EnumeratePixelsMutPar<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::EnumeratePixelsMutPar<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::EnumeratePixelsMutPar<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::EnumeratePixelsMutPar<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::EnumeratePixelsMutPar<'a, P>
impl<T> rayon::iter::IntoParallelIterator for image::buffer::EnumeratePixelsMutPar<'a, P> where T: rayon::iter::ParallelIterator
pub type image::buffer::EnumeratePixelsMutPar<'a, P>::Item = <T as rayon::iter::ParallelIterator>::Item
pub type image::buffer::EnumeratePixelsMutPar<'a, P>::Iter = T
pub fn image::buffer::EnumeratePixelsMutPar<'a, P>::into_par_iter(self) -> T
pub struct image::buffer::EnumeratePixelsPar<'a, P> where P: image::Pixel + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Sync + 'a
impl<'a, P> core::clone::Clone for image::buffer::EnumeratePixelsPar<'a, P> where P: image::Pixel + core::marker::Sync + 'a + core::clone::Clone, <P as image::Pixel>::Subpixel: core::marker::Sync + 'a
pub fn image::buffer::EnumeratePixelsPar<'a, P>::clone(&self) -> image::buffer::EnumeratePixelsPar<'a, P>
impl<'a, P> rayon::iter::IndexedParallelIterator for image::buffer::EnumeratePixelsPar<'a, P> where P: image::Pixel + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Sync + 'a
pub fn image::buffer::EnumeratePixelsPar<'a, P>::drive<C: rayon::iter::plumbing::Consumer<Self::Item>>(self, consumer: C) -> <C as rayon::iter::plumbing::Consumer>::Result
pub fn image::buffer::EnumeratePixelsPar<'a, P>::len(&self) -> usize
pub fn image::buffer::EnumeratePixelsPar<'a, P>::with_producer<CB: rayon::iter::plumbing::ProducerCallback<Self::Item>>(self, callback: CB) -> <CB as rayon::iter::plumbing::ProducerCallback>::Output
impl<'a, P> rayon::iter::ParallelIterator for image::buffer::EnumeratePixelsPar<'a, P> where P: image::Pixel + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Sync + 'a
pub type image::buffer::EnumeratePixelsPar<'a, P>::Item = (u32, u32, &'a P)
pub fn image::buffer::EnumeratePixelsPar<'a, P>::drive_unindexed<C>(self, consumer: C) -> <C as rayon::iter::plumbing::Consumer>::Result where C: rayon::iter::plumbing::UnindexedConsumer<Self::Item>
pub fn image::buffer::EnumeratePixelsPar<'a, P>::opt_len(&self) -> core::option::Option<usize>
impl<P> core::fmt::Debug for image::buffer::EnumeratePixelsPar<'_, P> where P: image::Pixel + core::marker::Sync, <P as image::Pixel>::Subpixel: core::marker::Sync + core::fmt::Debug
pub fn image::buffer::EnumeratePixelsPar<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::EnumeratePixelsPar<'a, P>
impl<'a, P> core::marker::Send for image::buffer::EnumeratePixelsPar<'a, P>
impl<'a, P> core::marker::Sync for image::buffer::EnumeratePixelsPar<'a, P>
impl<'a, P> core::marker::Unpin for image::buffer::EnumeratePixelsPar<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::EnumeratePixelsPar<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> core::panic::unwind_safe::UnwindSafe for image::buffer::EnumeratePixelsPar<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<T, U> core::convert::Into<U> for image::buffer::EnumeratePixelsPar<'a, P> where U: core::convert::From<T>
pub fn image::buffer::EnumeratePixelsPar<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::EnumeratePixelsPar<'a, P> where U: core::convert::Into<T>
pub type image::buffer::EnumeratePixelsPar<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::EnumeratePixelsPar<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::EnumeratePixelsPar<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::EnumeratePixelsPar<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::EnumeratePixelsPar<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::buffer::EnumeratePixelsPar<'a, P> where T: core::clone::Clone
pub type image::buffer::EnumeratePixelsPar<'a, P>::Owned = T
pub fn image::buffer::EnumeratePixelsPar<'a, P>::clone_into(&self, target: &mut T)
pub fn image::buffer::EnumeratePixelsPar<'a, P>::to_owned(&self) -> T
impl<T> core::any::Any for image::buffer::EnumeratePixelsPar<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::EnumeratePixelsPar<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::EnumeratePixelsPar<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumeratePixelsPar<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::EnumeratePixelsPar<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumeratePixelsPar<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::buffer::EnumeratePixelsPar<'a, P> where T: core::clone::Clone
pub unsafe fn image::buffer::EnumeratePixelsPar<'a, P>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::buffer::EnumeratePixelsPar<'a, P>
pub fn image::buffer::EnumeratePixelsPar<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::EnumeratePixelsPar<'a, P>
pub type image::buffer::EnumeratePixelsPar<'a, P>::Init = T
pub const image::buffer::EnumeratePixelsPar<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::EnumeratePixelsPar<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::EnumeratePixelsPar<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::EnumeratePixelsPar<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::EnumeratePixelsPar<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::EnumeratePixelsPar<'a, P>
impl<T> rayon::iter::IntoParallelIterator for image::buffer::EnumeratePixelsPar<'a, P> where T: rayon::iter::ParallelIterator
pub type image::buffer::EnumeratePixelsPar<'a, P>::Item = <T as rayon::iter::ParallelIterator>::Item
pub type image::buffer::EnumeratePixelsPar<'a, P>::Iter = T
pub fn image::buffer::EnumeratePixelsPar<'a, P>::into_par_iter(self) -> T
pub struct image::buffer::EnumerateRows<'a, P: image::Pixel + 'a> where <P as image::Pixel>::Subpixel: 'a
impl<'a, P: image::Pixel + 'a> core::iter::traits::exact_size::ExactSizeIterator for image::buffer::EnumerateRows<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::EnumerateRows<'a, P>::len(&self) -> usize
impl<'a, P: image::Pixel + 'a> core::iter::traits::iterator::Iterator for image::buffer::EnumerateRows<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub type image::buffer::EnumerateRows<'a, P>::Item = (u32, image::buffer::EnumeratePixels<'a, P>)
pub fn image::buffer::EnumerateRows<'a, P>::next(&mut self) -> core::option::Option<(u32, image::buffer::EnumeratePixels<'a, P>)>
pub fn image::buffer::EnumerateRows<'a, P>::size_hint(&self) -> (usize, core::option::Option<usize>)
impl<P: image::Pixel> core::clone::Clone for image::buffer::EnumerateRows<'_, P>
pub fn image::buffer::EnumerateRows<'_, P>::clone(&self) -> Self
impl<P: image::Pixel> core::fmt::Debug for image::buffer::EnumerateRows<'_, P> where <P as image::Pixel>::Subpixel: core::fmt::Debug
pub fn image::buffer::EnumerateRows<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::EnumerateRows<'a, P>
impl<'a, P> core::marker::Send for image::buffer::EnumerateRows<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Sync for image::buffer::EnumerateRows<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Unpin for image::buffer::EnumerateRows<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::EnumerateRows<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> core::panic::unwind_safe::UnwindSafe for image::buffer::EnumerateRows<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<I> core::iter::traits::collect::IntoIterator for image::buffer::EnumerateRows<'a, P> where I: core::iter::traits::iterator::Iterator
pub type image::buffer::EnumerateRows<'a, P>::IntoIter = I
pub type image::buffer::EnumerateRows<'a, P>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::buffer::EnumerateRows<'a, P>::into_iter(self) -> I
impl<IT, A, FromA, B, FromB> itertools::unziptuple::MultiUnzip<(FromA, FromB)> for image::buffer::EnumerateRows<'a, P> where IT: core::iter::traits::iterator::Iterator<Item = (A, B)>, FromA: core::default::Default + core::iter::traits::collect::Extend<A>, FromB: core::default::Default + core::iter::traits::collect::Extend<B>
pub fn image::buffer::EnumerateRows<'a, P>::multiunzip(self) -> (FromA, FromB)
impl<T, U> core::convert::Into<U> for image::buffer::EnumerateRows<'a, P> where U: core::convert::From<T>
pub fn image::buffer::EnumerateRows<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::EnumerateRows<'a, P> where U: core::convert::Into<T>
pub type image::buffer::EnumerateRows<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::EnumerateRows<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::EnumerateRows<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::EnumerateRows<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::EnumerateRows<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::buffer::EnumerateRows<'a, P> where T: core::clone::Clone
pub type image::buffer::EnumerateRows<'a, P>::Owned = T
pub fn image::buffer::EnumerateRows<'a, P>::clone_into(&self, target: &mut T)
pub fn image::buffer::EnumerateRows<'a, P>::to_owned(&self) -> T
impl<T> core::any::Any for image::buffer::EnumerateRows<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::EnumerateRows<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::EnumerateRows<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumerateRows<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::EnumerateRows<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumerateRows<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::buffer::EnumerateRows<'a, P> where T: core::clone::Clone
pub unsafe fn image::buffer::EnumerateRows<'a, P>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::buffer::EnumerateRows<'a, P>
pub fn image::buffer::EnumerateRows<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::EnumerateRows<'a, P>
pub type image::buffer::EnumerateRows<'a, P>::Init = T
pub const image::buffer::EnumerateRows<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::EnumerateRows<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::EnumerateRows<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::EnumerateRows<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::EnumerateRows<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::EnumerateRows<'a, P>
impl<T> itertools::Itertools for image::buffer::EnumerateRows<'a, P> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
pub struct image::buffer::EnumerateRowsMut<'a, P: image::Pixel + 'a> where <P as image::Pixel>::Subpixel: 'a
impl<'a, P: image::Pixel + 'a> core::iter::traits::exact_size::ExactSizeIterator for image::buffer::EnumerateRowsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::EnumerateRowsMut<'a, P>::len(&self) -> usize
impl<'a, P: image::Pixel + 'a> core::iter::traits::iterator::Iterator for image::buffer::EnumerateRowsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub type image::buffer::EnumerateRowsMut<'a, P>::Item = (u32, image::buffer::EnumeratePixelsMut<'a, P>)
pub fn image::buffer::EnumerateRowsMut<'a, P>::next(&mut self) -> core::option::Option<(u32, image::buffer::EnumeratePixelsMut<'a, P>)>
pub fn image::buffer::EnumerateRowsMut<'a, P>::size_hint(&self) -> (usize, core::option::Option<usize>)
impl<P: image::Pixel> core::fmt::Debug for image::buffer::EnumerateRowsMut<'_, P> where <P as image::Pixel>::Subpixel: core::fmt::Debug
pub fn image::buffer::EnumerateRowsMut<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::EnumerateRowsMut<'a, P>
impl<'a, P> core::marker::Send for image::buffer::EnumerateRowsMut<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Send
impl<'a, P> core::marker::Sync for image::buffer::EnumerateRowsMut<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Unpin for image::buffer::EnumerateRowsMut<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::EnumerateRowsMut<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> !core::panic::unwind_safe::UnwindSafe for image::buffer::EnumerateRowsMut<'a, P>
impl<I> core::iter::traits::collect::IntoIterator for image::buffer::EnumerateRowsMut<'a, P> where I: core::iter::traits::iterator::Iterator
pub type image::buffer::EnumerateRowsMut<'a, P>::IntoIter = I
pub type image::buffer::EnumerateRowsMut<'a, P>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::buffer::EnumerateRowsMut<'a, P>::into_iter(self) -> I
impl<IT, A, FromA, B, FromB> itertools::unziptuple::MultiUnzip<(FromA, FromB)> for image::buffer::EnumerateRowsMut<'a, P> where IT: core::iter::traits::iterator::Iterator<Item = (A, B)>, FromA: core::default::Default + core::iter::traits::collect::Extend<A>, FromB: core::default::Default + core::iter::traits::collect::Extend<B>
pub fn image::buffer::EnumerateRowsMut<'a, P>::multiunzip(self) -> (FromA, FromB)
impl<T, U> core::convert::Into<U> for image::buffer::EnumerateRowsMut<'a, P> where U: core::convert::From<T>
pub fn image::buffer::EnumerateRowsMut<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::EnumerateRowsMut<'a, P> where U: core::convert::Into<T>
pub type image::buffer::EnumerateRowsMut<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::EnumerateRowsMut<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::EnumerateRowsMut<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::EnumerateRowsMut<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::EnumerateRowsMut<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::buffer::EnumerateRowsMut<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::EnumerateRowsMut<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::EnumerateRowsMut<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumerateRowsMut<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::EnumerateRowsMut<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::EnumerateRowsMut<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::buffer::EnumerateRowsMut<'a, P>
pub fn image::buffer::EnumerateRowsMut<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::EnumerateRowsMut<'a, P>
pub type image::buffer::EnumerateRowsMut<'a, P>::Init = T
pub const image::buffer::EnumerateRowsMut<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::EnumerateRowsMut<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::EnumerateRowsMut<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::EnumerateRowsMut<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::EnumerateRowsMut<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::EnumerateRowsMut<'a, P>
impl<T> itertools::Itertools for image::buffer::EnumerateRowsMut<'a, P> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
pub struct image::buffer::Pixels<'a, P: image::Pixel + 'a> where <P as image::Pixel>::Subpixel: 'a
impl<'a, P: image::Pixel + 'a> core::iter::traits::double_ended::DoubleEndedIterator for image::buffer::Pixels<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::Pixels<'a, P>::next_back(&mut self) -> core::option::Option<&'a P>
impl<'a, P: image::Pixel + 'a> core::iter::traits::exact_size::ExactSizeIterator for image::buffer::Pixels<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::Pixels<'a, P>::len(&self) -> usize
impl<'a, P: image::Pixel + 'a> core::iter::traits::iterator::Iterator for image::buffer::Pixels<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub type image::buffer::Pixels<'a, P>::Item = &'a P
pub fn image::buffer::Pixels<'a, P>::next(&mut self) -> core::option::Option<&'a P>
pub fn image::buffer::Pixels<'a, P>::size_hint(&self) -> (usize, core::option::Option<usize>)
impl<P: image::Pixel> core::clone::Clone for image::buffer::Pixels<'_, P>
pub fn image::buffer::Pixels<'_, P>::clone(&self) -> Self
impl<P: image::Pixel> core::fmt::Debug for image::buffer::Pixels<'_, P> where <P as image::Pixel>::Subpixel: core::fmt::Debug
pub fn image::buffer::Pixels<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::Pixels<'a, P>
impl<'a, P> core::marker::Send for image::buffer::Pixels<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Sync for image::buffer::Pixels<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Unpin for image::buffer::Pixels<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::Pixels<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> core::panic::unwind_safe::UnwindSafe for image::buffer::Pixels<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<I> core::iter::traits::collect::IntoIterator for image::buffer::Pixels<'a, P> where I: core::iter::traits::iterator::Iterator
pub type image::buffer::Pixels<'a, P>::IntoIter = I
pub type image::buffer::Pixels<'a, P>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::buffer::Pixels<'a, P>::into_iter(self) -> I
impl<T, U> core::convert::Into<U> for image::buffer::Pixels<'a, P> where U: core::convert::From<T>
pub fn image::buffer::Pixels<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::Pixels<'a, P> where U: core::convert::Into<T>
pub type image::buffer::Pixels<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::Pixels<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::Pixels<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::Pixels<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::Pixels<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::buffer::Pixels<'a, P> where T: core::clone::Clone
pub type image::buffer::Pixels<'a, P>::Owned = T
pub fn image::buffer::Pixels<'a, P>::clone_into(&self, target: &mut T)
pub fn image::buffer::Pixels<'a, P>::to_owned(&self) -> T
impl<T> core::any::Any for image::buffer::Pixels<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::Pixels<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::Pixels<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::Pixels<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::Pixels<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::Pixels<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::buffer::Pixels<'a, P> where T: core::clone::Clone
pub unsafe fn image::buffer::Pixels<'a, P>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::buffer::Pixels<'a, P>
pub fn image::buffer::Pixels<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::Pixels<'a, P>
pub type image::buffer::Pixels<'a, P>::Init = T
pub const image::buffer::Pixels<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::Pixels<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::Pixels<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::Pixels<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::Pixels<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::Pixels<'a, P>
impl<T> itertools::Itertools for image::buffer::Pixels<'a, P> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
pub struct image::buffer::PixelsMut<'a, P: image::Pixel + 'a> where <P as image::Pixel>::Subpixel: 'a
impl<'a, P: image::Pixel + 'a> core::iter::traits::double_ended::DoubleEndedIterator for image::buffer::PixelsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::PixelsMut<'a, P>::next_back(&mut self) -> core::option::Option<&'a mut P>
impl<'a, P: image::Pixel + 'a> core::iter::traits::exact_size::ExactSizeIterator for image::buffer::PixelsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::PixelsMut<'a, P>::len(&self) -> usize
impl<'a, P: image::Pixel + 'a> core::iter::traits::iterator::Iterator for image::buffer::PixelsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub type image::buffer::PixelsMut<'a, P>::Item = &'a mut P
pub fn image::buffer::PixelsMut<'a, P>::next(&mut self) -> core::option::Option<&'a mut P>
pub fn image::buffer::PixelsMut<'a, P>::size_hint(&self) -> (usize, core::option::Option<usize>)
impl<P: image::Pixel> core::fmt::Debug for image::buffer::PixelsMut<'_, P> where <P as image::Pixel>::Subpixel: core::fmt::Debug
pub fn image::buffer::PixelsMut<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::PixelsMut<'a, P>
impl<'a, P> core::marker::Send for image::buffer::PixelsMut<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Send
impl<'a, P> core::marker::Sync for image::buffer::PixelsMut<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Unpin for image::buffer::PixelsMut<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::PixelsMut<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> !core::panic::unwind_safe::UnwindSafe for image::buffer::PixelsMut<'a, P>
impl<I> core::iter::traits::collect::IntoIterator for image::buffer::PixelsMut<'a, P> where I: core::iter::traits::iterator::Iterator
pub type image::buffer::PixelsMut<'a, P>::IntoIter = I
pub type image::buffer::PixelsMut<'a, P>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::buffer::PixelsMut<'a, P>::into_iter(self) -> I
impl<T, U> core::convert::Into<U> for image::buffer::PixelsMut<'a, P> where U: core::convert::From<T>
pub fn image::buffer::PixelsMut<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::PixelsMut<'a, P> where U: core::convert::Into<T>
pub type image::buffer::PixelsMut<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::PixelsMut<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::PixelsMut<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::PixelsMut<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::PixelsMut<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::buffer::PixelsMut<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::PixelsMut<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::PixelsMut<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::PixelsMut<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::PixelsMut<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::PixelsMut<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::buffer::PixelsMut<'a, P>
pub fn image::buffer::PixelsMut<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::PixelsMut<'a, P>
pub type image::buffer::PixelsMut<'a, P>::Init = T
pub const image::buffer::PixelsMut<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::PixelsMut<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::PixelsMut<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::PixelsMut<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::PixelsMut<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::PixelsMut<'a, P>
impl<T> itertools::Itertools for image::buffer::PixelsMut<'a, P> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
pub struct image::buffer::PixelsMutPar<'a, P> where P: image::Pixel + core::marker::Send + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync + 'a
impl<'a, P> rayon::iter::IndexedParallelIterator for image::buffer::PixelsMutPar<'a, P> where P: image::Pixel + core::marker::Send + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync + 'a
pub fn image::buffer::PixelsMutPar<'a, P>::drive<C: rayon::iter::plumbing::Consumer<Self::Item>>(self, consumer: C) -> <C as rayon::iter::plumbing::Consumer>::Result
pub fn image::buffer::PixelsMutPar<'a, P>::len(&self) -> usize
pub fn image::buffer::PixelsMutPar<'a, P>::with_producer<CB: rayon::iter::plumbing::ProducerCallback<Self::Item>>(self, callback: CB) -> <CB as rayon::iter::plumbing::ProducerCallback>::Output
impl<'a, P> rayon::iter::ParallelIterator for image::buffer::PixelsMutPar<'a, P> where P: image::Pixel + core::marker::Send + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync + 'a
pub type image::buffer::PixelsMutPar<'a, P>::Item = &'a mut P
pub fn image::buffer::PixelsMutPar<'a, P>::drive_unindexed<C>(self, consumer: C) -> <C as rayon::iter::plumbing::Consumer>::Result where C: rayon::iter::plumbing::UnindexedConsumer<Self::Item>
pub fn image::buffer::PixelsMutPar<'a, P>::opt_len(&self) -> core::option::Option<usize>
impl<P> core::fmt::Debug for image::buffer::PixelsMutPar<'_, P> where P: image::Pixel + core::marker::Send + core::marker::Sync, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync + core::fmt::Debug
pub fn image::buffer::PixelsMutPar<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::PixelsMutPar<'a, P>
impl<'a, P> core::marker::Send for image::buffer::PixelsMutPar<'a, P>
impl<'a, P> core::marker::Sync for image::buffer::PixelsMutPar<'a, P>
impl<'a, P> core::marker::Unpin for image::buffer::PixelsMutPar<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::PixelsMutPar<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> !core::panic::unwind_safe::UnwindSafe for image::buffer::PixelsMutPar<'a, P>
impl<T, U> core::convert::Into<U> for image::buffer::PixelsMutPar<'a, P> where U: core::convert::From<T>
pub fn image::buffer::PixelsMutPar<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::PixelsMutPar<'a, P> where U: core::convert::Into<T>
pub type image::buffer::PixelsMutPar<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::PixelsMutPar<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::PixelsMutPar<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::PixelsMutPar<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::PixelsMutPar<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::buffer::PixelsMutPar<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::PixelsMutPar<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::PixelsMutPar<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::PixelsMutPar<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::PixelsMutPar<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::PixelsMutPar<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::buffer::PixelsMutPar<'a, P>
pub fn image::buffer::PixelsMutPar<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::PixelsMutPar<'a, P>
pub type image::buffer::PixelsMutPar<'a, P>::Init = T
pub const image::buffer::PixelsMutPar<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::PixelsMutPar<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::PixelsMutPar<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::PixelsMutPar<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::PixelsMutPar<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::PixelsMutPar<'a, P>
impl<T> rayon::iter::IntoParallelIterator for image::buffer::PixelsMutPar<'a, P> where T: rayon::iter::ParallelIterator
pub type image::buffer::PixelsMutPar<'a, P>::Item = <T as rayon::iter::ParallelIterator>::Item
pub type image::buffer::PixelsMutPar<'a, P>::Iter = T
pub fn image::buffer::PixelsMutPar<'a, P>::into_par_iter(self) -> T
pub struct image::buffer::PixelsPar<'a, P> where P: image::Pixel + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Sync + 'a
impl<'a, P> core::clone::Clone for image::buffer::PixelsPar<'a, P> where P: image::Pixel + core::marker::Sync + 'a + core::clone::Clone, <P as image::Pixel>::Subpixel: core::marker::Sync + 'a + core::clone::Clone
pub fn image::buffer::PixelsPar<'a, P>::clone(&self) -> image::buffer::PixelsPar<'a, P>
impl<'a, P> rayon::iter::IndexedParallelIterator for image::buffer::PixelsPar<'a, P> where P: image::Pixel + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Sync + 'a
pub fn image::buffer::PixelsPar<'a, P>::drive<C: rayon::iter::plumbing::Consumer<Self::Item>>(self, consumer: C) -> <C as rayon::iter::plumbing::Consumer>::Result
pub fn image::buffer::PixelsPar<'a, P>::len(&self) -> usize
pub fn image::buffer::PixelsPar<'a, P>::with_producer<CB: rayon::iter::plumbing::ProducerCallback<Self::Item>>(self, callback: CB) -> <CB as rayon::iter::plumbing::ProducerCallback>::Output
impl<'a, P> rayon::iter::ParallelIterator for image::buffer::PixelsPar<'a, P> where P: image::Pixel + core::marker::Sync + 'a, <P as image::Pixel>::Subpixel: core::marker::Sync + 'a
pub type image::buffer::PixelsPar<'a, P>::Item = &'a P
pub fn image::buffer::PixelsPar<'a, P>::drive_unindexed<C>(self, consumer: C) -> <C as rayon::iter::plumbing::Consumer>::Result where C: rayon::iter::plumbing::UnindexedConsumer<Self::Item>
pub fn image::buffer::PixelsPar<'a, P>::opt_len(&self) -> core::option::Option<usize>
impl<P> core::fmt::Debug for image::buffer::PixelsPar<'_, P> where P: image::Pixel + core::marker::Sync, <P as image::Pixel>::Subpixel: core::marker::Sync + core::fmt::Debug
pub fn image::buffer::PixelsPar<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::PixelsPar<'a, P>
impl<'a, P> core::marker::Send for image::buffer::PixelsPar<'a, P>
impl<'a, P> core::marker::Sync for image::buffer::PixelsPar<'a, P>
impl<'a, P> core::marker::Unpin for image::buffer::PixelsPar<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::PixelsPar<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> core::panic::unwind_safe::UnwindSafe for image::buffer::PixelsPar<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<T, U> core::convert::Into<U> for image::buffer::PixelsPar<'a, P> where U: core::convert::From<T>
pub fn image::buffer::PixelsPar<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::PixelsPar<'a, P> where U: core::convert::Into<T>
pub type image::buffer::PixelsPar<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::PixelsPar<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::PixelsPar<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::PixelsPar<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::PixelsPar<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::buffer::PixelsPar<'a, P> where T: core::clone::Clone
pub type image::buffer::PixelsPar<'a, P>::Owned = T
pub fn image::buffer::PixelsPar<'a, P>::clone_into(&self, target: &mut T)
pub fn image::buffer::PixelsPar<'a, P>::to_owned(&self) -> T
impl<T> core::any::Any for image::buffer::PixelsPar<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::PixelsPar<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::PixelsPar<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::PixelsPar<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::PixelsPar<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::PixelsPar<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::buffer::PixelsPar<'a, P> where T: core::clone::Clone
pub unsafe fn image::buffer::PixelsPar<'a, P>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::buffer::PixelsPar<'a, P>
pub fn image::buffer::PixelsPar<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::PixelsPar<'a, P>
pub type image::buffer::PixelsPar<'a, P>::Init = T
pub const image::buffer::PixelsPar<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::PixelsPar<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::PixelsPar<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::PixelsPar<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::PixelsPar<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::PixelsPar<'a, P>
impl<T> rayon::iter::IntoParallelIterator for image::buffer::PixelsPar<'a, P> where T: rayon::iter::ParallelIterator
pub type image::buffer::PixelsPar<'a, P>::Item = <T as rayon::iter::ParallelIterator>::Item
pub type image::buffer::PixelsPar<'a, P>::Iter = T
pub fn image::buffer::PixelsPar<'a, P>::into_par_iter(self) -> T
pub struct image::buffer::Rows<'a, P: image::Pixel + 'a> where <P as image::Pixel>::Subpixel: 'a
impl<'a, P: image::Pixel + 'a> core::iter::traits::double_ended::DoubleEndedIterator for image::buffer::Rows<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::Rows<'a, P>::next_back(&mut self) -> core::option::Option<image::buffer::Pixels<'a, P>>
impl<'a, P: image::Pixel + 'a> core::iter::traits::exact_size::ExactSizeIterator for image::buffer::Rows<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::Rows<'a, P>::len(&self) -> usize
impl<'a, P: image::Pixel + 'a> core::iter::traits::iterator::Iterator for image::buffer::Rows<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub type image::buffer::Rows<'a, P>::Item = image::buffer::Pixels<'a, P>
pub fn image::buffer::Rows<'a, P>::next(&mut self) -> core::option::Option<image::buffer::Pixels<'a, P>>
pub fn image::buffer::Rows<'a, P>::size_hint(&self) -> (usize, core::option::Option<usize>)
impl<P: image::Pixel> core::clone::Clone for image::buffer::Rows<'_, P>
pub fn image::buffer::Rows<'_, P>::clone(&self) -> Self
impl<P: image::Pixel> core::fmt::Debug for image::buffer::Rows<'_, P> where <P as image::Pixel>::Subpixel: core::fmt::Debug
pub fn image::buffer::Rows<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::Rows<'a, P>
impl<'a, P> core::marker::Send for image::buffer::Rows<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Sync for image::buffer::Rows<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Unpin for image::buffer::Rows<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::Rows<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> core::panic::unwind_safe::UnwindSafe for image::buffer::Rows<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<I> core::iter::traits::collect::IntoIterator for image::buffer::Rows<'a, P> where I: core::iter::traits::iterator::Iterator
pub type image::buffer::Rows<'a, P>::IntoIter = I
pub type image::buffer::Rows<'a, P>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::buffer::Rows<'a, P>::into_iter(self) -> I
impl<T, U> core::convert::Into<U> for image::buffer::Rows<'a, P> where U: core::convert::From<T>
pub fn image::buffer::Rows<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::Rows<'a, P> where U: core::convert::Into<T>
pub type image::buffer::Rows<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::Rows<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::Rows<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::Rows<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::Rows<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::buffer::Rows<'a, P> where T: core::clone::Clone
pub type image::buffer::Rows<'a, P>::Owned = T
pub fn image::buffer::Rows<'a, P>::clone_into(&self, target: &mut T)
pub fn image::buffer::Rows<'a, P>::to_owned(&self) -> T
impl<T> core::any::Any for image::buffer::Rows<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::Rows<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::Rows<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::Rows<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::Rows<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::Rows<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::buffer::Rows<'a, P> where T: core::clone::Clone
pub unsafe fn image::buffer::Rows<'a, P>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::buffer::Rows<'a, P>
pub fn image::buffer::Rows<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::Rows<'a, P>
pub type image::buffer::Rows<'a, P>::Init = T
pub const image::buffer::Rows<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::Rows<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::Rows<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::Rows<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::Rows<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::Rows<'a, P>
impl<T> itertools::Itertools for image::buffer::Rows<'a, P> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
pub struct image::buffer::RowsMut<'a, P: image::Pixel + 'a> where <P as image::Pixel>::Subpixel: 'a
impl<'a, P: image::Pixel + 'a> core::iter::traits::double_ended::DoubleEndedIterator for image::buffer::RowsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::RowsMut<'a, P>::next_back(&mut self) -> core::option::Option<image::buffer::PixelsMut<'a, P>>
impl<'a, P: image::Pixel + 'a> core::iter::traits::exact_size::ExactSizeIterator for image::buffer::RowsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub fn image::buffer::RowsMut<'a, P>::len(&self) -> usize
impl<'a, P: image::Pixel + 'a> core::iter::traits::iterator::Iterator for image::buffer::RowsMut<'a, P> where <P as image::Pixel>::Subpixel: 'a
pub type image::buffer::RowsMut<'a, P>::Item = image::buffer::PixelsMut<'a, P>
pub fn image::buffer::RowsMut<'a, P>::next(&mut self) -> core::option::Option<image::buffer::PixelsMut<'a, P>>
pub fn image::buffer::RowsMut<'a, P>::size_hint(&self) -> (usize, core::option::Option<usize>)
impl<P: image::Pixel> core::fmt::Debug for image::buffer::RowsMut<'_, P> where <P as image::Pixel>::Subpixel: core::fmt::Debug
pub fn image::buffer::RowsMut<'_, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'a, P> core::marker::Freeze for image::buffer::RowsMut<'a, P>
impl<'a, P> core::marker::Send for image::buffer::RowsMut<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Send
impl<'a, P> core::marker::Sync for image::buffer::RowsMut<'a, P> where <P as image::Pixel>::Subpixel: core::marker::Sync
impl<'a, P> core::marker::Unpin for image::buffer::RowsMut<'a, P>
impl<'a, P> core::panic::unwind_safe::RefUnwindSafe for image::buffer::RowsMut<'a, P> where <P as image::Pixel>::Subpixel: core::panic::unwind_safe::RefUnwindSafe
impl<'a, P> !core::panic::unwind_safe::UnwindSafe for image::buffer::RowsMut<'a, P>
impl<I> core::iter::traits::collect::IntoIterator for image::buffer::RowsMut<'a, P> where I: core::iter::traits::iterator::Iterator
pub type image::buffer::RowsMut<'a, P>::IntoIter = I
pub type image::buffer::RowsMut<'a, P>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::buffer::RowsMut<'a, P>::into_iter(self) -> I
impl<T, U> core::convert::Into<U> for image::buffer::RowsMut<'a, P> where U: core::convert::From<T>
pub fn image::buffer::RowsMut<'a, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::buffer::RowsMut<'a, P> where U: core::convert::Into<T>
pub type image::buffer::RowsMut<'a, P>::Error = core::convert::Infallible
pub fn image::buffer::RowsMut<'a, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::buffer::RowsMut<'a, P> where U: core::convert::TryFrom<T>
pub type image::buffer::RowsMut<'a, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::buffer::RowsMut<'a, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::buffer::RowsMut<'a, P> where T: 'static + ?core::marker::Sized
pub fn image::buffer::RowsMut<'a, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::buffer::RowsMut<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::RowsMut<'a, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::buffer::RowsMut<'a, P> where T: ?core::marker::Sized
pub fn image::buffer::RowsMut<'a, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::buffer::RowsMut<'a, P>
pub fn image::buffer::RowsMut<'a, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::buffer::RowsMut<'a, P>
pub type image::buffer::RowsMut<'a, P>::Init = T
pub const image::buffer::RowsMut<'a, P>::ALIGN: usize
pub unsafe fn image::buffer::RowsMut<'a, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::buffer::RowsMut<'a, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::buffer::RowsMut<'a, P>::drop(ptr: usize)
pub unsafe fn image::buffer::RowsMut<'a, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::buffer::RowsMut<'a, P>
impl<T> itertools::Itertools for image::buffer::RowsMut<'a, P> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
pub trait image::buffer::ConvertBuffer<T>
pub fn image::buffer::ConvertBuffer::convert(&self) -> T
impl<Container, FromType: image::Pixel, ToType> image::buffer::ConvertBuffer<image::ImageBuffer<ToType, alloc::vec::Vec<<ToType as image::Pixel>::Subpixel>>> for image::ImageBuffer<FromType, Container> where Container: core::ops::deref::Deref<Target = [<FromType as image::Pixel>::Subpixel]>, ToType: image::color::FromColor<FromType> + image::Pixel
pub fn image::ImageBuffer<FromType, Container>::convert(&self) -> image::ImageBuffer<ToType, alloc::vec::Vec<<ToType as image::Pixel>::Subpixel>>
pub mod image::codecs
pub mod image::codecs::avif
#[non_exhaustive] pub enum image::codecs::avif::ColorSpace
pub image::codecs::avif::ColorSpace::Bt709
pub image::codecs::avif::ColorSpace::Srgb
impl core::clone::Clone for image::codecs::avif::ColorSpace
pub fn image::codecs::avif::ColorSpace::clone(&self) -> image::codecs::avif::ColorSpace
impl core::cmp::Eq for image::codecs::avif::ColorSpace
impl core::cmp::PartialEq for image::codecs::avif::ColorSpace
pub fn image::codecs::avif::ColorSpace::eq(&self, other: &image::codecs::avif::ColorSpace) -> bool
impl core::fmt::Debug for image::codecs::avif::ColorSpace
pub fn image::codecs::avif::ColorSpace::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::avif::ColorSpace
impl core::marker::StructuralPartialEq for image::codecs::avif::ColorSpace
impl core::marker::Freeze for image::codecs::avif::ColorSpace
impl core::marker::Send for image::codecs::avif::ColorSpace
impl core::marker::Sync for image::codecs::avif::ColorSpace
impl core::marker::Unpin for image::codecs::avif::ColorSpace
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::avif::ColorSpace
impl core::panic::unwind_safe::UnwindSafe for image::codecs::avif::ColorSpace
impl<T, U> core::convert::Into<U> for image::codecs::avif::ColorSpace where U: core::convert::From<T>
pub fn image::codecs::avif::ColorSpace::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::avif::ColorSpace where U: core::convert::Into<T>
pub type image::codecs::avif::ColorSpace::Error = core::convert::Infallible
pub fn image::codecs::avif::ColorSpace::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::avif::ColorSpace where U: core::convert::TryFrom<T>
pub type image::codecs::avif::ColorSpace::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::avif::ColorSpace::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::avif::ColorSpace where T: core::clone::Clone
pub type image::codecs::avif::ColorSpace::Owned = T
pub fn image::codecs::avif::ColorSpace::clone_into(&self, target: &mut T)
pub fn image::codecs::avif::ColorSpace::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::avif::ColorSpace where T: 'static + ?core::marker::Sized
pub fn image::codecs::avif::ColorSpace::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::avif::ColorSpace where T: ?core::marker::Sized
pub fn image::codecs::avif::ColorSpace::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::avif::ColorSpace where T: ?core::marker::Sized
pub fn image::codecs::avif::ColorSpace::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::avif::ColorSpace where T: core::clone::Clone
pub unsafe fn image::codecs::avif::ColorSpace::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::avif::ColorSpace
pub fn image::codecs::avif::ColorSpace::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::avif::ColorSpace
pub type image::codecs::avif::ColorSpace::Init = T
pub const image::codecs::avif::ColorSpace::ALIGN: usize
pub unsafe fn image::codecs::avif::ColorSpace::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::avif::ColorSpace::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::avif::ColorSpace::drop(ptr: usize)
pub unsafe fn image::codecs::avif::ColorSpace::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::avif::ColorSpace
pub struct image::codecs::avif::AvifEncoder<W>
impl<W: std::io::Write> image::codecs::avif::AvifEncoder<W>
pub fn image::codecs::avif::AvifEncoder<W>::new(w: W) -> Self
pub fn image::codecs::avif::AvifEncoder<W>::new_with_speed_quality(w: W, speed: u8, quality: u8) -> Self
pub fn image::codecs::avif::AvifEncoder<W>::with_colorspace(self, color_space: image::codecs::avif::ColorSpace) -> Self
pub fn image::codecs::avif::AvifEncoder<W>::with_num_threads(self, num_threads: core::option::Option<usize>) -> Self
impl<W: std::io::Write> image::ImageEncoder for image::codecs::avif::AvifEncoder<W>
pub fn image::codecs::avif::AvifEncoder<W>::write_image(self, data: &[u8], width: u32, height: u32, color: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::avif::AvifEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::avif::AvifEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::avif::AvifEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::avif::AvifEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::avif::AvifEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::avif::AvifEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::avif::AvifEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::avif::AvifEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::avif::AvifEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::avif::AvifEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::avif::AvifEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::avif::AvifEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::avif::AvifEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::avif::AvifEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::avif::AvifEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::avif::AvifEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::avif::AvifEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::avif::AvifEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::avif::AvifEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::avif::AvifEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::avif::AvifEncoder<W>
pub fn image::codecs::avif::AvifEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::avif::AvifEncoder<W>
pub type image::codecs::avif::AvifEncoder<W>::Init = T
pub const image::codecs::avif::AvifEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::avif::AvifEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::avif::AvifEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::avif::AvifEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::avif::AvifEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::avif::AvifEncoder<W>
pub mod image::codecs::bmp
pub struct image::codecs::bmp::BmpDecoder<R>
impl<R: std::io::BufRead + std::io::Seek> image::codecs::bmp::BmpDecoder<R>
pub fn image::codecs::bmp::BmpDecoder<R>::get_palette(&self) -> core::option::Option<&[[u8; 3]]>
pub fn image::codecs::bmp::BmpDecoder<R>::new(reader: R) -> image::error::ImageResult<image::codecs::bmp::BmpDecoder<R>>
pub fn image::codecs::bmp::BmpDecoder<R>::new_without_file_header(reader: R) -> image::error::ImageResult<image::codecs::bmp::BmpDecoder<R>>
pub fn image::codecs::bmp::BmpDecoder<R>::set_indexed_color(&mut self, indexed_color: bool)
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::bmp::BmpDecoder<R>
pub fn image::codecs::bmp::BmpDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::bmp::BmpDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::bmp::BmpDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::bmp::BmpDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoderRect for image::codecs::bmp::BmpDecoder<R>
pub fn image::codecs::bmp::BmpDecoder<R>::read_rect(&mut self, x: u32, y: u32, width: u32, height: u32, buf: &mut [u8], row_pitch: usize) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::bmp::BmpDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::bmp::BmpDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::bmp::BmpDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::bmp::BmpDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::bmp::BmpDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::bmp::BmpDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::bmp::BmpDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::bmp::BmpDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::bmp::BmpDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::bmp::BmpDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::bmp::BmpDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::bmp::BmpDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::bmp::BmpDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::bmp::BmpDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::bmp::BmpDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::bmp::BmpDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::bmp::BmpDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::bmp::BmpDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::bmp::BmpDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::bmp::BmpDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::bmp::BmpDecoder<R>
pub fn image::codecs::bmp::BmpDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::bmp::BmpDecoder<R>
pub type image::codecs::bmp::BmpDecoder<R>::Init = T
pub const image::codecs::bmp::BmpDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::bmp::BmpDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::bmp::BmpDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::bmp::BmpDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::bmp::BmpDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::bmp::BmpDecoder<R>
pub struct image::codecs::bmp::BmpEncoder<'a, W: 'a>
impl<'a, W: std::io::Write + 'a> image::codecs::bmp::BmpEncoder<'a, W>
pub fn image::codecs::bmp::BmpEncoder<'a, W>::encode(&mut self, image: &[u8], width: u32, height: u32, c: image::ExtendedColorType) -> image::error::ImageResult<()>
pub fn image::codecs::bmp::BmpEncoder<'a, W>::encode_with_palette(&mut self, image: &[u8], width: u32, height: u32, c: image::ExtendedColorType, palette: core::option::Option<&[[u8; 3]]>) -> image::error::ImageResult<()>
pub fn image::codecs::bmp::BmpEncoder<'a, W>::new(w: &'a mut W) -> Self
impl<W: std::io::Write> image::ImageEncoder for image::codecs::bmp::BmpEncoder<'_, W>
pub fn image::codecs::bmp::BmpEncoder<'_, W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<'a, W> core::marker::Freeze for image::codecs::bmp::BmpEncoder<'a, W>
impl<'a, W> core::marker::Send for image::codecs::bmp::BmpEncoder<'a, W> where W: core::marker::Send
impl<'a, W> core::marker::Sync for image::codecs::bmp::BmpEncoder<'a, W> where W: core::marker::Sync
impl<'a, W> core::marker::Unpin for image::codecs::bmp::BmpEncoder<'a, W>
impl<'a, W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::bmp::BmpEncoder<'a, W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<'a, W> !core::panic::unwind_safe::UnwindSafe for image::codecs::bmp::BmpEncoder<'a, W>
impl<T, U> core::convert::Into<U> for image::codecs::bmp::BmpEncoder<'a, W> where U: core::convert::From<T>
pub fn image::codecs::bmp::BmpEncoder<'a, W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::bmp::BmpEncoder<'a, W> where U: core::convert::Into<T>
pub type image::codecs::bmp::BmpEncoder<'a, W>::Error = core::convert::Infallible
pub fn image::codecs::bmp::BmpEncoder<'a, W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::bmp::BmpEncoder<'a, W> where U: core::convert::TryFrom<T>
pub type image::codecs::bmp::BmpEncoder<'a, W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::bmp::BmpEncoder<'a, W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::bmp::BmpEncoder<'a, W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::bmp::BmpEncoder<'a, W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::bmp::BmpEncoder<'a, W> where T: ?core::marker::Sized
pub fn image::codecs::bmp::BmpEncoder<'a, W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::bmp::BmpEncoder<'a, W> where T: ?core::marker::Sized
pub fn image::codecs::bmp::BmpEncoder<'a, W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::bmp::BmpEncoder<'a, W>
pub fn image::codecs::bmp::BmpEncoder<'a, W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::bmp::BmpEncoder<'a, W>
pub type image::codecs::bmp::BmpEncoder<'a, W>::Init = T
pub const image::codecs::bmp::BmpEncoder<'a, W>::ALIGN: usize
pub unsafe fn image::codecs::bmp::BmpEncoder<'a, W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::bmp::BmpEncoder<'a, W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::bmp::BmpEncoder<'a, W>::drop(ptr: usize)
pub unsafe fn image::codecs::bmp::BmpEncoder<'a, W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::bmp::BmpEncoder<'a, W>
pub mod image::codecs::dds
pub struct image::codecs::dds::DdsDecoder<R: std::io::Read>
impl<R: std::io::Read> image::codecs::dds::DdsDecoder<R>
pub fn image::codecs::dds::DdsDecoder<R>::new(r: R) -> image::error::ImageResult<Self>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::dds::DdsDecoder<R>
pub fn image::codecs::dds::DdsDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::dds::DdsDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::dds::DdsDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::dds::DdsDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::dds::DdsDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::dds::DdsDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::dds::DdsDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::dds::DdsDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::dds::DdsDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::dds::DdsDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::dds::DdsDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::dds::DdsDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::dds::DdsDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::dds::DdsDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::dds::DdsDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::dds::DdsDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::dds::DdsDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::dds::DdsDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::dds::DdsDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::dds::DdsDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::dds::DdsDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::dds::DdsDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::dds::DdsDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::dds::DdsDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::dds::DdsDecoder<R>
pub fn image::codecs::dds::DdsDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::dds::DdsDecoder<R>
pub type image::codecs::dds::DdsDecoder<R>::Init = T
pub const image::codecs::dds::DdsDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::dds::DdsDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::dds::DdsDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::dds::DdsDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::dds::DdsDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::dds::DdsDecoder<R>
pub mod image::codecs::farbfeld
pub struct image::codecs::farbfeld::FarbfeldDecoder<R: std::io::Read>
impl<R: std::io::Read> image::codecs::farbfeld::FarbfeldDecoder<R>
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::new(buffered_read: R) -> image::error::ImageResult<image::codecs::farbfeld::FarbfeldDecoder<R>>
impl<R: std::io::Read + std::io::Seek> image::ImageDecoderRect for image::codecs::farbfeld::FarbfeldDecoder<R>
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::read_rect(&mut self, x: u32, y: u32, width: u32, height: u32, buf: &mut [u8], row_pitch: usize) -> image::error::ImageResult<()>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::farbfeld::FarbfeldDecoder<R>
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::farbfeld::FarbfeldDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::farbfeld::FarbfeldDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::farbfeld::FarbfeldDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::farbfeld::FarbfeldDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::farbfeld::FarbfeldDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::farbfeld::FarbfeldDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::farbfeld::FarbfeldDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::farbfeld::FarbfeldDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::farbfeld::FarbfeldDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::farbfeld::FarbfeldDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::farbfeld::FarbfeldDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::farbfeld::FarbfeldDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::farbfeld::FarbfeldDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::farbfeld::FarbfeldDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::farbfeld::FarbfeldDecoder<R>
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::farbfeld::FarbfeldDecoder<R>
pub type image::codecs::farbfeld::FarbfeldDecoder<R>::Init = T
pub const image::codecs::farbfeld::FarbfeldDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::farbfeld::FarbfeldDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::farbfeld::FarbfeldDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::farbfeld::FarbfeldDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::farbfeld::FarbfeldDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::farbfeld::FarbfeldDecoder<R>
pub struct image::codecs::farbfeld::FarbfeldEncoder<W: std::io::Write>
impl<W: std::io::Write> image::codecs::farbfeld::FarbfeldEncoder<W>
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::encode(self, data: &[u8], width: u32, height: u32) -> image::error::ImageResult<()>
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::new(buffered_writer: W) -> image::codecs::farbfeld::FarbfeldEncoder<W>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::farbfeld::FarbfeldEncoder<W>
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::farbfeld::FarbfeldEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::farbfeld::FarbfeldEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::farbfeld::FarbfeldEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::farbfeld::FarbfeldEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::farbfeld::FarbfeldEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::farbfeld::FarbfeldEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::farbfeld::FarbfeldEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::farbfeld::FarbfeldEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::farbfeld::FarbfeldEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::farbfeld::FarbfeldEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::farbfeld::FarbfeldEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::farbfeld::FarbfeldEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::farbfeld::FarbfeldEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::farbfeld::FarbfeldEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::farbfeld::FarbfeldEncoder<W>
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::farbfeld::FarbfeldEncoder<W>
pub type image::codecs::farbfeld::FarbfeldEncoder<W>::Init = T
pub const image::codecs::farbfeld::FarbfeldEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::farbfeld::FarbfeldEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::farbfeld::FarbfeldEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::farbfeld::FarbfeldEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::farbfeld::FarbfeldEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::farbfeld::FarbfeldEncoder<W>
pub struct image::codecs::farbfeld::FarbfeldReader<R: std::io::Read>
impl<R: std::io::Read + std::io::Seek> std::io::Seek for image::codecs::farbfeld::FarbfeldReader<R>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::seek(&mut self, pos: std::io::SeekFrom) -> std::io::error::Result<u64>
impl<R: std::io::Read> std::io::Read for image::codecs::farbfeld::FarbfeldReader<R>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read(&mut self, buf: &mut [u8]) -> std::io::error::Result<usize>
impl<R> core::marker::Freeze for image::codecs::farbfeld::FarbfeldReader<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::farbfeld::FarbfeldReader<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::farbfeld::FarbfeldReader<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::farbfeld::FarbfeldReader<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::farbfeld::FarbfeldReader<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::farbfeld::FarbfeldReader<R> where R: core::panic::unwind_safe::UnwindSafe
impl<R> byteorder_lite::io::ReadBytesExt for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read + ?core::marker::Sized
impl<R> lebe::io::ReadEndian<[f32]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [f32]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [f32]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[f64]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [f64]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [f64]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i128]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [i128]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [i128]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i16]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [i16]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [i16]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i32]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [i32]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [i32]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i64]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [i64]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [i64]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i8]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [i8]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [i8]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u128]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [u128]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [u128]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u16]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [u16]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [u16]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u32]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [u32]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [u32]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u64]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [u64]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [u64]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u8]> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut [u8]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut [u8]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<f32> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut f32) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut f32) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<f64> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut f64) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut f64) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i128> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut i128) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut i128) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i16> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut i16) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut i16) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i32> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut i32) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut i32) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i64> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut i64) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut i64) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i8> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut i8) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut i8) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u128> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut u128) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut u128) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u16> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut u16) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut u16) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u32> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut u32) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut u32) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u64> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut u64) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut u64) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u8> for image::codecs::farbfeld::FarbfeldReader<R> where R: std::io::Read
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_big_endian_into(&mut self, value: &mut u8) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::read_from_little_endian_into(&mut self, value: &mut u8) -> core::result::Result<(), std::io::error::Error>
impl<T, U> core::convert::Into<U> for image::codecs::farbfeld::FarbfeldReader<R> where U: core::convert::From<T>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::farbfeld::FarbfeldReader<R> where U: core::convert::Into<T>
pub type image::codecs::farbfeld::FarbfeldReader<R>::Error = core::convert::Infallible
pub fn image::codecs::farbfeld::FarbfeldReader<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::farbfeld::FarbfeldReader<R> where U: core::convert::TryFrom<T>
pub type image::codecs::farbfeld::FarbfeldReader<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::farbfeld::FarbfeldReader<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::farbfeld::FarbfeldReader<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::farbfeld::FarbfeldReader<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::farbfeld::FarbfeldReader<R> where T: ?core::marker::Sized
pub fn image::codecs::farbfeld::FarbfeldReader<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::farbfeld::FarbfeldReader<R> where T: ?core::marker::Sized
pub fn image::codecs::farbfeld::FarbfeldReader<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::farbfeld::FarbfeldReader<R>
pub fn image::codecs::farbfeld::FarbfeldReader<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::farbfeld::FarbfeldReader<R>
pub type image::codecs::farbfeld::FarbfeldReader<R>::Init = T
pub const image::codecs::farbfeld::FarbfeldReader<R>::ALIGN: usize
pub unsafe fn image::codecs::farbfeld::FarbfeldReader<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::farbfeld::FarbfeldReader<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::farbfeld::FarbfeldReader<R>::drop(ptr: usize)
pub unsafe fn image::codecs::farbfeld::FarbfeldReader<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::farbfeld::FarbfeldReader<R>
pub mod image::codecs::gif
pub enum image::codecs::gif::Repeat
pub image::codecs::gif::Repeat::Finite(u16)
pub image::codecs::gif::Repeat::Infinite
impl core::clone::Clone for image::codecs::gif::Repeat
pub fn image::codecs::gif::Repeat::clone(&self) -> image::codecs::gif::Repeat
impl core::fmt::Debug for image::codecs::gif::Repeat
pub fn image::codecs::gif::Repeat::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::gif::Repeat
impl core::marker::Freeze for image::codecs::gif::Repeat
impl core::marker::Send for image::codecs::gif::Repeat
impl core::marker::Sync for image::codecs::gif::Repeat
impl core::marker::Unpin for image::codecs::gif::Repeat
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::gif::Repeat
impl core::panic::unwind_safe::UnwindSafe for image::codecs::gif::Repeat
impl<T, U> core::convert::Into<U> for image::codecs::gif::Repeat where U: core::convert::From<T>
pub fn image::codecs::gif::Repeat::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::gif::Repeat where U: core::convert::Into<T>
pub type image::codecs::gif::Repeat::Error = core::convert::Infallible
pub fn image::codecs::gif::Repeat::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::gif::Repeat where U: core::convert::TryFrom<T>
pub type image::codecs::gif::Repeat::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::gif::Repeat::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::gif::Repeat where T: core::clone::Clone
pub type image::codecs::gif::Repeat::Owned = T
pub fn image::codecs::gif::Repeat::clone_into(&self, target: &mut T)
pub fn image::codecs::gif::Repeat::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::gif::Repeat where T: 'static + ?core::marker::Sized
pub fn image::codecs::gif::Repeat::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::gif::Repeat where T: ?core::marker::Sized
pub fn image::codecs::gif::Repeat::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::gif::Repeat where T: ?core::marker::Sized
pub fn image::codecs::gif::Repeat::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::gif::Repeat where T: core::clone::Clone
pub unsafe fn image::codecs::gif::Repeat::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::gif::Repeat
pub fn image::codecs::gif::Repeat::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::gif::Repeat
pub type image::codecs::gif::Repeat::Init = T
pub const image::codecs::gif::Repeat::ALIGN: usize
pub unsafe fn image::codecs::gif::Repeat::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::gif::Repeat::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::gif::Repeat::drop(ptr: usize)
pub unsafe fn image::codecs::gif::Repeat::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::gif::Repeat
pub struct image::codecs::gif::GifDecoder<R: std::io::Read>
impl<R: std::io::Read> image::codecs::gif::GifDecoder<R>
pub fn image::codecs::gif::GifDecoder<R>::new(r: R) -> image::error::ImageResult<image::codecs::gif::GifDecoder<R>>
impl<'a, R: std::io::BufRead + std::io::Seek + 'a> image::AnimationDecoder<'a> for image::codecs::gif::GifDecoder<R>
pub fn image::codecs::gif::GifDecoder<R>::into_frames(self) -> image::Frames<'a>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::gif::GifDecoder<R>
pub fn image::codecs::gif::GifDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::gif::GifDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::gif::GifDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::gif::GifDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::gif::GifDecoder<R>::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::gif::GifDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::gif::GifDecoder<R> where R: core::marker::Send
impl<R> !core::marker::Sync for image::codecs::gif::GifDecoder<R>
impl<R> core::marker::Unpin for image::codecs::gif::GifDecoder<R> where R: core::marker::Unpin
impl<R> !core::panic::unwind_safe::RefUnwindSafe for image::codecs::gif::GifDecoder<R>
impl<R> !core::panic::unwind_safe::UnwindSafe for image::codecs::gif::GifDecoder<R>
impl<T, U> core::convert::Into<U> for image::codecs::gif::GifDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::gif::GifDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::gif::GifDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::gif::GifDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::gif::GifDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::gif::GifDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::gif::GifDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::gif::GifDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::gif::GifDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::gif::GifDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::gif::GifDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::gif::GifDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::gif::GifDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::gif::GifDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::gif::GifDecoder<R>
pub fn image::codecs::gif::GifDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::gif::GifDecoder<R>
pub type image::codecs::gif::GifDecoder<R>::Init = T
pub const image::codecs::gif::GifDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::gif::GifDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::gif::GifDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::gif::GifDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::gif::GifDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::gif::GifDecoder<R>
pub struct image::codecs::gif::GifEncoder<W: std::io::Write>
impl<W: std::io::Write> image::codecs::gif::GifEncoder<W>
pub fn image::codecs::gif::GifEncoder<W>::encode(&mut self, data: &[u8], width: u32, height: u32, color: image::ExtendedColorType) -> image::error::ImageResult<()>
pub fn image::codecs::gif::GifEncoder<W>::encode_frame(&mut self, img_frame: image::Frame) -> image::error::ImageResult<()>
pub fn image::codecs::gif::GifEncoder<W>::encode_frames<F>(&mut self, frames: F) -> image::error::ImageResult<()> where F: core::iter::traits::collect::IntoIterator<Item = image::Frame>
pub fn image::codecs::gif::GifEncoder<W>::new(w: W) -> image::codecs::gif::GifEncoder<W>
pub fn image::codecs::gif::GifEncoder<W>::new_with_speed(w: W, speed: i32) -> image::codecs::gif::GifEncoder<W>
pub fn image::codecs::gif::GifEncoder<W>::set_repeat(&mut self, repeat: image::codecs::gif::Repeat) -> image::error::ImageResult<()>
pub fn image::codecs::gif::GifEncoder<W>::try_encode_frames<F>(&mut self, frames: F) -> image::error::ImageResult<()> where F: core::iter::traits::collect::IntoIterator<Item = image::error::ImageResult<image::Frame>>
impl<W> core::marker::Freeze for image::codecs::gif::GifEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::gif::GifEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::gif::GifEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::gif::GifEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::gif::GifEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::gif::GifEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::gif::GifEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::gif::GifEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::gif::GifEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::gif::GifEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::gif::GifEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::gif::GifEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::gif::GifEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::gif::GifEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::gif::GifEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::gif::GifEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::gif::GifEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::gif::GifEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::gif::GifEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::gif::GifEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::gif::GifEncoder<W>
pub fn image::codecs::gif::GifEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::gif::GifEncoder<W>
pub type image::codecs::gif::GifEncoder<W>::Init = T
pub const image::codecs::gif::GifEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::gif::GifEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::gif::GifEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::gif::GifEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::gif::GifEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::gif::GifEncoder<W>
pub struct image::codecs::gif::GifReader<R>(_, _)
impl<R> std::io::Read for image::codecs::gif::GifReader<R>
pub fn image::codecs::gif::GifReader<R>::read(&mut self, buf: &mut [u8]) -> std::io::error::Result<usize>
pub fn image::codecs::gif::GifReader<R>::read_to_end(&mut self, buf: &mut alloc::vec::Vec<u8>) -> std::io::error::Result<usize>
impl<R> core::marker::Freeze for image::codecs::gif::GifReader<R>
impl<R> core::marker::Send for image::codecs::gif::GifReader<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::gif::GifReader<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::gif::GifReader<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::gif::GifReader<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::gif::GifReader<R> where R: core::panic::unwind_safe::UnwindSafe
impl<R> byteorder_lite::io::ReadBytesExt for image::codecs::gif::GifReader<R> where R: std::io::Read + ?core::marker::Sized
impl<R> lebe::io::ReadEndian<[f32]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [f32]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [f32]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[f64]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [f64]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [f64]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i128]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [i128]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [i128]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i16]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [i16]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [i16]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i32]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [i32]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [i32]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i64]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [i64]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [i64]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i8]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [i8]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [i8]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u128]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [u128]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [u128]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u16]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [u16]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [u16]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u32]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [u32]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [u32]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u64]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [u64]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [u64]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u8]> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut [u8]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut [u8]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<f32> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut f32) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut f32) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<f64> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut f64) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut f64) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i128> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut i128) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut i128) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i16> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut i16) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut i16) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i32> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut i32) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut i32) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i64> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut i64) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut i64) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i8> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut i8) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut i8) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u128> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut u128) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut u128) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u16> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut u16) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut u16) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u32> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut u32) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut u32) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u64> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut u64) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut u64) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u8> for image::codecs::gif::GifReader<R> where R: std::io::Read
pub fn image::codecs::gif::GifReader<R>::read_from_big_endian_into(&mut self, value: &mut u8) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::gif::GifReader<R>::read_from_little_endian_into(&mut self, value: &mut u8) -> core::result::Result<(), std::io::error::Error>
impl<T, U> core::convert::Into<U> for image::codecs::gif::GifReader<R> where U: core::convert::From<T>
pub fn image::codecs::gif::GifReader<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::gif::GifReader<R> where U: core::convert::Into<T>
pub type image::codecs::gif::GifReader<R>::Error = core::convert::Infallible
pub fn image::codecs::gif::GifReader<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::gif::GifReader<R> where U: core::convert::TryFrom<T>
pub type image::codecs::gif::GifReader<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::gif::GifReader<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::gif::GifReader<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::gif::GifReader<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::gif::GifReader<R> where T: ?core::marker::Sized
pub fn image::codecs::gif::GifReader<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::gif::GifReader<R> where T: ?core::marker::Sized
pub fn image::codecs::gif::GifReader<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::gif::GifReader<R>
pub fn image::codecs::gif::GifReader<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::gif::GifReader<R>
pub type image::codecs::gif::GifReader<R>::Init = T
pub const image::codecs::gif::GifReader<R>::ALIGN: usize
pub unsafe fn image::codecs::gif::GifReader<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::gif::GifReader<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::gif::GifReader<R>::drop(ptr: usize)
pub unsafe fn image::codecs::gif::GifReader<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::gif::GifReader<R>
pub mod image::codecs::hdr
pub struct image::codecs::hdr::HdrDecoder<R>
impl<R: std::io::Read> image::codecs::hdr::HdrDecoder<R>
pub fn image::codecs::hdr::HdrDecoder<R>::metadata(&self) -> image::codecs::hdr::HdrMetadata
pub fn image::codecs::hdr::HdrDecoder<R>::new(reader: R) -> image::error::ImageResult<Self>
pub fn image::codecs::hdr::HdrDecoder<R>::new_nonstrict(reader: R) -> image::error::ImageResult<Self>
pub fn image::codecs::hdr::HdrDecoder<R>::with_strictness(reader: R, strict: bool) -> image::error::ImageResult<image::codecs::hdr::HdrDecoder<R>>
impl<R: core::fmt::Debug> core::fmt::Debug for image::codecs::hdr::HdrDecoder<R>
pub fn image::codecs::hdr::HdrDecoder<R>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<R: std::io::Read> image::ImageDecoder for image::codecs::hdr::HdrDecoder<R>
pub fn image::codecs::hdr::HdrDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::hdr::HdrDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::hdr::HdrDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::hdr::HdrDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::hdr::HdrDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::hdr::HdrDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::hdr::HdrDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::hdr::HdrDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::hdr::HdrDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::hdr::HdrDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::hdr::HdrDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::hdr::HdrDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::hdr::HdrDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::hdr::HdrDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::hdr::HdrDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::hdr::HdrDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::hdr::HdrDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::hdr::HdrDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::hdr::HdrDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::hdr::HdrDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::hdr::HdrDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::hdr::HdrDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::hdr::HdrDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::hdr::HdrDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::hdr::HdrDecoder<R>
pub fn image::codecs::hdr::HdrDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::hdr::HdrDecoder<R>
pub type image::codecs::hdr::HdrDecoder<R>::Init = T
pub const image::codecs::hdr::HdrDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::hdr::HdrDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::hdr::HdrDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::hdr::HdrDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::hdr::HdrDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::hdr::HdrDecoder<R>
pub struct image::codecs::hdr::HdrEncoder<W: std::io::Write>
impl<W: std::io::Write> image::codecs::hdr::HdrEncoder<W>
pub fn image::codecs::hdr::HdrEncoder<W>::encode(self, rgb: &[image::Rgb<f32>], width: usize, height: usize) -> image::error::ImageResult<()>
pub fn image::codecs::hdr::HdrEncoder<W>::new(w: W) -> image::codecs::hdr::HdrEncoder<W>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::hdr::HdrEncoder<W>
pub fn image::codecs::hdr::HdrEncoder<W>::write_image(self, unaligned_bytes: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::hdr::HdrEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::hdr::HdrEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::hdr::HdrEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::hdr::HdrEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::hdr::HdrEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::hdr::HdrEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::hdr::HdrEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::hdr::HdrEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::hdr::HdrEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::hdr::HdrEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::hdr::HdrEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::hdr::HdrEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::hdr::HdrEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::hdr::HdrEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::hdr::HdrEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::hdr::HdrEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::hdr::HdrEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::hdr::HdrEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::hdr::HdrEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::hdr::HdrEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::hdr::HdrEncoder<W>
pub fn image::codecs::hdr::HdrEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::hdr::HdrEncoder<W>
pub type image::codecs::hdr::HdrEncoder<W>::Init = T
pub const image::codecs::hdr::HdrEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::hdr::HdrEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::hdr::HdrEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::hdr::HdrEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::hdr::HdrEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::hdr::HdrEncoder<W>
pub struct image::codecs::hdr::HdrMetadata
pub image::codecs::hdr::HdrMetadata::color_correction: core::option::Option<(f32, f32, f32)>
pub image::codecs::hdr::HdrMetadata::custom_attributes: alloc::vec::Vec<(alloc::string::String, alloc::string::String)>
pub image::codecs::hdr::HdrMetadata::exposure: core::option::Option<f32>
pub image::codecs::hdr::HdrMetadata::height: u32
pub image::codecs::hdr::HdrMetadata::orientation: ((i8, i8), (i8, i8))
pub image::codecs::hdr::HdrMetadata::pixel_aspect_ratio: core::option::Option<f32>
pub image::codecs::hdr::HdrMetadata::width: u32
impl core::clone::Clone for image::codecs::hdr::HdrMetadata
pub fn image::codecs::hdr::HdrMetadata::clone(&self) -> image::codecs::hdr::HdrMetadata
impl core::fmt::Debug for image::codecs::hdr::HdrMetadata
pub fn image::codecs::hdr::HdrMetadata::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for image::codecs::hdr::HdrMetadata
impl core::marker::Send for image::codecs::hdr::HdrMetadata
impl core::marker::Sync for image::codecs::hdr::HdrMetadata
impl core::marker::Unpin for image::codecs::hdr::HdrMetadata
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::hdr::HdrMetadata
impl core::panic::unwind_safe::UnwindSafe for image::codecs::hdr::HdrMetadata
impl<T, U> core::convert::Into<U> for image::codecs::hdr::HdrMetadata where U: core::convert::From<T>
pub fn image::codecs::hdr::HdrMetadata::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::hdr::HdrMetadata where U: core::convert::Into<T>
pub type image::codecs::hdr::HdrMetadata::Error = core::convert::Infallible
pub fn image::codecs::hdr::HdrMetadata::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::hdr::HdrMetadata where U: core::convert::TryFrom<T>
pub type image::codecs::hdr::HdrMetadata::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::hdr::HdrMetadata::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::hdr::HdrMetadata where T: core::clone::Clone
pub type image::codecs::hdr::HdrMetadata::Owned = T
pub fn image::codecs::hdr::HdrMetadata::clone_into(&self, target: &mut T)
pub fn image::codecs::hdr::HdrMetadata::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::hdr::HdrMetadata where T: 'static + ?core::marker::Sized
pub fn image::codecs::hdr::HdrMetadata::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::hdr::HdrMetadata where T: ?core::marker::Sized
pub fn image::codecs::hdr::HdrMetadata::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::hdr::HdrMetadata where T: ?core::marker::Sized
pub fn image::codecs::hdr::HdrMetadata::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::hdr::HdrMetadata where T: core::clone::Clone
pub unsafe fn image::codecs::hdr::HdrMetadata::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::hdr::HdrMetadata
pub fn image::codecs::hdr::HdrMetadata::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::hdr::HdrMetadata
pub type image::codecs::hdr::HdrMetadata::Init = T
pub const image::codecs::hdr::HdrMetadata::ALIGN: usize
pub unsafe fn image::codecs::hdr::HdrMetadata::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::hdr::HdrMetadata::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::hdr::HdrMetadata::drop(ptr: usize)
pub unsafe fn image::codecs::hdr::HdrMetadata::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::hdr::HdrMetadata
pub const image::codecs::hdr::SIGNATURE: &[u8]
pub mod image::codecs::ico
pub struct image::codecs::ico::IcoDecoder<R: std::io::BufRead + std::io::Seek>
impl<R: std::io::BufRead + std::io::Seek> image::codecs::ico::IcoDecoder<R>
pub fn image::codecs::ico::IcoDecoder<R>::new(r: R) -> image::error::ImageResult<image::codecs::ico::IcoDecoder<R>>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::ico::IcoDecoder<R>
pub fn image::codecs::ico::IcoDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::ico::IcoDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::ico::IcoDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::ico::IcoDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::ico::IcoDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::ico::IcoDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::ico::IcoDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::ico::IcoDecoder<R> where R: core::marker::Unpin
impl<R> !core::panic::unwind_safe::RefUnwindSafe for image::codecs::ico::IcoDecoder<R>
impl<R> !core::panic::unwind_safe::UnwindSafe for image::codecs::ico::IcoDecoder<R>
impl<T, U> core::convert::Into<U> for image::codecs::ico::IcoDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::ico::IcoDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::ico::IcoDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::ico::IcoDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::ico::IcoDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::ico::IcoDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::ico::IcoDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::ico::IcoDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::ico::IcoDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::ico::IcoDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::ico::IcoDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::ico::IcoDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::ico::IcoDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::ico::IcoDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::ico::IcoDecoder<R>
pub fn image::codecs::ico::IcoDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::ico::IcoDecoder<R>
pub type image::codecs::ico::IcoDecoder<R>::Init = T
pub const image::codecs::ico::IcoDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::ico::IcoDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::ico::IcoDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::ico::IcoDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::ico::IcoDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::ico::IcoDecoder<R>
pub struct image::codecs::ico::IcoEncoder<W: std::io::Write>
impl<W: std::io::Write> image::codecs::ico::IcoEncoder<W>
pub fn image::codecs::ico::IcoEncoder<W>::encode_images(self, images: &[image::codecs::ico::IcoFrame<'_>]) -> image::error::ImageResult<()>
pub fn image::codecs::ico::IcoEncoder<W>::new(w: W) -> image::codecs::ico::IcoEncoder<W>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::ico::IcoEncoder<W>
pub fn image::codecs::ico::IcoEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::ico::IcoEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::ico::IcoEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::ico::IcoEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::ico::IcoEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::ico::IcoEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::ico::IcoEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::ico::IcoEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::ico::IcoEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::ico::IcoEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::ico::IcoEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::ico::IcoEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::ico::IcoEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::ico::IcoEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::ico::IcoEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::ico::IcoEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::ico::IcoEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::ico::IcoEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::ico::IcoEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::ico::IcoEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::ico::IcoEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::ico::IcoEncoder<W>
pub fn image::codecs::ico::IcoEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::ico::IcoEncoder<W>
pub type image::codecs::ico::IcoEncoder<W>::Init = T
pub const image::codecs::ico::IcoEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::ico::IcoEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::ico::IcoEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::ico::IcoEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::ico::IcoEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::ico::IcoEncoder<W>
pub struct image::codecs::ico::IcoFrame<'a>
impl<'a> image::codecs::ico::IcoFrame<'a>
pub fn image::codecs::ico::IcoFrame<'a>::as_png(buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<Self>
pub fn image::codecs::ico::IcoFrame<'a>::with_encoded(encoded_image: impl core::convert::Into<alloc::borrow::Cow<'a, [u8]>>, width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<Self>
impl<'a> core::marker::Freeze for image::codecs::ico::IcoFrame<'a>
impl<'a> core::marker::Send for image::codecs::ico::IcoFrame<'a>
impl<'a> core::marker::Sync for image::codecs::ico::IcoFrame<'a>
impl<'a> core::marker::Unpin for image::codecs::ico::IcoFrame<'a>
impl<'a> core::panic::unwind_safe::RefUnwindSafe for image::codecs::ico::IcoFrame<'a>
impl<'a> core::panic::unwind_safe::UnwindSafe for image::codecs::ico::IcoFrame<'a>
impl<T, U> core::convert::Into<U> for image::codecs::ico::IcoFrame<'a> where U: core::convert::From<T>
pub fn image::codecs::ico::IcoFrame<'a>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::ico::IcoFrame<'a> where U: core::convert::Into<T>
pub type image::codecs::ico::IcoFrame<'a>::Error = core::convert::Infallible
pub fn image::codecs::ico::IcoFrame<'a>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::ico::IcoFrame<'a> where U: core::convert::TryFrom<T>
pub type image::codecs::ico::IcoFrame<'a>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::ico::IcoFrame<'a>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::ico::IcoFrame<'a> where T: 'static + ?core::marker::Sized
pub fn image::codecs::ico::IcoFrame<'a>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::ico::IcoFrame<'a> where T: ?core::marker::Sized
pub fn image::codecs::ico::IcoFrame<'a>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::ico::IcoFrame<'a> where T: ?core::marker::Sized
pub fn image::codecs::ico::IcoFrame<'a>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::ico::IcoFrame<'a>
pub fn image::codecs::ico::IcoFrame<'a>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::ico::IcoFrame<'a>
pub type image::codecs::ico::IcoFrame<'a>::Init = T
pub const image::codecs::ico::IcoFrame<'a>::ALIGN: usize
pub unsafe fn image::codecs::ico::IcoFrame<'a>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::ico::IcoFrame<'a>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::ico::IcoFrame<'a>::drop(ptr: usize)
pub unsafe fn image::codecs::ico::IcoFrame<'a>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::ico::IcoFrame<'a>
pub mod image::codecs::jpeg
pub enum image::codecs::jpeg::PixelDensityUnit
pub image::codecs::jpeg::PixelDensityUnit::Centimeters
pub image::codecs::jpeg::PixelDensityUnit::Inches
pub image::codecs::jpeg::PixelDensityUnit::PixelAspectRatio
impl core::clone::Clone for image::codecs::jpeg::PixelDensityUnit
pub fn image::codecs::jpeg::PixelDensityUnit::clone(&self) -> image::codecs::jpeg::PixelDensityUnit
impl core::cmp::Eq for image::codecs::jpeg::PixelDensityUnit
impl core::cmp::PartialEq for image::codecs::jpeg::PixelDensityUnit
pub fn image::codecs::jpeg::PixelDensityUnit::eq(&self, other: &image::codecs::jpeg::PixelDensityUnit) -> bool
impl core::fmt::Debug for image::codecs::jpeg::PixelDensityUnit
pub fn image::codecs::jpeg::PixelDensityUnit::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::jpeg::PixelDensityUnit
impl core::marker::StructuralPartialEq for image::codecs::jpeg::PixelDensityUnit
impl core::marker::Freeze for image::codecs::jpeg::PixelDensityUnit
impl core::marker::Send for image::codecs::jpeg::PixelDensityUnit
impl core::marker::Sync for image::codecs::jpeg::PixelDensityUnit
impl core::marker::Unpin for image::codecs::jpeg::PixelDensityUnit
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::jpeg::PixelDensityUnit
impl core::panic::unwind_safe::UnwindSafe for image::codecs::jpeg::PixelDensityUnit
impl<T, U> core::convert::Into<U> for image::codecs::jpeg::PixelDensityUnit where U: core::convert::From<T>
pub fn image::codecs::jpeg::PixelDensityUnit::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::jpeg::PixelDensityUnit where U: core::convert::Into<T>
pub type image::codecs::jpeg::PixelDensityUnit::Error = core::convert::Infallible
pub fn image::codecs::jpeg::PixelDensityUnit::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::jpeg::PixelDensityUnit where U: core::convert::TryFrom<T>
pub type image::codecs::jpeg::PixelDensityUnit::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::jpeg::PixelDensityUnit::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::jpeg::PixelDensityUnit where T: core::clone::Clone
pub type image::codecs::jpeg::PixelDensityUnit::Owned = T
pub fn image::codecs::jpeg::PixelDensityUnit::clone_into(&self, target: &mut T)
pub fn image::codecs::jpeg::PixelDensityUnit::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::jpeg::PixelDensityUnit where T: 'static + ?core::marker::Sized
pub fn image::codecs::jpeg::PixelDensityUnit::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::jpeg::PixelDensityUnit where T: ?core::marker::Sized
pub fn image::codecs::jpeg::PixelDensityUnit::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::jpeg::PixelDensityUnit where T: ?core::marker::Sized
pub fn image::codecs::jpeg::PixelDensityUnit::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::jpeg::PixelDensityUnit where T: core::clone::Clone
pub unsafe fn image::codecs::jpeg::PixelDensityUnit::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::jpeg::PixelDensityUnit
pub fn image::codecs::jpeg::PixelDensityUnit::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::jpeg::PixelDensityUnit
pub type image::codecs::jpeg::PixelDensityUnit::Init = T
pub const image::codecs::jpeg::PixelDensityUnit::ALIGN: usize
pub unsafe fn image::codecs::jpeg::PixelDensityUnit::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::jpeg::PixelDensityUnit::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::jpeg::PixelDensityUnit::drop(ptr: usize)
pub unsafe fn image::codecs::jpeg::PixelDensityUnit::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::jpeg::PixelDensityUnit
pub struct image::codecs::jpeg::JpegDecoder<R>
impl<R: std::io::BufRead + std::io::Seek> image::codecs::jpeg::JpegDecoder<R>
pub fn image::codecs::jpeg::JpegDecoder<R>::new(r: R) -> image::error::ImageResult<image::codecs::jpeg::JpegDecoder<R>>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::jpeg::JpegDecoder<R>
pub fn image::codecs::jpeg::JpegDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::jpeg::JpegDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::jpeg::JpegDecoder<R>::exif_metadata(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::jpeg::JpegDecoder<R>::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::jpeg::JpegDecoder<R>::orientation(&mut self) -> image::error::ImageResult<image::metadata::Orientation>
pub fn image::codecs::jpeg::JpegDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::jpeg::JpegDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::jpeg::JpegDecoder<R>::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::jpeg::JpegDecoder<R>
impl<R> core::marker::Send for image::codecs::jpeg::JpegDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::jpeg::JpegDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::jpeg::JpegDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::jpeg::JpegDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::jpeg::JpegDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::jpeg::JpegDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::jpeg::JpegDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::jpeg::JpegDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::jpeg::JpegDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::jpeg::JpegDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::jpeg::JpegDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::jpeg::JpegDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::jpeg::JpegDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::jpeg::JpegDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::jpeg::JpegDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::jpeg::JpegDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::jpeg::JpegDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::jpeg::JpegDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::jpeg::JpegDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::jpeg::JpegDecoder<R>
pub fn image::codecs::jpeg::JpegDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::jpeg::JpegDecoder<R>
pub type image::codecs::jpeg::JpegDecoder<R>::Init = T
pub const image::codecs::jpeg::JpegDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::jpeg::JpegDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::jpeg::JpegDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::jpeg::JpegDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::jpeg::JpegDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::jpeg::JpegDecoder<R>
pub struct image::codecs::jpeg::JpegEncoder<W>
impl<W: std::io::Write> image::codecs::jpeg::JpegEncoder<W>
pub fn image::codecs::jpeg::JpegEncoder<W>::encode(&mut self, image: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
pub fn image::codecs::jpeg::JpegEncoder<W>::encode_image<I: image::GenericImageView>(&mut self, image: &I) -> image::error::ImageResult<()> where <I as image::GenericImageView>::Pixel: image::PixelWithColorType
pub fn image::codecs::jpeg::JpegEncoder<W>::new(w: W) -> image::codecs::jpeg::JpegEncoder<W>
pub fn image::codecs::jpeg::JpegEncoder<W>::new_with_quality(w: W, quality: u8) -> image::codecs::jpeg::JpegEncoder<W>
pub fn image::codecs::jpeg::JpegEncoder<W>::set_pixel_density(&mut self, pixel_density: image::codecs::jpeg::PixelDensity)
impl<W: std::io::Write> image::ImageEncoder for image::codecs::jpeg::JpegEncoder<W>
pub fn image::codecs::jpeg::JpegEncoder<W>::set_icc_profile(&mut self, icc_profile: alloc::vec::Vec<u8>) -> core::result::Result<(), image::error::UnsupportedError>
pub fn image::codecs::jpeg::JpegEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::jpeg::JpegEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::jpeg::JpegEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::jpeg::JpegEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::jpeg::JpegEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::jpeg::JpegEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::jpeg::JpegEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::jpeg::JpegEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::jpeg::JpegEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::jpeg::JpegEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::jpeg::JpegEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::jpeg::JpegEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::jpeg::JpegEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::jpeg::JpegEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::jpeg::JpegEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::jpeg::JpegEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::jpeg::JpegEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::jpeg::JpegEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::jpeg::JpegEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::jpeg::JpegEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::jpeg::JpegEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::jpeg::JpegEncoder<W>
pub fn image::codecs::jpeg::JpegEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::jpeg::JpegEncoder<W>
pub type image::codecs::jpeg::JpegEncoder<W>::Init = T
pub const image::codecs::jpeg::JpegEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::jpeg::JpegEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::jpeg::JpegEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::jpeg::JpegEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::jpeg::JpegEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::jpeg::JpegEncoder<W>
pub struct image::codecs::jpeg::PixelDensity
pub image::codecs::jpeg::PixelDensity::density: (u16, u16)
pub image::codecs::jpeg::PixelDensity::unit: image::codecs::jpeg::PixelDensityUnit
impl image::codecs::jpeg::PixelDensity
pub fn image::codecs::jpeg::PixelDensity::dpi(density: u16) -> Self
impl core::clone::Clone for image::codecs::jpeg::PixelDensity
pub fn image::codecs::jpeg::PixelDensity::clone(&self) -> image::codecs::jpeg::PixelDensity
impl core::cmp::Eq for image::codecs::jpeg::PixelDensity
impl core::cmp::PartialEq for image::codecs::jpeg::PixelDensity
pub fn image::codecs::jpeg::PixelDensity::eq(&self, other: &image::codecs::jpeg::PixelDensity) -> bool
impl core::default::Default for image::codecs::jpeg::PixelDensity
pub fn image::codecs::jpeg::PixelDensity::default() -> Self
impl core::fmt::Debug for image::codecs::jpeg::PixelDensity
pub fn image::codecs::jpeg::PixelDensity::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::jpeg::PixelDensity
impl core::marker::StructuralPartialEq for image::codecs::jpeg::PixelDensity
impl core::marker::Freeze for image::codecs::jpeg::PixelDensity
impl core::marker::Send for image::codecs::jpeg::PixelDensity
impl core::marker::Sync for image::codecs::jpeg::PixelDensity
impl core::marker::Unpin for image::codecs::jpeg::PixelDensity
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::jpeg::PixelDensity
impl core::panic::unwind_safe::UnwindSafe for image::codecs::jpeg::PixelDensity
impl<R, P> lebe::io::ReadPrimitive<R> for image::codecs::jpeg::PixelDensity where R: std::io::Read + lebe::io::ReadEndian<P>, P: core::default::Default
impl<T, U> core::convert::Into<U> for image::codecs::jpeg::PixelDensity where U: core::convert::From<T>
pub fn image::codecs::jpeg::PixelDensity::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::jpeg::PixelDensity where U: core::convert::Into<T>
pub type image::codecs::jpeg::PixelDensity::Error = core::convert::Infallible
pub fn image::codecs::jpeg::PixelDensity::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::jpeg::PixelDensity where U: core::convert::TryFrom<T>
pub type image::codecs::jpeg::PixelDensity::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::jpeg::PixelDensity::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::jpeg::PixelDensity where T: core::clone::Clone
pub type image::codecs::jpeg::PixelDensity::Owned = T
pub fn image::codecs::jpeg::PixelDensity::clone_into(&self, target: &mut T)
pub fn image::codecs::jpeg::PixelDensity::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::jpeg::PixelDensity where T: 'static + ?core::marker::Sized
pub fn image::codecs::jpeg::PixelDensity::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::jpeg::PixelDensity where T: ?core::marker::Sized
pub fn image::codecs::jpeg::PixelDensity::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::jpeg::PixelDensity where T: ?core::marker::Sized
pub fn image::codecs::jpeg::PixelDensity::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::jpeg::PixelDensity where T: core::clone::Clone
pub unsafe fn image::codecs::jpeg::PixelDensity::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::jpeg::PixelDensity
pub fn image::codecs::jpeg::PixelDensity::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::jpeg::PixelDensity
pub type image::codecs::jpeg::PixelDensity::Init = T
pub const image::codecs::jpeg::PixelDensity::ALIGN: usize
pub unsafe fn image::codecs::jpeg::PixelDensity::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::jpeg::PixelDensity::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::jpeg::PixelDensity::drop(ptr: usize)
pub unsafe fn image::codecs::jpeg::PixelDensity::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::jpeg::PixelDensity
pub mod image::codecs::openexr
pub struct image::codecs::openexr::OpenExrDecoder<R>
impl<R: std::io::BufRead + std::io::Seek> image::codecs::openexr::OpenExrDecoder<R>
pub fn image::codecs::openexr::OpenExrDecoder<R>::new(source: R) -> image::error::ImageResult<Self>
pub fn image::codecs::openexr::OpenExrDecoder<R>::with_alpha_preference(source: R, alpha_preference: core::option::Option<bool>) -> image::error::ImageResult<Self>
impl<R: core::fmt::Debug> core::fmt::Debug for image::codecs::openexr::OpenExrDecoder<R>
pub fn image::codecs::openexr::OpenExrDecoder<R>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::openexr::OpenExrDecoder<R>
pub fn image::codecs::openexr::OpenExrDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::openexr::OpenExrDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::openexr::OpenExrDecoder<R>::original_color_type(&self) -> image::ExtendedColorType
pub fn image::codecs::openexr::OpenExrDecoder<R>::read_image(self, unaligned_bytes: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::openexr::OpenExrDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::openexr::OpenExrDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::openexr::OpenExrDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::openexr::OpenExrDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::openexr::OpenExrDecoder<R> where R: core::marker::Unpin
impl<R> !core::panic::unwind_safe::RefUnwindSafe for image::codecs::openexr::OpenExrDecoder<R>
impl<R> !core::panic::unwind_safe::UnwindSafe for image::codecs::openexr::OpenExrDecoder<R>
impl<T, U> core::convert::Into<U> for image::codecs::openexr::OpenExrDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::openexr::OpenExrDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::openexr::OpenExrDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::openexr::OpenExrDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::openexr::OpenExrDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::openexr::OpenExrDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::openexr::OpenExrDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::openexr::OpenExrDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::openexr::OpenExrDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::openexr::OpenExrDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::openexr::OpenExrDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::openexr::OpenExrDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::openexr::OpenExrDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::openexr::OpenExrDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::openexr::OpenExrDecoder<R>
pub fn image::codecs::openexr::OpenExrDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::openexr::OpenExrDecoder<R>
pub type image::codecs::openexr::OpenExrDecoder<R>::Init = T
pub const image::codecs::openexr::OpenExrDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::openexr::OpenExrDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::openexr::OpenExrDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::openexr::OpenExrDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::openexr::OpenExrDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::openexr::OpenExrDecoder<R>
pub struct image::codecs::openexr::OpenExrEncoder<W>(_)
impl<W> image::codecs::openexr::OpenExrEncoder<W>
pub fn image::codecs::openexr::OpenExrEncoder<W>::new(write: W) -> Self
impl<W: core::fmt::Debug> core::fmt::Debug for image::codecs::openexr::OpenExrEncoder<W>
pub fn image::codecs::openexr::OpenExrEncoder<W>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<W> image::ImageEncoder for image::codecs::openexr::OpenExrEncoder<W> where W: std::io::Write + std::io::Seek
pub fn image::codecs::openexr::OpenExrEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::openexr::OpenExrEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::openexr::OpenExrEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::openexr::OpenExrEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::openexr::OpenExrEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::openexr::OpenExrEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::openexr::OpenExrEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::openexr::OpenExrEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::openexr::OpenExrEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::openexr::OpenExrEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::openexr::OpenExrEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::openexr::OpenExrEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::openexr::OpenExrEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::openexr::OpenExrEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::openexr::OpenExrEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::openexr::OpenExrEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::openexr::OpenExrEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::openexr::OpenExrEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::openexr::OpenExrEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::openexr::OpenExrEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::openexr::OpenExrEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::openexr::OpenExrEncoder<W>
pub fn image::codecs::openexr::OpenExrEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::openexr::OpenExrEncoder<W>
pub type image::codecs::openexr::OpenExrEncoder<W>::Init = T
pub const image::codecs::openexr::OpenExrEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::openexr::OpenExrEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::openexr::OpenExrEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::openexr::OpenExrEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::openexr::OpenExrEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::openexr::OpenExrEncoder<W>
pub mod image::codecs::png
#[non_exhaustive] pub enum image::codecs::png::CompressionType
pub image::codecs::png::CompressionType::Best
pub image::codecs::png::CompressionType::Default
pub image::codecs::png::CompressionType::Fast
impl core::clone::Clone for image::codecs::png::CompressionType
pub fn image::codecs::png::CompressionType::clone(&self) -> image::codecs::png::CompressionType
impl core::cmp::Eq for image::codecs::png::CompressionType
impl core::cmp::PartialEq for image::codecs::png::CompressionType
pub fn image::codecs::png::CompressionType::eq(&self, other: &image::codecs::png::CompressionType) -> bool
impl core::default::Default for image::codecs::png::CompressionType
pub fn image::codecs::png::CompressionType::default() -> image::codecs::png::CompressionType
impl core::fmt::Debug for image::codecs::png::CompressionType
pub fn image::codecs::png::CompressionType::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::png::CompressionType
impl core::marker::StructuralPartialEq for image::codecs::png::CompressionType
impl core::marker::Freeze for image::codecs::png::CompressionType
impl core::marker::Send for image::codecs::png::CompressionType
impl core::marker::Sync for image::codecs::png::CompressionType
impl core::marker::Unpin for image::codecs::png::CompressionType
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::png::CompressionType
impl core::panic::unwind_safe::UnwindSafe for image::codecs::png::CompressionType
impl<R, P> lebe::io::ReadPrimitive<R> for image::codecs::png::CompressionType where R: std::io::Read + lebe::io::ReadEndian<P>, P: core::default::Default
impl<T, U> core::convert::Into<U> for image::codecs::png::CompressionType where U: core::convert::From<T>
pub fn image::codecs::png::CompressionType::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::png::CompressionType where U: core::convert::Into<T>
pub type image::codecs::png::CompressionType::Error = core::convert::Infallible
pub fn image::codecs::png::CompressionType::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::png::CompressionType where U: core::convert::TryFrom<T>
pub type image::codecs::png::CompressionType::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::png::CompressionType::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::png::CompressionType where T: core::clone::Clone
pub type image::codecs::png::CompressionType::Owned = T
pub fn image::codecs::png::CompressionType::clone_into(&self, target: &mut T)
pub fn image::codecs::png::CompressionType::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::png::CompressionType where T: 'static + ?core::marker::Sized
pub fn image::codecs::png::CompressionType::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::png::CompressionType where T: ?core::marker::Sized
pub fn image::codecs::png::CompressionType::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::png::CompressionType where T: ?core::marker::Sized
pub fn image::codecs::png::CompressionType::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::png::CompressionType where T: core::clone::Clone
pub unsafe fn image::codecs::png::CompressionType::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::png::CompressionType
pub fn image::codecs::png::CompressionType::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::png::CompressionType
pub type image::codecs::png::CompressionType::Init = T
pub const image::codecs::png::CompressionType::ALIGN: usize
pub unsafe fn image::codecs::png::CompressionType::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::png::CompressionType::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::png::CompressionType::drop(ptr: usize)
pub unsafe fn image::codecs::png::CompressionType::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::png::CompressionType
#[non_exhaustive] pub enum image::codecs::png::FilterType
pub image::codecs::png::FilterType::Adaptive
pub image::codecs::png::FilterType::Avg
pub image::codecs::png::FilterType::NoFilter
pub image::codecs::png::FilterType::Paeth
pub image::codecs::png::FilterType::Sub
pub image::codecs::png::FilterType::Up
impl core::clone::Clone for image::codecs::png::FilterType
pub fn image::codecs::png::FilterType::clone(&self) -> image::codecs::png::FilterType
impl core::cmp::Eq for image::codecs::png::FilterType
impl core::cmp::PartialEq for image::codecs::png::FilterType
pub fn image::codecs::png::FilterType::eq(&self, other: &image::codecs::png::FilterType) -> bool
impl core::default::Default for image::codecs::png::FilterType
pub fn image::codecs::png::FilterType::default() -> image::codecs::png::FilterType
impl core::fmt::Debug for image::codecs::png::FilterType
pub fn image::codecs::png::FilterType::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::png::FilterType
impl core::marker::StructuralPartialEq for image::codecs::png::FilterType
impl core::marker::Freeze for image::codecs::png::FilterType
impl core::marker::Send for image::codecs::png::FilterType
impl core::marker::Sync for image::codecs::png::FilterType
impl core::marker::Unpin for image::codecs::png::FilterType
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::png::FilterType
impl core::panic::unwind_safe::UnwindSafe for image::codecs::png::FilterType
impl<R, P> lebe::io::ReadPrimitive<R> for image::codecs::png::FilterType where R: std::io::Read + lebe::io::ReadEndian<P>, P: core::default::Default
impl<T, U> core::convert::Into<U> for image::codecs::png::FilterType where U: core::convert::From<T>
pub fn image::codecs::png::FilterType::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::png::FilterType where U: core::convert::Into<T>
pub type image::codecs::png::FilterType::Error = core::convert::Infallible
pub fn image::codecs::png::FilterType::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::png::FilterType where U: core::convert::TryFrom<T>
pub type image::codecs::png::FilterType::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::png::FilterType::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::png::FilterType where T: core::clone::Clone
pub type image::codecs::png::FilterType::Owned = T
pub fn image::codecs::png::FilterType::clone_into(&self, target: &mut T)
pub fn image::codecs::png::FilterType::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::png::FilterType where T: 'static + ?core::marker::Sized
pub fn image::codecs::png::FilterType::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::png::FilterType where T: ?core::marker::Sized
pub fn image::codecs::png::FilterType::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::png::FilterType where T: ?core::marker::Sized
pub fn image::codecs::png::FilterType::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::png::FilterType where T: core::clone::Clone
pub unsafe fn image::codecs::png::FilterType::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::png::FilterType
pub fn image::codecs::png::FilterType::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::png::FilterType
pub type image::codecs::png::FilterType::Init = T
pub const image::codecs::png::FilterType::ALIGN: usize
pub unsafe fn image::codecs::png::FilterType::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::png::FilterType::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::png::FilterType::drop(ptr: usize)
pub unsafe fn image::codecs::png::FilterType::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::png::FilterType
pub struct image::codecs::png::ApngDecoder<R: std::io::BufRead + std::io::Seek>
impl<'a, R: std::io::BufRead + std::io::Seek + 'a> image::AnimationDecoder<'a> for image::codecs::png::ApngDecoder<R>
pub fn image::codecs::png::ApngDecoder<R>::into_frames(self) -> image::Frames<'a>
impl<R> core::marker::Freeze for image::codecs::png::ApngDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::png::ApngDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::png::ApngDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::png::ApngDecoder<R> where R: core::marker::Unpin
impl<R> !core::panic::unwind_safe::RefUnwindSafe for image::codecs::png::ApngDecoder<R>
impl<R> !core::panic::unwind_safe::UnwindSafe for image::codecs::png::ApngDecoder<R>
impl<T, U> core::convert::Into<U> for image::codecs::png::ApngDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::png::ApngDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::png::ApngDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::png::ApngDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::png::ApngDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::png::ApngDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::png::ApngDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::png::ApngDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::png::ApngDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::png::ApngDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::png::ApngDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::png::ApngDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::png::ApngDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::png::ApngDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::png::ApngDecoder<R>
pub fn image::codecs::png::ApngDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::png::ApngDecoder<R>
pub type image::codecs::png::ApngDecoder<R>::Init = T
pub const image::codecs::png::ApngDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::png::ApngDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::png::ApngDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::png::ApngDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::png::ApngDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::png::ApngDecoder<R>
pub struct image::codecs::png::PngDecoder<R: std::io::BufRead + std::io::Seek>
impl<R: std::io::BufRead + std::io::Seek> image::codecs::png::PngDecoder<R>
pub fn image::codecs::png::PngDecoder<R>::apng(self) -> image::error::ImageResult<image::codecs::png::ApngDecoder<R>>
pub fn image::codecs::png::PngDecoder<R>::gamma_value(&self) -> image::error::ImageResult<core::option::Option<f64>>
pub fn image::codecs::png::PngDecoder<R>::is_apng(&self) -> image::error::ImageResult<bool>
pub fn image::codecs::png::PngDecoder<R>::new(r: R) -> image::error::ImageResult<image::codecs::png::PngDecoder<R>>
pub fn image::codecs::png::PngDecoder<R>::with_limits(r: R, limits: image::Limits) -> image::error::ImageResult<image::codecs::png::PngDecoder<R>>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::png::PngDecoder<R>
pub fn image::codecs::png::PngDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::png::PngDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::png::PngDecoder<R>::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::png::PngDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::png::PngDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::png::PngDecoder<R>::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::png::PngDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::png::PngDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::png::PngDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::png::PngDecoder<R> where R: core::marker::Unpin
impl<R> !core::panic::unwind_safe::RefUnwindSafe for image::codecs::png::PngDecoder<R>
impl<R> !core::panic::unwind_safe::UnwindSafe for image::codecs::png::PngDecoder<R>
impl<T, U> core::convert::Into<U> for image::codecs::png::PngDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::png::PngDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::png::PngDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::png::PngDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::png::PngDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::png::PngDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::png::PngDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::png::PngDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::png::PngDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::png::PngDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::png::PngDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::png::PngDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::png::PngDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::png::PngDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::png::PngDecoder<R>
pub fn image::codecs::png::PngDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::png::PngDecoder<R>
pub type image::codecs::png::PngDecoder<R>::Init = T
pub const image::codecs::png::PngDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::png::PngDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::png::PngDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::png::PngDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::png::PngDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::png::PngDecoder<R>
pub struct image::codecs::png::PngEncoder<W: std::io::Write>
impl<W: std::io::Write> image::codecs::png::PngEncoder<W>
pub fn image::codecs::png::PngEncoder<W>::new(w: W) -> image::codecs::png::PngEncoder<W>
pub fn image::codecs::png::PngEncoder<W>::new_with_quality(w: W, compression: image::codecs::png::CompressionType, filter: image::codecs::png::FilterType) -> image::codecs::png::PngEncoder<W>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::png::PngEncoder<W>
pub fn image::codecs::png::PngEncoder<W>::set_icc_profile(&mut self, icc_profile: alloc::vec::Vec<u8>) -> core::result::Result<(), image::error::UnsupportedError>
pub fn image::codecs::png::PngEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::png::PngEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::png::PngEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::png::PngEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::png::PngEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::png::PngEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::png::PngEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::png::PngEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::png::PngEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::png::PngEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::png::PngEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::png::PngEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::png::PngEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::png::PngEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::png::PngEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::png::PngEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::png::PngEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::png::PngEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::png::PngEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::png::PngEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::png::PngEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::png::PngEncoder<W>
pub fn image::codecs::png::PngEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::png::PngEncoder<W>
pub type image::codecs::png::PngEncoder<W>::Init = T
pub const image::codecs::png::PngEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::png::PngEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::png::PngEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::png::PngEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::png::PngEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::png::PngEncoder<W>
pub mod image::codecs::pnm
pub enum image::codecs::pnm::ArbitraryTuplType
pub image::codecs::pnm::ArbitraryTuplType::BlackAndWhite
pub image::codecs::pnm::ArbitraryTuplType::BlackAndWhiteAlpha
pub image::codecs::pnm::ArbitraryTuplType::Custom(alloc::string::String)
pub image::codecs::pnm::ArbitraryTuplType::Grayscale
pub image::codecs::pnm::ArbitraryTuplType::GrayscaleAlpha
pub image::codecs::pnm::ArbitraryTuplType::RGB
pub image::codecs::pnm::ArbitraryTuplType::RGBAlpha
impl core::clone::Clone for image::codecs::pnm::ArbitraryTuplType
pub fn image::codecs::pnm::ArbitraryTuplType::clone(&self) -> image::codecs::pnm::ArbitraryTuplType
impl core::fmt::Debug for image::codecs::pnm::ArbitraryTuplType
pub fn image::codecs::pnm::ArbitraryTuplType::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for image::codecs::pnm::ArbitraryTuplType
impl core::marker::Send for image::codecs::pnm::ArbitraryTuplType
impl core::marker::Sync for image::codecs::pnm::ArbitraryTuplType
impl core::marker::Unpin for image::codecs::pnm::ArbitraryTuplType
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::ArbitraryTuplType
impl core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::ArbitraryTuplType
impl<T, U> core::convert::Into<U> for image::codecs::pnm::ArbitraryTuplType where U: core::convert::From<T>
pub fn image::codecs::pnm::ArbitraryTuplType::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::ArbitraryTuplType where U: core::convert::Into<T>
pub type image::codecs::pnm::ArbitraryTuplType::Error = core::convert::Infallible
pub fn image::codecs::pnm::ArbitraryTuplType::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::ArbitraryTuplType where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::ArbitraryTuplType::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::ArbitraryTuplType::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::pnm::ArbitraryTuplType where T: core::clone::Clone
pub type image::codecs::pnm::ArbitraryTuplType::Owned = T
pub fn image::codecs::pnm::ArbitraryTuplType::clone_into(&self, target: &mut T)
pub fn image::codecs::pnm::ArbitraryTuplType::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::pnm::ArbitraryTuplType where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::ArbitraryTuplType::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::ArbitraryTuplType where T: ?core::marker::Sized
pub fn image::codecs::pnm::ArbitraryTuplType::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::ArbitraryTuplType where T: ?core::marker::Sized
pub fn image::codecs::pnm::ArbitraryTuplType::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::pnm::ArbitraryTuplType where T: core::clone::Clone
pub unsafe fn image::codecs::pnm::ArbitraryTuplType::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::pnm::ArbitraryTuplType
pub fn image::codecs::pnm::ArbitraryTuplType::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::ArbitraryTuplType
pub type image::codecs::pnm::ArbitraryTuplType::Init = T
pub const image::codecs::pnm::ArbitraryTuplType::ALIGN: usize
pub unsafe fn image::codecs::pnm::ArbitraryTuplType::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::ArbitraryTuplType::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::ArbitraryTuplType::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::ArbitraryTuplType::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::ArbitraryTuplType
pub enum image::codecs::pnm::PnmSubtype
pub image::codecs::pnm::PnmSubtype::ArbitraryMap
pub image::codecs::pnm::PnmSubtype::Bitmap(image::codecs::pnm::SampleEncoding)
pub image::codecs::pnm::PnmSubtype::Graymap(image::codecs::pnm::SampleEncoding)
pub image::codecs::pnm::PnmSubtype::Pixmap(image::codecs::pnm::SampleEncoding)
impl image::codecs::pnm::PnmSubtype
pub fn image::codecs::pnm::PnmSubtype::magic_constant(self) -> &'static [u8; 2]
pub fn image::codecs::pnm::PnmSubtype::sample_encoding(self) -> image::codecs::pnm::SampleEncoding
impl core::clone::Clone for image::codecs::pnm::PnmSubtype
pub fn image::codecs::pnm::PnmSubtype::clone(&self) -> image::codecs::pnm::PnmSubtype
impl core::cmp::Eq for image::codecs::pnm::PnmSubtype
impl core::cmp::PartialEq for image::codecs::pnm::PnmSubtype
pub fn image::codecs::pnm::PnmSubtype::eq(&self, other: &image::codecs::pnm::PnmSubtype) -> bool
impl core::fmt::Debug for image::codecs::pnm::PnmSubtype
pub fn image::codecs::pnm::PnmSubtype::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::pnm::PnmSubtype
impl core::marker::StructuralPartialEq for image::codecs::pnm::PnmSubtype
impl core::marker::Freeze for image::codecs::pnm::PnmSubtype
impl core::marker::Send for image::codecs::pnm::PnmSubtype
impl core::marker::Sync for image::codecs::pnm::PnmSubtype
impl core::marker::Unpin for image::codecs::pnm::PnmSubtype
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::PnmSubtype
impl core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::PnmSubtype
impl<T, U> core::convert::Into<U> for image::codecs::pnm::PnmSubtype where U: core::convert::From<T>
pub fn image::codecs::pnm::PnmSubtype::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::PnmSubtype where U: core::convert::Into<T>
pub type image::codecs::pnm::PnmSubtype::Error = core::convert::Infallible
pub fn image::codecs::pnm::PnmSubtype::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::PnmSubtype where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::PnmSubtype::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::PnmSubtype::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::pnm::PnmSubtype where T: core::clone::Clone
pub type image::codecs::pnm::PnmSubtype::Owned = T
pub fn image::codecs::pnm::PnmSubtype::clone_into(&self, target: &mut T)
pub fn image::codecs::pnm::PnmSubtype::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::pnm::PnmSubtype where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::PnmSubtype::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::PnmSubtype where T: ?core::marker::Sized
pub fn image::codecs::pnm::PnmSubtype::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::PnmSubtype where T: ?core::marker::Sized
pub fn image::codecs::pnm::PnmSubtype::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::pnm::PnmSubtype where T: core::clone::Clone
pub unsafe fn image::codecs::pnm::PnmSubtype::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::pnm::PnmSubtype
pub fn image::codecs::pnm::PnmSubtype::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::PnmSubtype
pub type image::codecs::pnm::PnmSubtype::Init = T
pub const image::codecs::pnm::PnmSubtype::ALIGN: usize
pub unsafe fn image::codecs::pnm::PnmSubtype::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::PnmSubtype::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::PnmSubtype::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::PnmSubtype::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::PnmSubtype
pub enum image::codecs::pnm::SampleEncoding
pub image::codecs::pnm::SampleEncoding::Ascii
pub image::codecs::pnm::SampleEncoding::Binary
impl core::clone::Clone for image::codecs::pnm::SampleEncoding
pub fn image::codecs::pnm::SampleEncoding::clone(&self) -> image::codecs::pnm::SampleEncoding
impl core::cmp::Eq for image::codecs::pnm::SampleEncoding
impl core::cmp::PartialEq for image::codecs::pnm::SampleEncoding
pub fn image::codecs::pnm::SampleEncoding::eq(&self, other: &image::codecs::pnm::SampleEncoding) -> bool
impl core::fmt::Debug for image::codecs::pnm::SampleEncoding
pub fn image::codecs::pnm::SampleEncoding::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::pnm::SampleEncoding
impl core::marker::StructuralPartialEq for image::codecs::pnm::SampleEncoding
impl core::marker::Freeze for image::codecs::pnm::SampleEncoding
impl core::marker::Send for image::codecs::pnm::SampleEncoding
impl core::marker::Sync for image::codecs::pnm::SampleEncoding
impl core::marker::Unpin for image::codecs::pnm::SampleEncoding
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::SampleEncoding
impl core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::SampleEncoding
impl<T, U> core::convert::Into<U> for image::codecs::pnm::SampleEncoding where U: core::convert::From<T>
pub fn image::codecs::pnm::SampleEncoding::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::SampleEncoding where U: core::convert::Into<T>
pub type image::codecs::pnm::SampleEncoding::Error = core::convert::Infallible
pub fn image::codecs::pnm::SampleEncoding::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::SampleEncoding where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::SampleEncoding::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::SampleEncoding::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::pnm::SampleEncoding where T: core::clone::Clone
pub type image::codecs::pnm::SampleEncoding::Owned = T
pub fn image::codecs::pnm::SampleEncoding::clone_into(&self, target: &mut T)
pub fn image::codecs::pnm::SampleEncoding::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::pnm::SampleEncoding where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::SampleEncoding::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::SampleEncoding where T: ?core::marker::Sized
pub fn image::codecs::pnm::SampleEncoding::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::SampleEncoding where T: ?core::marker::Sized
pub fn image::codecs::pnm::SampleEncoding::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::pnm::SampleEncoding where T: core::clone::Clone
pub unsafe fn image::codecs::pnm::SampleEncoding::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::pnm::SampleEncoding
pub fn image::codecs::pnm::SampleEncoding::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::SampleEncoding
pub type image::codecs::pnm::SampleEncoding::Init = T
pub const image::codecs::pnm::SampleEncoding::ALIGN: usize
pub unsafe fn image::codecs::pnm::SampleEncoding::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::SampleEncoding::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::SampleEncoding::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::SampleEncoding::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::SampleEncoding
pub struct image::codecs::pnm::ArbitraryHeader
pub image::codecs::pnm::ArbitraryHeader::depth: u32
pub image::codecs::pnm::ArbitraryHeader::height: u32
pub image::codecs::pnm::ArbitraryHeader::maxval: u32
pub image::codecs::pnm::ArbitraryHeader::tupltype: core::option::Option<image::codecs::pnm::ArbitraryTuplType>
pub image::codecs::pnm::ArbitraryHeader::width: u32
impl core::clone::Clone for image::codecs::pnm::ArbitraryHeader
pub fn image::codecs::pnm::ArbitraryHeader::clone(&self) -> image::codecs::pnm::ArbitraryHeader
impl core::convert::From<image::codecs::pnm::ArbitraryHeader> for image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::from(header: image::codecs::pnm::ArbitraryHeader) -> Self
impl core::fmt::Debug for image::codecs::pnm::ArbitraryHeader
pub fn image::codecs::pnm::ArbitraryHeader::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Freeze for image::codecs::pnm::ArbitraryHeader
impl core::marker::Send for image::codecs::pnm::ArbitraryHeader
impl core::marker::Sync for image::codecs::pnm::ArbitraryHeader
impl core::marker::Unpin for image::codecs::pnm::ArbitraryHeader
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::ArbitraryHeader
impl core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::ArbitraryHeader
impl<T, U> core::convert::Into<U> for image::codecs::pnm::ArbitraryHeader where U: core::convert::From<T>
pub fn image::codecs::pnm::ArbitraryHeader::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::ArbitraryHeader where U: core::convert::Into<T>
pub type image::codecs::pnm::ArbitraryHeader::Error = core::convert::Infallible
pub fn image::codecs::pnm::ArbitraryHeader::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::ArbitraryHeader where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::ArbitraryHeader::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::ArbitraryHeader::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::pnm::ArbitraryHeader where T: core::clone::Clone
pub type image::codecs::pnm::ArbitraryHeader::Owned = T
pub fn image::codecs::pnm::ArbitraryHeader::clone_into(&self, target: &mut T)
pub fn image::codecs::pnm::ArbitraryHeader::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::pnm::ArbitraryHeader where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::ArbitraryHeader::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::ArbitraryHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::ArbitraryHeader::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::ArbitraryHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::ArbitraryHeader::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::pnm::ArbitraryHeader where T: core::clone::Clone
pub unsafe fn image::codecs::pnm::ArbitraryHeader::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::pnm::ArbitraryHeader
pub fn image::codecs::pnm::ArbitraryHeader::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::ArbitraryHeader
pub type image::codecs::pnm::ArbitraryHeader::Init = T
pub const image::codecs::pnm::ArbitraryHeader::ALIGN: usize
pub unsafe fn image::codecs::pnm::ArbitraryHeader::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::ArbitraryHeader::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::ArbitraryHeader::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::ArbitraryHeader::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::ArbitraryHeader
pub struct image::codecs::pnm::BitmapHeader
pub image::codecs::pnm::BitmapHeader::encoding: image::codecs::pnm::SampleEncoding
pub image::codecs::pnm::BitmapHeader::height: u32
pub image::codecs::pnm::BitmapHeader::width: u32
impl core::clone::Clone for image::codecs::pnm::BitmapHeader
pub fn image::codecs::pnm::BitmapHeader::clone(&self) -> image::codecs::pnm::BitmapHeader
impl core::convert::From<image::codecs::pnm::BitmapHeader> for image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::from(header: image::codecs::pnm::BitmapHeader) -> Self
impl core::fmt::Debug for image::codecs::pnm::BitmapHeader
pub fn image::codecs::pnm::BitmapHeader::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::pnm::BitmapHeader
impl core::marker::Freeze for image::codecs::pnm::BitmapHeader
impl core::marker::Send for image::codecs::pnm::BitmapHeader
impl core::marker::Sync for image::codecs::pnm::BitmapHeader
impl core::marker::Unpin for image::codecs::pnm::BitmapHeader
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::BitmapHeader
impl core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::BitmapHeader
impl<T, U> core::convert::Into<U> for image::codecs::pnm::BitmapHeader where U: core::convert::From<T>
pub fn image::codecs::pnm::BitmapHeader::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::BitmapHeader where U: core::convert::Into<T>
pub type image::codecs::pnm::BitmapHeader::Error = core::convert::Infallible
pub fn image::codecs::pnm::BitmapHeader::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::BitmapHeader where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::BitmapHeader::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::BitmapHeader::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::pnm::BitmapHeader where T: core::clone::Clone
pub type image::codecs::pnm::BitmapHeader::Owned = T
pub fn image::codecs::pnm::BitmapHeader::clone_into(&self, target: &mut T)
pub fn image::codecs::pnm::BitmapHeader::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::pnm::BitmapHeader where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::BitmapHeader::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::BitmapHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::BitmapHeader::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::BitmapHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::BitmapHeader::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::pnm::BitmapHeader where T: core::clone::Clone
pub unsafe fn image::codecs::pnm::BitmapHeader::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::pnm::BitmapHeader
pub fn image::codecs::pnm::BitmapHeader::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::BitmapHeader
pub type image::codecs::pnm::BitmapHeader::Init = T
pub const image::codecs::pnm::BitmapHeader::ALIGN: usize
pub unsafe fn image::codecs::pnm::BitmapHeader::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::BitmapHeader::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::BitmapHeader::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::BitmapHeader::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::BitmapHeader
pub struct image::codecs::pnm::GraymapHeader
pub image::codecs::pnm::GraymapHeader::encoding: image::codecs::pnm::SampleEncoding
pub image::codecs::pnm::GraymapHeader::height: u32
pub image::codecs::pnm::GraymapHeader::maxwhite: u32
pub image::codecs::pnm::GraymapHeader::width: u32
impl core::clone::Clone for image::codecs::pnm::GraymapHeader
pub fn image::codecs::pnm::GraymapHeader::clone(&self) -> image::codecs::pnm::GraymapHeader
impl core::convert::From<image::codecs::pnm::GraymapHeader> for image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::from(header: image::codecs::pnm::GraymapHeader) -> Self
impl core::fmt::Debug for image::codecs::pnm::GraymapHeader
pub fn image::codecs::pnm::GraymapHeader::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::pnm::GraymapHeader
impl core::marker::Freeze for image::codecs::pnm::GraymapHeader
impl core::marker::Send for image::codecs::pnm::GraymapHeader
impl core::marker::Sync for image::codecs::pnm::GraymapHeader
impl core::marker::Unpin for image::codecs::pnm::GraymapHeader
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::GraymapHeader
impl core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::GraymapHeader
impl<T, U> core::convert::Into<U> for image::codecs::pnm::GraymapHeader where U: core::convert::From<T>
pub fn image::codecs::pnm::GraymapHeader::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::GraymapHeader where U: core::convert::Into<T>
pub type image::codecs::pnm::GraymapHeader::Error = core::convert::Infallible
pub fn image::codecs::pnm::GraymapHeader::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::GraymapHeader where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::GraymapHeader::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::GraymapHeader::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::pnm::GraymapHeader where T: core::clone::Clone
pub type image::codecs::pnm::GraymapHeader::Owned = T
pub fn image::codecs::pnm::GraymapHeader::clone_into(&self, target: &mut T)
pub fn image::codecs::pnm::GraymapHeader::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::pnm::GraymapHeader where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::GraymapHeader::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::GraymapHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::GraymapHeader::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::GraymapHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::GraymapHeader::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::pnm::GraymapHeader where T: core::clone::Clone
pub unsafe fn image::codecs::pnm::GraymapHeader::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::pnm::GraymapHeader
pub fn image::codecs::pnm::GraymapHeader::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::GraymapHeader
pub type image::codecs::pnm::GraymapHeader::Init = T
pub const image::codecs::pnm::GraymapHeader::ALIGN: usize
pub unsafe fn image::codecs::pnm::GraymapHeader::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::GraymapHeader::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::GraymapHeader::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::GraymapHeader::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::GraymapHeader
pub struct image::codecs::pnm::PixmapHeader
pub image::codecs::pnm::PixmapHeader::encoding: image::codecs::pnm::SampleEncoding
pub image::codecs::pnm::PixmapHeader::height: u32
pub image::codecs::pnm::PixmapHeader::maxval: u32
pub image::codecs::pnm::PixmapHeader::width: u32
impl core::clone::Clone for image::codecs::pnm::PixmapHeader
pub fn image::codecs::pnm::PixmapHeader::clone(&self) -> image::codecs::pnm::PixmapHeader
impl core::convert::From<image::codecs::pnm::PixmapHeader> for image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::from(header: image::codecs::pnm::PixmapHeader) -> Self
impl core::fmt::Debug for image::codecs::pnm::PixmapHeader
pub fn image::codecs::pnm::PixmapHeader::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::codecs::pnm::PixmapHeader
impl core::marker::Freeze for image::codecs::pnm::PixmapHeader
impl core::marker::Send for image::codecs::pnm::PixmapHeader
impl core::marker::Sync for image::codecs::pnm::PixmapHeader
impl core::marker::Unpin for image::codecs::pnm::PixmapHeader
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::PixmapHeader
impl core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::PixmapHeader
impl<T, U> core::convert::Into<U> for image::codecs::pnm::PixmapHeader where U: core::convert::From<T>
pub fn image::codecs::pnm::PixmapHeader::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::PixmapHeader where U: core::convert::Into<T>
pub type image::codecs::pnm::PixmapHeader::Error = core::convert::Infallible
pub fn image::codecs::pnm::PixmapHeader::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::PixmapHeader where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::PixmapHeader::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::PixmapHeader::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::codecs::pnm::PixmapHeader where T: core::clone::Clone
pub type image::codecs::pnm::PixmapHeader::Owned = T
pub fn image::codecs::pnm::PixmapHeader::clone_into(&self, target: &mut T)
pub fn image::codecs::pnm::PixmapHeader::to_owned(&self) -> T
impl<T> core::any::Any for image::codecs::pnm::PixmapHeader where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::PixmapHeader::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::PixmapHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::PixmapHeader::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::PixmapHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::PixmapHeader::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::codecs::pnm::PixmapHeader where T: core::clone::Clone
pub unsafe fn image::codecs::pnm::PixmapHeader::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::codecs::pnm::PixmapHeader
pub fn image::codecs::pnm::PixmapHeader::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::PixmapHeader
pub type image::codecs::pnm::PixmapHeader::Init = T
pub const image::codecs::pnm::PixmapHeader::ALIGN: usize
pub unsafe fn image::codecs::pnm::PixmapHeader::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::PixmapHeader::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::PixmapHeader::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::PixmapHeader::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::PixmapHeader
pub struct image::codecs::pnm::PnmDecoder<R>
impl<R: std::io::Read> image::codecs::pnm::PnmDecoder<R>
pub fn image::codecs::pnm::PnmDecoder<R>::into_inner(self) -> (R, image::codecs::pnm::PnmHeader)
pub fn image::codecs::pnm::PnmDecoder<R>::new(buffered_read: R) -> image::error::ImageResult<image::codecs::pnm::PnmDecoder<R>>
impl<R: std::io::Read> image::codecs::pnm::PnmDecoder<R>
pub fn image::codecs::pnm::PnmDecoder<R>::subtype(&self) -> image::codecs::pnm::PnmSubtype
impl<R: std::io::Read> image::ImageDecoder for image::codecs::pnm::PnmDecoder<R>
pub fn image::codecs::pnm::PnmDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::pnm::PnmDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::pnm::PnmDecoder<R>::original_color_type(&self) -> image::ExtendedColorType
pub fn image::codecs::pnm::PnmDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::pnm::PnmDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::pnm::PnmDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::pnm::PnmDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::pnm::PnmDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::pnm::PnmDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::PnmDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::PnmDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::pnm::PnmDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::pnm::PnmDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::PnmDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::pnm::PnmDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::pnm::PnmDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::PnmDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::PnmDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::PnmDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::pnm::PnmDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::PnmDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::PnmDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::pnm::PnmDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::PnmDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::pnm::PnmDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::pnm::PnmDecoder<R>
pub fn image::codecs::pnm::PnmDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::PnmDecoder<R>
pub type image::codecs::pnm::PnmDecoder<R>::Init = T
pub const image::codecs::pnm::PnmDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::pnm::PnmDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::PnmDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::PnmDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::PnmDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::PnmDecoder<R>
pub struct image::codecs::pnm::PnmEncoder<W: std::io::Write>
impl<W: std::io::Write> image::codecs::pnm::PnmEncoder<W>
pub fn image::codecs::pnm::PnmEncoder<W>::encode<'s, S>(&mut self, image: S, width: u32, height: u32, color: image::ExtendedColorType) -> image::error::ImageResult<()> where S: core::convert::Into<image::codecs::pnm::encoder::FlatSamples<'s>>
pub fn image::codecs::pnm::PnmEncoder<W>::new(writer: W) -> Self
pub fn image::codecs::pnm::PnmEncoder<W>::with_dynamic_header(self) -> Self
pub fn image::codecs::pnm::PnmEncoder<W>::with_header(self, header: image::codecs::pnm::PnmHeader) -> Self
pub fn image::codecs::pnm::PnmEncoder<W>::with_subtype(self, subtype: image::codecs::pnm::PnmSubtype) -> Self
impl<W: std::io::Write> image::ImageEncoder for image::codecs::pnm::PnmEncoder<W>
pub fn image::codecs::pnm::PnmEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::pnm::PnmEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::pnm::PnmEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::pnm::PnmEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::pnm::PnmEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::PnmEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::PnmEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::pnm::PnmEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::pnm::PnmEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::PnmEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::pnm::PnmEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::pnm::PnmEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::PnmEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::PnmEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::PnmEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::pnm::PnmEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::PnmEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::PnmEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::pnm::PnmEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::PnmEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::pnm::PnmEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::pnm::PnmEncoder<W>
pub fn image::codecs::pnm::PnmEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::PnmEncoder<W>
pub type image::codecs::pnm::PnmEncoder<W>::Init = T
pub const image::codecs::pnm::PnmEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::pnm::PnmEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::PnmEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::PnmEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::PnmEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::PnmEncoder<W>
pub struct image::codecs::pnm::PnmHeader
impl image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::as_arbitrary(&self) -> core::option::Option<&image::codecs::pnm::ArbitraryHeader>
pub fn image::codecs::pnm::PnmHeader::as_bitmap(&self) -> core::option::Option<&image::codecs::pnm::BitmapHeader>
pub fn image::codecs::pnm::PnmHeader::as_graymap(&self) -> core::option::Option<&image::codecs::pnm::GraymapHeader>
pub fn image::codecs::pnm::PnmHeader::as_pixmap(&self) -> core::option::Option<&image::codecs::pnm::PixmapHeader>
pub fn image::codecs::pnm::PnmHeader::height(&self) -> u32
pub fn image::codecs::pnm::PnmHeader::maximal_sample(&self) -> u32
pub fn image::codecs::pnm::PnmHeader::subtype(&self) -> image::codecs::pnm::PnmSubtype
pub fn image::codecs::pnm::PnmHeader::width(&self) -> u32
pub fn image::codecs::pnm::PnmHeader::write(&self, writer: &mut dyn std::io::Write) -> std::io::error::Result<()>
impl core::convert::From<image::codecs::pnm::ArbitraryHeader> for image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::from(header: image::codecs::pnm::ArbitraryHeader) -> Self
impl core::convert::From<image::codecs::pnm::BitmapHeader> for image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::from(header: image::codecs::pnm::BitmapHeader) -> Self
impl core::convert::From<image::codecs::pnm::GraymapHeader> for image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::from(header: image::codecs::pnm::GraymapHeader) -> Self
impl core::convert::From<image::codecs::pnm::PixmapHeader> for image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::from(header: image::codecs::pnm::PixmapHeader) -> Self
impl core::marker::Freeze for image::codecs::pnm::PnmHeader
impl core::marker::Send for image::codecs::pnm::PnmHeader
impl core::marker::Sync for image::codecs::pnm::PnmHeader
impl core::marker::Unpin for image::codecs::pnm::PnmHeader
impl core::panic::unwind_safe::RefUnwindSafe for image::codecs::pnm::PnmHeader
impl core::panic::unwind_safe::UnwindSafe for image::codecs::pnm::PnmHeader
impl<T, U> core::convert::Into<U> for image::codecs::pnm::PnmHeader where U: core::convert::From<T>
pub fn image::codecs::pnm::PnmHeader::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::pnm::PnmHeader where U: core::convert::Into<T>
pub type image::codecs::pnm::PnmHeader::Error = core::convert::Infallible
pub fn image::codecs::pnm::PnmHeader::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::pnm::PnmHeader where U: core::convert::TryFrom<T>
pub type image::codecs::pnm::PnmHeader::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::pnm::PnmHeader::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::pnm::PnmHeader where T: 'static + ?core::marker::Sized
pub fn image::codecs::pnm::PnmHeader::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::pnm::PnmHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::PnmHeader::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::pnm::PnmHeader where T: ?core::marker::Sized
pub fn image::codecs::pnm::PnmHeader::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::pnm::PnmHeader
pub fn image::codecs::pnm::PnmHeader::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::pnm::PnmHeader
pub type image::codecs::pnm::PnmHeader::Init = T
pub const image::codecs::pnm::PnmHeader::ALIGN: usize
pub unsafe fn image::codecs::pnm::PnmHeader::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::pnm::PnmHeader::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::pnm::PnmHeader::drop(ptr: usize)
pub unsafe fn image::codecs::pnm::PnmHeader::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::pnm::PnmHeader
pub mod image::codecs::qoi
pub struct image::codecs::qoi::QoiDecoder<R>
impl<R> image::codecs::qoi::QoiDecoder<R> where R: std::io::Read
pub fn image::codecs::qoi::QoiDecoder<R>::new(reader: R) -> image::error::ImageResult<Self>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::qoi::QoiDecoder<R>
pub fn image::codecs::qoi::QoiDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::qoi::QoiDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::qoi::QoiDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::qoi::QoiDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::qoi::QoiDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::qoi::QoiDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::qoi::QoiDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::qoi::QoiDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::qoi::QoiDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::qoi::QoiDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::qoi::QoiDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::qoi::QoiDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::qoi::QoiDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::qoi::QoiDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::qoi::QoiDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::qoi::QoiDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::qoi::QoiDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::qoi::QoiDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::qoi::QoiDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::qoi::QoiDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::qoi::QoiDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::qoi::QoiDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::qoi::QoiDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::qoi::QoiDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::qoi::QoiDecoder<R>
pub fn image::codecs::qoi::QoiDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::qoi::QoiDecoder<R>
pub type image::codecs::qoi::QoiDecoder<R>::Init = T
pub const image::codecs::qoi::QoiDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::qoi::QoiDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::qoi::QoiDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::qoi::QoiDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::qoi::QoiDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::qoi::QoiDecoder<R>
pub struct image::codecs::qoi::QoiEncoder<W>
impl<W: std::io::Write> image::codecs::qoi::QoiEncoder<W>
pub fn image::codecs::qoi::QoiEncoder<W>::new(writer: W) -> Self
impl<W: std::io::Write> image::ImageEncoder for image::codecs::qoi::QoiEncoder<W>
pub fn image::codecs::qoi::QoiEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::qoi::QoiEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::qoi::QoiEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::qoi::QoiEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::qoi::QoiEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::qoi::QoiEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::qoi::QoiEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::qoi::QoiEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::qoi::QoiEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::qoi::QoiEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::qoi::QoiEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::qoi::QoiEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::qoi::QoiEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::qoi::QoiEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::qoi::QoiEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::qoi::QoiEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::qoi::QoiEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::qoi::QoiEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::qoi::QoiEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::qoi::QoiEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::qoi::QoiEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::qoi::QoiEncoder<W>
pub fn image::codecs::qoi::QoiEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::qoi::QoiEncoder<W>
pub type image::codecs::qoi::QoiEncoder<W>::Init = T
pub const image::codecs::qoi::QoiEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::qoi::QoiEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::qoi::QoiEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::qoi::QoiEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::qoi::QoiEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::qoi::QoiEncoder<W>
pub mod image::codecs::tga
pub struct image::codecs::tga::TgaDecoder<R>
impl<R: std::io::Read> image::codecs::tga::TgaDecoder<R>
pub fn image::codecs::tga::TgaDecoder<R>::new(r: R) -> image::error::ImageResult<image::codecs::tga::TgaDecoder<R>>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::tga::TgaDecoder<R>
pub fn image::codecs::tga::TgaDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::tga::TgaDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::tga::TgaDecoder<R>::original_color_type(&self) -> image::ExtendedColorType
pub fn image::codecs::tga::TgaDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::tga::TgaDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::tga::TgaDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::tga::TgaDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::tga::TgaDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::tga::TgaDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::tga::TgaDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::tga::TgaDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::tga::TgaDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::tga::TgaDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::tga::TgaDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::tga::TgaDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::tga::TgaDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::tga::TgaDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::tga::TgaDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::tga::TgaDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::tga::TgaDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::tga::TgaDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::tga::TgaDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::tga::TgaDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::tga::TgaDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::tga::TgaDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::tga::TgaDecoder<R>
pub fn image::codecs::tga::TgaDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::tga::TgaDecoder<R>
pub type image::codecs::tga::TgaDecoder<R>::Init = T
pub const image::codecs::tga::TgaDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::tga::TgaDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::tga::TgaDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::tga::TgaDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::tga::TgaDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::tga::TgaDecoder<R>
pub struct image::codecs::tga::TgaEncoder<W: std::io::Write>
impl<W: std::io::Write> image::codecs::tga::TgaEncoder<W>
pub fn image::codecs::tga::TgaEncoder<W>::disable_rle(self) -> image::codecs::tga::TgaEncoder<W>
pub fn image::codecs::tga::TgaEncoder<W>::encode(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
pub fn image::codecs::tga::TgaEncoder<W>::new(w: W) -> image::codecs::tga::TgaEncoder<W>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::tga::TgaEncoder<W>
pub fn image::codecs::tga::TgaEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::tga::TgaEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::tga::TgaEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::tga::TgaEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::tga::TgaEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::tga::TgaEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::tga::TgaEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::tga::TgaEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::tga::TgaEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::tga::TgaEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::tga::TgaEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::tga::TgaEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::tga::TgaEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::tga::TgaEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::tga::TgaEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::tga::TgaEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::tga::TgaEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::tga::TgaEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::tga::TgaEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::tga::TgaEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::tga::TgaEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::tga::TgaEncoder<W>
pub fn image::codecs::tga::TgaEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::tga::TgaEncoder<W>
pub type image::codecs::tga::TgaEncoder<W>::Init = T
pub const image::codecs::tga::TgaEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::tga::TgaEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::tga::TgaEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::tga::TgaEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::tga::TgaEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::tga::TgaEncoder<W>
pub mod image::codecs::tiff
pub struct image::codecs::tiff::TiffDecoder<R> where R: std::io::BufRead + std::io::Seek
impl<R> image::codecs::tiff::TiffDecoder<R> where R: std::io::BufRead + std::io::Seek
pub fn image::codecs::tiff::TiffDecoder<R>::new(r: R) -> core::result::Result<image::codecs::tiff::TiffDecoder<R>, image::error::ImageError>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::tiff::TiffDecoder<R>
pub fn image::codecs::tiff::TiffDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::tiff::TiffDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::tiff::TiffDecoder<R>::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::tiff::TiffDecoder<R>::orientation(&mut self) -> image::error::ImageResult<image::metadata::Orientation>
pub fn image::codecs::tiff::TiffDecoder<R>::original_color_type(&self) -> image::ExtendedColorType
pub fn image::codecs::tiff::TiffDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::tiff::TiffDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::tiff::TiffDecoder<R>::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::tiff::TiffDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::tiff::TiffDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::tiff::TiffDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::tiff::TiffDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::tiff::TiffDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::tiff::TiffDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::tiff::TiffDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::tiff::TiffDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::tiff::TiffDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::tiff::TiffDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::tiff::TiffDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::tiff::TiffDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::tiff::TiffDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::tiff::TiffDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::tiff::TiffDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::tiff::TiffDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::tiff::TiffDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::tiff::TiffDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::tiff::TiffDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::tiff::TiffDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::tiff::TiffDecoder<R>
pub fn image::codecs::tiff::TiffDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::tiff::TiffDecoder<R>
pub type image::codecs::tiff::TiffDecoder<R>::Init = T
pub const image::codecs::tiff::TiffDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::tiff::TiffDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::tiff::TiffDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::tiff::TiffDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::tiff::TiffDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::tiff::TiffDecoder<R>
pub struct image::codecs::tiff::TiffEncoder<W>
impl<W: std::io::Write + std::io::Seek> image::codecs::tiff::TiffEncoder<W>
pub fn image::codecs::tiff::TiffEncoder<W>::encode(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
pub fn image::codecs::tiff::TiffEncoder<W>::new(w: W) -> image::codecs::tiff::TiffEncoder<W>
impl<W: std::io::Write + std::io::Seek> image::ImageEncoder for image::codecs::tiff::TiffEncoder<W>
pub fn image::codecs::tiff::TiffEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::tiff::TiffEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::tiff::TiffEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::tiff::TiffEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::tiff::TiffEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::tiff::TiffEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::tiff::TiffEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::tiff::TiffEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::tiff::TiffEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::tiff::TiffEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::tiff::TiffEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::tiff::TiffEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::tiff::TiffEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::tiff::TiffEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::tiff::TiffEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::tiff::TiffEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::tiff::TiffEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::tiff::TiffEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::tiff::TiffEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::tiff::TiffEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::tiff::TiffEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::tiff::TiffEncoder<W>
pub fn image::codecs::tiff::TiffEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::tiff::TiffEncoder<W>
pub type image::codecs::tiff::TiffEncoder<W>::Init = T
pub const image::codecs::tiff::TiffEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::tiff::TiffEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::tiff::TiffEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::tiff::TiffEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::tiff::TiffEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::tiff::TiffEncoder<W>
pub struct image::codecs::tiff::TiffReader<R>(_, _)
impl<R> std::io::Read for image::codecs::tiff::TiffReader<R>
pub fn image::codecs::tiff::TiffReader<R>::read(&mut self, buf: &mut [u8]) -> std::io::error::Result<usize>
pub fn image::codecs::tiff::TiffReader<R>::read_to_end(&mut self, buf: &mut alloc::vec::Vec<u8>) -> std::io::error::Result<usize>
impl<R> core::marker::Freeze for image::codecs::tiff::TiffReader<R>
impl<R> core::marker::Send for image::codecs::tiff::TiffReader<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::tiff::TiffReader<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::tiff::TiffReader<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::tiff::TiffReader<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::tiff::TiffReader<R> where R: core::panic::unwind_safe::UnwindSafe
impl<R> byteorder_lite::io::ReadBytesExt for image::codecs::tiff::TiffReader<R> where R: std::io::Read + ?core::marker::Sized
impl<R> lebe::io::ReadEndian<[f32]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [f32]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [f32]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[f64]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [f64]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [f64]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i128]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [i128]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [i128]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i16]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [i16]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [i16]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i32]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [i32]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [i32]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i64]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [i64]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [i64]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[i8]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [i8]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [i8]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u128]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [u128]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [u128]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u16]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [u16]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [u16]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u32]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [u32]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [u32]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u64]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [u64]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [u64]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<[u8]> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut [u8]) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut [u8]) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<f32> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut f32) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut f32) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<f64> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut f64) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut f64) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i128> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut i128) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut i128) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i16> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut i16) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut i16) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i32> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut i32) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut i32) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i64> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut i64) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut i64) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<i8> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut i8) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut i8) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u128> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut u128) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut u128) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u16> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut u16) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut u16) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u32> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut u32) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut u32) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u64> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut u64) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut u64) -> core::result::Result<(), std::io::error::Error>
impl<R> lebe::io::ReadEndian<u8> for image::codecs::tiff::TiffReader<R> where R: std::io::Read
pub fn image::codecs::tiff::TiffReader<R>::read_from_big_endian_into(&mut self, value: &mut u8) -> core::result::Result<(), std::io::error::Error>
pub fn image::codecs::tiff::TiffReader<R>::read_from_little_endian_into(&mut self, value: &mut u8) -> core::result::Result<(), std::io::error::Error>
impl<T, U> core::convert::Into<U> for image::codecs::tiff::TiffReader<R> where U: core::convert::From<T>
pub fn image::codecs::tiff::TiffReader<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::tiff::TiffReader<R> where U: core::convert::Into<T>
pub type image::codecs::tiff::TiffReader<R>::Error = core::convert::Infallible
pub fn image::codecs::tiff::TiffReader<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::tiff::TiffReader<R> where U: core::convert::TryFrom<T>
pub type image::codecs::tiff::TiffReader<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::tiff::TiffReader<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::tiff::TiffReader<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::tiff::TiffReader<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::tiff::TiffReader<R> where T: ?core::marker::Sized
pub fn image::codecs::tiff::TiffReader<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::tiff::TiffReader<R> where T: ?core::marker::Sized
pub fn image::codecs::tiff::TiffReader<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::tiff::TiffReader<R>
pub fn image::codecs::tiff::TiffReader<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::tiff::TiffReader<R>
pub type image::codecs::tiff::TiffReader<R>::Init = T
pub const image::codecs::tiff::TiffReader<R>::ALIGN: usize
pub unsafe fn image::codecs::tiff::TiffReader<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::tiff::TiffReader<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::tiff::TiffReader<R>::drop(ptr: usize)
pub unsafe fn image::codecs::tiff::TiffReader<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::tiff::TiffReader<R>
pub mod image::codecs::webp
pub struct image::codecs::webp::WebPDecoder<R>
impl<R: std::io::BufRead + std::io::Seek> image::codecs::webp::WebPDecoder<R>
pub fn image::codecs::webp::WebPDecoder<R>::has_animation(&self) -> bool
pub fn image::codecs::webp::WebPDecoder<R>::new(r: R) -> image::error::ImageResult<Self>
pub fn image::codecs::webp::WebPDecoder<R>::set_background_color(&mut self, color: image::Rgba<u8>) -> image::error::ImageResult<()>
impl<'a, R: 'a + std::io::BufRead + std::io::Seek> image::AnimationDecoder<'a> for image::codecs::webp::WebPDecoder<R>
pub fn image::codecs::webp::WebPDecoder<R>::into_frames(self) -> image::Frames<'a>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::webp::WebPDecoder<R>
pub fn image::codecs::webp::WebPDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::webp::WebPDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::webp::WebPDecoder<R>::exif_metadata(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::webp::WebPDecoder<R>::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::webp::WebPDecoder<R>::orientation(&mut self) -> image::error::ImageResult<image::metadata::Orientation>
pub fn image::codecs::webp::WebPDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::webp::WebPDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R> core::marker::Freeze for image::codecs::webp::WebPDecoder<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::codecs::webp::WebPDecoder<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::codecs::webp::WebPDecoder<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::codecs::webp::WebPDecoder<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::codecs::webp::WebPDecoder<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::codecs::webp::WebPDecoder<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::webp::WebPDecoder<R> where U: core::convert::From<T>
pub fn image::codecs::webp::WebPDecoder<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::webp::WebPDecoder<R> where U: core::convert::Into<T>
pub type image::codecs::webp::WebPDecoder<R>::Error = core::convert::Infallible
pub fn image::codecs::webp::WebPDecoder<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::webp::WebPDecoder<R> where U: core::convert::TryFrom<T>
pub type image::codecs::webp::WebPDecoder<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::webp::WebPDecoder<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::webp::WebPDecoder<R> where T: 'static + ?core::marker::Sized
pub fn image::codecs::webp::WebPDecoder<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::webp::WebPDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::webp::WebPDecoder<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::webp::WebPDecoder<R> where T: ?core::marker::Sized
pub fn image::codecs::webp::WebPDecoder<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::webp::WebPDecoder<R>
pub fn image::codecs::webp::WebPDecoder<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::webp::WebPDecoder<R>
pub type image::codecs::webp::WebPDecoder<R>::Init = T
pub const image::codecs::webp::WebPDecoder<R>::ALIGN: usize
pub unsafe fn image::codecs::webp::WebPDecoder<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::webp::WebPDecoder<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::webp::WebPDecoder<R>::drop(ptr: usize)
pub unsafe fn image::codecs::webp::WebPDecoder<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::webp::WebPDecoder<R>
pub struct image::codecs::webp::WebPEncoder<W>
impl<W: std::io::Write> image::codecs::webp::WebPEncoder<W>
pub fn image::codecs::webp::WebPEncoder<W>::encode(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
pub fn image::codecs::webp::WebPEncoder<W>::new_lossless(w: W) -> Self
impl<W: std::io::Write> image::ImageEncoder for image::codecs::webp::WebPEncoder<W>
pub fn image::codecs::webp::WebPEncoder<W>::set_icc_profile(&mut self, icc_profile: alloc::vec::Vec<u8>) -> core::result::Result<(), image::error::UnsupportedError>
pub fn image::codecs::webp::WebPEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> core::marker::Freeze for image::codecs::webp::WebPEncoder<W> where W: core::marker::Freeze
impl<W> core::marker::Send for image::codecs::webp::WebPEncoder<W> where W: core::marker::Send
impl<W> core::marker::Sync for image::codecs::webp::WebPEncoder<W> where W: core::marker::Sync
impl<W> core::marker::Unpin for image::codecs::webp::WebPEncoder<W> where W: core::marker::Unpin
impl<W> core::panic::unwind_safe::RefUnwindSafe for image::codecs::webp::WebPEncoder<W> where W: core::panic::unwind_safe::RefUnwindSafe
impl<W> core::panic::unwind_safe::UnwindSafe for image::codecs::webp::WebPEncoder<W> where W: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::codecs::webp::WebPEncoder<W> where U: core::convert::From<T>
pub fn image::codecs::webp::WebPEncoder<W>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::codecs::webp::WebPEncoder<W> where U: core::convert::Into<T>
pub type image::codecs::webp::WebPEncoder<W>::Error = core::convert::Infallible
pub fn image::codecs::webp::WebPEncoder<W>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::codecs::webp::WebPEncoder<W> where U: core::convert::TryFrom<T>
pub type image::codecs::webp::WebPEncoder<W>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::codecs::webp::WebPEncoder<W>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::codecs::webp::WebPEncoder<W> where T: 'static + ?core::marker::Sized
pub fn image::codecs::webp::WebPEncoder<W>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::codecs::webp::WebPEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::webp::WebPEncoder<W>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::codecs::webp::WebPEncoder<W> where T: ?core::marker::Sized
pub fn image::codecs::webp::WebPEncoder<W>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::codecs::webp::WebPEncoder<W>
pub fn image::codecs::webp::WebPEncoder<W>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::codecs::webp::WebPEncoder<W>
pub type image::codecs::webp::WebPEncoder<W>::Init = T
pub const image::codecs::webp::WebPEncoder<W>::ALIGN: usize
pub unsafe fn image::codecs::webp::WebPEncoder<W>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::codecs::webp::WebPEncoder<W>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::codecs::webp::WebPEncoder<W>::drop(ptr: usize)
pub unsafe fn image::codecs::webp::WebPEncoder<W>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::codecs::webp::WebPEncoder<W>
pub mod image::error
pub enum image::error::ImageError
pub image::error::ImageError::Decoding(image::error::DecodingError)
pub image::error::ImageError::Encoding(image::error::EncodingError)
pub image::error::ImageError::IoError(std::io::error::Error)
pub image::error::ImageError::Limits(image::error::LimitError)
pub image::error::ImageError::Parameter(image::error::ParameterError)
pub image::error::ImageError::Unsupported(image::error::UnsupportedError)
impl core::convert::From<image::flat::Error> for image::error::ImageError
pub fn image::error::ImageError::from(error: image::flat::Error) -> image::error::ImageError
impl core::convert::From<std::io::error::Error> for image::error::ImageError
pub fn image::error::ImageError::from(err: std::io::error::Error) -> image::error::ImageError
impl core::error::Error for image::error::ImageError
pub fn image::error::ImageError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for image::error::ImageError
pub fn image::error::ImageError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for image::error::ImageError
pub fn image::error::ImageError::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error>
impl core::marker::Freeze for image::error::ImageError
impl core::marker::Send for image::error::ImageError
impl core::marker::Sync for image::error::ImageError
impl core::marker::Unpin for image::error::ImageError
impl !core::panic::unwind_safe::RefUnwindSafe for image::error::ImageError
impl !core::panic::unwind_safe::UnwindSafe for image::error::ImageError
impl<T, U> core::convert::Into<U> for image::error::ImageError where U: core::convert::From<T>
pub fn image::error::ImageError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::ImageError where U: core::convert::Into<T>
pub type image::error::ImageError::Error = core::convert::Infallible
pub fn image::error::ImageError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::ImageError where U: core::convert::TryFrom<T>
pub type image::error::ImageError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::ImageError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for image::error::ImageError where T: core::fmt::Display + ?core::marker::Sized
pub fn image::error::ImageError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for image::error::ImageError where T: 'static + ?core::marker::Sized
pub fn image::error::ImageError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::ImageError where T: ?core::marker::Sized
pub fn image::error::ImageError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::ImageError where T: ?core::marker::Sized
pub fn image::error::ImageError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::error::ImageError
pub fn image::error::ImageError::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::ImageError
pub type image::error::ImageError::Init = T
pub const image::error::ImageError::ALIGN: usize
pub unsafe fn image::error::ImageError::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::ImageError::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::ImageError::drop(ptr: usize)
pub unsafe fn image::error::ImageError::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::ImageError
#[non_exhaustive] pub enum image::error::ImageFormatHint
pub image::error::ImageFormatHint::Exact(image::ImageFormat)
pub image::error::ImageFormatHint::Name(alloc::string::String)
pub image::error::ImageFormatHint::PathExtension(std::path::PathBuf)
pub image::error::ImageFormatHint::Unknown
impl core::clone::Clone for image::error::ImageFormatHint
pub fn image::error::ImageFormatHint::clone(&self) -> image::error::ImageFormatHint
impl core::cmp::PartialEq for image::error::ImageFormatHint
pub fn image::error::ImageFormatHint::eq(&self, other: &image::error::ImageFormatHint) -> bool
impl core::convert::From<&std::path::Path> for image::error::ImageFormatHint
pub fn image::error::ImageFormatHint::from(path: &std::path::Path) -> Self
impl core::convert::From<image::ImageFormat> for image::error::ImageFormatHint
pub fn image::error::ImageFormatHint::from(format: image::ImageFormat) -> Self
impl core::convert::From<image::error::ImageFormatHint> for image::error::UnsupportedError
pub fn image::error::UnsupportedError::from(hint: image::error::ImageFormatHint) -> Self
impl core::fmt::Debug for image::error::ImageFormatHint
pub fn image::error::ImageFormatHint::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for image::error::ImageFormatHint
pub fn image::error::ImageFormatHint::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error>
impl core::hash::Hash for image::error::ImageFormatHint
pub fn image::error::ImageFormatHint::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for image::error::ImageFormatHint
impl core::marker::Freeze for image::error::ImageFormatHint
impl core::marker::Send for image::error::ImageFormatHint
impl core::marker::Sync for image::error::ImageFormatHint
impl core::marker::Unpin for image::error::ImageFormatHint
impl core::panic::unwind_safe::RefUnwindSafe for image::error::ImageFormatHint
impl core::panic::unwind_safe::UnwindSafe for image::error::ImageFormatHint
impl<T, U> core::convert::Into<U> for image::error::ImageFormatHint where U: core::convert::From<T>
pub fn image::error::ImageFormatHint::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::ImageFormatHint where U: core::convert::Into<T>
pub type image::error::ImageFormatHint::Error = core::convert::Infallible
pub fn image::error::ImageFormatHint::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::ImageFormatHint where U: core::convert::TryFrom<T>
pub type image::error::ImageFormatHint::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::ImageFormatHint::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::error::ImageFormatHint where T: core::clone::Clone
pub type image::error::ImageFormatHint::Owned = T
pub fn image::error::ImageFormatHint::clone_into(&self, target: &mut T)
pub fn image::error::ImageFormatHint::to_owned(&self) -> T
impl<T> alloc::string::ToString for image::error::ImageFormatHint where T: core::fmt::Display + ?core::marker::Sized
pub fn image::error::ImageFormatHint::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for image::error::ImageFormatHint where T: 'static + ?core::marker::Sized
pub fn image::error::ImageFormatHint::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::ImageFormatHint where T: ?core::marker::Sized
pub fn image::error::ImageFormatHint::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::ImageFormatHint where T: ?core::marker::Sized
pub fn image::error::ImageFormatHint::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::error::ImageFormatHint where T: core::clone::Clone
pub unsafe fn image::error::ImageFormatHint::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::error::ImageFormatHint
pub fn image::error::ImageFormatHint::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::ImageFormatHint
pub type image::error::ImageFormatHint::Init = T
pub const image::error::ImageFormatHint::ALIGN: usize
pub unsafe fn image::error::ImageFormatHint::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::ImageFormatHint::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::ImageFormatHint::drop(ptr: usize)
pub unsafe fn image::error::ImageFormatHint::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::ImageFormatHint
#[non_exhaustive] pub enum image::error::LimitErrorKind
pub image::error::LimitErrorKind::DimensionError
pub image::error::LimitErrorKind::InsufficientMemory
pub image::error::LimitErrorKind::Unsupported
pub image::error::LimitErrorKind::Unsupported::limits: image::Limits
pub image::error::LimitErrorKind::Unsupported::supported: image::LimitSupport
impl core::clone::Clone for image::error::LimitErrorKind
pub fn image::error::LimitErrorKind::clone(&self) -> image::error::LimitErrorKind
impl core::cmp::Eq for image::error::LimitErrorKind
impl core::cmp::PartialEq for image::error::LimitErrorKind
pub fn image::error::LimitErrorKind::eq(&self, other: &image::error::LimitErrorKind) -> bool
impl core::fmt::Debug for image::error::LimitErrorKind
pub fn image::error::LimitErrorKind::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::error::LimitErrorKind
pub fn image::error::LimitErrorKind::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for image::error::LimitErrorKind
impl core::marker::Freeze for image::error::LimitErrorKind
impl core::marker::Send for image::error::LimitErrorKind
impl core::marker::Sync for image::error::LimitErrorKind
impl core::marker::Unpin for image::error::LimitErrorKind
impl core::panic::unwind_safe::RefUnwindSafe for image::error::LimitErrorKind
impl core::panic::unwind_safe::UnwindSafe for image::error::LimitErrorKind
impl<T, U> core::convert::Into<U> for image::error::LimitErrorKind where U: core::convert::From<T>
pub fn image::error::LimitErrorKind::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::LimitErrorKind where U: core::convert::Into<T>
pub type image::error::LimitErrorKind::Error = core::convert::Infallible
pub fn image::error::LimitErrorKind::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::LimitErrorKind where U: core::convert::TryFrom<T>
pub type image::error::LimitErrorKind::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::LimitErrorKind::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::error::LimitErrorKind where T: core::clone::Clone
pub type image::error::LimitErrorKind::Owned = T
pub fn image::error::LimitErrorKind::clone_into(&self, target: &mut T)
pub fn image::error::LimitErrorKind::to_owned(&self) -> T
impl<T> core::any::Any for image::error::LimitErrorKind where T: 'static + ?core::marker::Sized
pub fn image::error::LimitErrorKind::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::LimitErrorKind where T: ?core::marker::Sized
pub fn image::error::LimitErrorKind::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::LimitErrorKind where T: ?core::marker::Sized
pub fn image::error::LimitErrorKind::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::error::LimitErrorKind where T: core::clone::Clone
pub unsafe fn image::error::LimitErrorKind::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::error::LimitErrorKind
pub fn image::error::LimitErrorKind::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::LimitErrorKind
pub type image::error::LimitErrorKind::Init = T
pub const image::error::LimitErrorKind::ALIGN: usize
pub unsafe fn image::error::LimitErrorKind::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::LimitErrorKind::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::LimitErrorKind::drop(ptr: usize)
pub unsafe fn image::error::LimitErrorKind::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::LimitErrorKind
#[non_exhaustive] pub enum image::error::ParameterErrorKind
pub image::error::ParameterErrorKind::DimensionMismatch
pub image::error::ParameterErrorKind::FailedAlready
pub image::error::ParameterErrorKind::Generic(alloc::string::String)
pub image::error::ParameterErrorKind::NoMoreData
impl core::clone::Clone for image::error::ParameterErrorKind
pub fn image::error::ParameterErrorKind::clone(&self) -> image::error::ParameterErrorKind
impl core::cmp::PartialEq for image::error::ParameterErrorKind
pub fn image::error::ParameterErrorKind::eq(&self, other: &image::error::ParameterErrorKind) -> bool
impl core::fmt::Debug for image::error::ParameterErrorKind
pub fn image::error::ParameterErrorKind::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::error::ParameterErrorKind
pub fn image::error::ParameterErrorKind::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for image::error::ParameterErrorKind
impl core::marker::Freeze for image::error::ParameterErrorKind
impl core::marker::Send for image::error::ParameterErrorKind
impl core::marker::Sync for image::error::ParameterErrorKind
impl core::marker::Unpin for image::error::ParameterErrorKind
impl core::panic::unwind_safe::RefUnwindSafe for image::error::ParameterErrorKind
impl core::panic::unwind_safe::UnwindSafe for image::error::ParameterErrorKind
impl<T, U> core::convert::Into<U> for image::error::ParameterErrorKind where U: core::convert::From<T>
pub fn image::error::ParameterErrorKind::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::ParameterErrorKind where U: core::convert::Into<T>
pub type image::error::ParameterErrorKind::Error = core::convert::Infallible
pub fn image::error::ParameterErrorKind::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::ParameterErrorKind where U: core::convert::TryFrom<T>
pub type image::error::ParameterErrorKind::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::ParameterErrorKind::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::error::ParameterErrorKind where T: core::clone::Clone
pub type image::error::ParameterErrorKind::Owned = T
pub fn image::error::ParameterErrorKind::clone_into(&self, target: &mut T)
pub fn image::error::ParameterErrorKind::to_owned(&self) -> T
impl<T> core::any::Any for image::error::ParameterErrorKind where T: 'static + ?core::marker::Sized
pub fn image::error::ParameterErrorKind::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::ParameterErrorKind where T: ?core::marker::Sized
pub fn image::error::ParameterErrorKind::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::ParameterErrorKind where T: ?core::marker::Sized
pub fn image::error::ParameterErrorKind::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::error::ParameterErrorKind where T: core::clone::Clone
pub unsafe fn image::error::ParameterErrorKind::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::error::ParameterErrorKind
pub fn image::error::ParameterErrorKind::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::ParameterErrorKind
pub type image::error::ParameterErrorKind::Init = T
pub const image::error::ParameterErrorKind::ALIGN: usize
pub unsafe fn image::error::ParameterErrorKind::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::ParameterErrorKind::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::ParameterErrorKind::drop(ptr: usize)
pub unsafe fn image::error::ParameterErrorKind::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::ParameterErrorKind
#[non_exhaustive] pub enum image::error::UnsupportedErrorKind
pub image::error::UnsupportedErrorKind::Color(image::ExtendedColorType)
pub image::error::UnsupportedErrorKind::Format(image::error::ImageFormatHint)
pub image::error::UnsupportedErrorKind::GenericFeature(alloc::string::String)
impl core::clone::Clone for image::error::UnsupportedErrorKind
pub fn image::error::UnsupportedErrorKind::clone(&self) -> image::error::UnsupportedErrorKind
impl core::cmp::PartialEq for image::error::UnsupportedErrorKind
pub fn image::error::UnsupportedErrorKind::eq(&self, other: &image::error::UnsupportedErrorKind) -> bool
impl core::fmt::Debug for image::error::UnsupportedErrorKind
pub fn image::error::UnsupportedErrorKind::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::error::UnsupportedErrorKind
pub fn image::error::UnsupportedErrorKind::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for image::error::UnsupportedErrorKind
impl core::marker::Freeze for image::error::UnsupportedErrorKind
impl core::marker::Send for image::error::UnsupportedErrorKind
impl core::marker::Sync for image::error::UnsupportedErrorKind
impl core::marker::Unpin for image::error::UnsupportedErrorKind
impl core::panic::unwind_safe::RefUnwindSafe for image::error::UnsupportedErrorKind
impl core::panic::unwind_safe::UnwindSafe for image::error::UnsupportedErrorKind
impl<T, U> core::convert::Into<U> for image::error::UnsupportedErrorKind where U: core::convert::From<T>
pub fn image::error::UnsupportedErrorKind::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::UnsupportedErrorKind where U: core::convert::Into<T>
pub type image::error::UnsupportedErrorKind::Error = core::convert::Infallible
pub fn image::error::UnsupportedErrorKind::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::UnsupportedErrorKind where U: core::convert::TryFrom<T>
pub type image::error::UnsupportedErrorKind::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::UnsupportedErrorKind::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::error::UnsupportedErrorKind where T: core::clone::Clone
pub type image::error::UnsupportedErrorKind::Owned = T
pub fn image::error::UnsupportedErrorKind::clone_into(&self, target: &mut T)
pub fn image::error::UnsupportedErrorKind::to_owned(&self) -> T
impl<T> core::any::Any for image::error::UnsupportedErrorKind where T: 'static + ?core::marker::Sized
pub fn image::error::UnsupportedErrorKind::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::UnsupportedErrorKind where T: ?core::marker::Sized
pub fn image::error::UnsupportedErrorKind::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::UnsupportedErrorKind where T: ?core::marker::Sized
pub fn image::error::UnsupportedErrorKind::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::error::UnsupportedErrorKind where T: core::clone::Clone
pub unsafe fn image::error::UnsupportedErrorKind::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::error::UnsupportedErrorKind
pub fn image::error::UnsupportedErrorKind::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::UnsupportedErrorKind
pub type image::error::UnsupportedErrorKind::Init = T
pub const image::error::UnsupportedErrorKind::ALIGN: usize
pub unsafe fn image::error::UnsupportedErrorKind::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::UnsupportedErrorKind::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::UnsupportedErrorKind::drop(ptr: usize)
pub unsafe fn image::error::UnsupportedErrorKind::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::UnsupportedErrorKind
pub struct image::error::DecodingError
impl image::error::DecodingError
pub fn image::error::DecodingError::format_hint(&self) -> image::error::ImageFormatHint
pub fn image::error::DecodingError::from_format_hint(format: image::error::ImageFormatHint) -> Self
pub fn image::error::DecodingError::new(format: image::error::ImageFormatHint, err: impl core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>) -> Self
impl core::error::Error for image::error::DecodingError
pub fn image::error::DecodingError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for image::error::DecodingError
pub fn image::error::DecodingError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for image::error::DecodingError
pub fn image::error::DecodingError::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error>
impl core::marker::Freeze for image::error::DecodingError
impl core::marker::Send for image::error::DecodingError
impl core::marker::Sync for image::error::DecodingError
impl core::marker::Unpin for image::error::DecodingError
impl !core::panic::unwind_safe::RefUnwindSafe for image::error::DecodingError
impl !core::panic::unwind_safe::UnwindSafe for image::error::DecodingError
impl<T, U> core::convert::Into<U> for image::error::DecodingError where U: core::convert::From<T>
pub fn image::error::DecodingError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::DecodingError where U: core::convert::Into<T>
pub type image::error::DecodingError::Error = core::convert::Infallible
pub fn image::error::DecodingError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::DecodingError where U: core::convert::TryFrom<T>
pub type image::error::DecodingError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::DecodingError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for image::error::DecodingError where T: core::fmt::Display + ?core::marker::Sized
pub fn image::error::DecodingError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for image::error::DecodingError where T: 'static + ?core::marker::Sized
pub fn image::error::DecodingError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::DecodingError where T: ?core::marker::Sized
pub fn image::error::DecodingError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::DecodingError where T: ?core::marker::Sized
pub fn image::error::DecodingError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::error::DecodingError
pub fn image::error::DecodingError::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::DecodingError
pub type image::error::DecodingError::Init = T
pub const image::error::DecodingError::ALIGN: usize
pub unsafe fn image::error::DecodingError::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::DecodingError::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::DecodingError::drop(ptr: usize)
pub unsafe fn image::error::DecodingError::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::DecodingError
pub struct image::error::EncodingError
impl image::error::EncodingError
pub fn image::error::EncodingError::format_hint(&self) -> image::error::ImageFormatHint
pub fn image::error::EncodingError::from_format_hint(format: image::error::ImageFormatHint) -> Self
pub fn image::error::EncodingError::new(format: image::error::ImageFormatHint, err: impl core::convert::Into<alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>>) -> Self
impl core::error::Error for image::error::EncodingError
pub fn image::error::EncodingError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for image::error::EncodingError
pub fn image::error::EncodingError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for image::error::EncodingError
pub fn image::error::EncodingError::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error>
impl core::marker::Freeze for image::error::EncodingError
impl core::marker::Send for image::error::EncodingError
impl core::marker::Sync for image::error::EncodingError
impl core::marker::Unpin for image::error::EncodingError
impl !core::panic::unwind_safe::RefUnwindSafe for image::error::EncodingError
impl !core::panic::unwind_safe::UnwindSafe for image::error::EncodingError
impl<T, U> core::convert::Into<U> for image::error::EncodingError where U: core::convert::From<T>
pub fn image::error::EncodingError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::EncodingError where U: core::convert::Into<T>
pub type image::error::EncodingError::Error = core::convert::Infallible
pub fn image::error::EncodingError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::EncodingError where U: core::convert::TryFrom<T>
pub type image::error::EncodingError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::EncodingError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for image::error::EncodingError where T: core::fmt::Display + ?core::marker::Sized
pub fn image::error::EncodingError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for image::error::EncodingError where T: 'static + ?core::marker::Sized
pub fn image::error::EncodingError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::EncodingError where T: ?core::marker::Sized
pub fn image::error::EncodingError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::EncodingError where T: ?core::marker::Sized
pub fn image::error::EncodingError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::error::EncodingError
pub fn image::error::EncodingError::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::EncodingError
pub type image::error::EncodingError::Init = T
pub const image::error::EncodingError::ALIGN: usize
pub unsafe fn image::error::EncodingError::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::EncodingError::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::EncodingError::drop(ptr: usize)
pub unsafe fn image::error::EncodingError::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::EncodingError
pub struct image::error::LimitError
impl image::error::LimitError
pub fn image::error::LimitError::from_kind(kind: image::error::LimitErrorKind) -> Self
pub fn image::error::LimitError::kind(&self) -> image::error::LimitErrorKind
impl core::error::Error for image::error::LimitError
impl core::fmt::Debug for image::error::LimitError
pub fn image::error::LimitError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for image::error::LimitError
pub fn image::error::LimitError::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error>
impl core::marker::Freeze for image::error::LimitError
impl core::marker::Send for image::error::LimitError
impl core::marker::Sync for image::error::LimitError
impl core::marker::Unpin for image::error::LimitError
impl core::panic::unwind_safe::RefUnwindSafe for image::error::LimitError
impl core::panic::unwind_safe::UnwindSafe for image::error::LimitError
impl<T, U> core::convert::Into<U> for image::error::LimitError where U: core::convert::From<T>
pub fn image::error::LimitError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::LimitError where U: core::convert::Into<T>
pub type image::error::LimitError::Error = core::convert::Infallible
pub fn image::error::LimitError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::LimitError where U: core::convert::TryFrom<T>
pub type image::error::LimitError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::LimitError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for image::error::LimitError where T: core::fmt::Display + ?core::marker::Sized
pub fn image::error::LimitError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for image::error::LimitError where T: 'static + ?core::marker::Sized
pub fn image::error::LimitError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::LimitError where T: ?core::marker::Sized
pub fn image::error::LimitError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::LimitError where T: ?core::marker::Sized
pub fn image::error::LimitError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::error::LimitError
pub fn image::error::LimitError::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::LimitError
pub type image::error::LimitError::Init = T
pub const image::error::LimitError::ALIGN: usize
pub unsafe fn image::error::LimitError::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::LimitError::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::LimitError::drop(ptr: usize)
pub unsafe fn image::error::LimitError::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::LimitError
pub struct image::error::ParameterError
impl image::error::ParameterError
pub fn image::error::ParameterError::from_kind(kind: image::error::ParameterErrorKind) -> Self
pub fn image::error::ParameterError::kind(&self) -> image::error::ParameterErrorKind
impl core::error::Error for image::error::ParameterError
pub fn image::error::ParameterError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for image::error::ParameterError
pub fn image::error::ParameterError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for image::error::ParameterError
pub fn image::error::ParameterError::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error>
impl core::marker::Freeze for image::error::ParameterError
impl core::marker::Send for image::error::ParameterError
impl core::marker::Sync for image::error::ParameterError
impl core::marker::Unpin for image::error::ParameterError
impl !core::panic::unwind_safe::RefUnwindSafe for image::error::ParameterError
impl !core::panic::unwind_safe::UnwindSafe for image::error::ParameterError
impl<T, U> core::convert::Into<U> for image::error::ParameterError where U: core::convert::From<T>
pub fn image::error::ParameterError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::ParameterError where U: core::convert::Into<T>
pub type image::error::ParameterError::Error = core::convert::Infallible
pub fn image::error::ParameterError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::ParameterError where U: core::convert::TryFrom<T>
pub type image::error::ParameterError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::ParameterError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for image::error::ParameterError where T: core::fmt::Display + ?core::marker::Sized
pub fn image::error::ParameterError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for image::error::ParameterError where T: 'static + ?core::marker::Sized
pub fn image::error::ParameterError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::ParameterError where T: ?core::marker::Sized
pub fn image::error::ParameterError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::ParameterError where T: ?core::marker::Sized
pub fn image::error::ParameterError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::error::ParameterError
pub fn image::error::ParameterError::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::ParameterError
pub type image::error::ParameterError::Init = T
pub const image::error::ParameterError::ALIGN: usize
pub unsafe fn image::error::ParameterError::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::ParameterError::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::ParameterError::drop(ptr: usize)
pub unsafe fn image::error::ParameterError::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::ParameterError
pub struct image::error::UnsupportedError
impl image::error::UnsupportedError
pub fn image::error::UnsupportedError::format_hint(&self) -> image::error::ImageFormatHint
pub fn image::error::UnsupportedError::from_format_and_kind(format: image::error::ImageFormatHint, kind: image::error::UnsupportedErrorKind) -> Self
pub fn image::error::UnsupportedError::kind(&self) -> image::error::UnsupportedErrorKind
impl core::convert::From<image::error::ImageFormatHint> for image::error::UnsupportedError
pub fn image::error::UnsupportedError::from(hint: image::error::ImageFormatHint) -> Self
impl core::error::Error for image::error::UnsupportedError
impl core::fmt::Debug for image::error::UnsupportedError
pub fn image::error::UnsupportedError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for image::error::UnsupportedError
pub fn image::error::UnsupportedError::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error>
impl core::marker::Freeze for image::error::UnsupportedError
impl core::marker::Send for image::error::UnsupportedError
impl core::marker::Sync for image::error::UnsupportedError
impl core::marker::Unpin for image::error::UnsupportedError
impl core::panic::unwind_safe::RefUnwindSafe for image::error::UnsupportedError
impl core::panic::unwind_safe::UnwindSafe for image::error::UnsupportedError
impl<T, U> core::convert::Into<U> for image::error::UnsupportedError where U: core::convert::From<T>
pub fn image::error::UnsupportedError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::UnsupportedError where U: core::convert::Into<T>
pub type image::error::UnsupportedError::Error = core::convert::Infallible
pub fn image::error::UnsupportedError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::UnsupportedError where U: core::convert::TryFrom<T>
pub type image::error::UnsupportedError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::UnsupportedError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for image::error::UnsupportedError where T: core::fmt::Display + ?core::marker::Sized
pub fn image::error::UnsupportedError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for image::error::UnsupportedError where T: 'static + ?core::marker::Sized
pub fn image::error::UnsupportedError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::UnsupportedError where T: ?core::marker::Sized
pub fn image::error::UnsupportedError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::UnsupportedError where T: ?core::marker::Sized
pub fn image::error::UnsupportedError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::error::UnsupportedError
pub fn image::error::UnsupportedError::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::UnsupportedError
pub type image::error::UnsupportedError::Init = T
pub const image::error::UnsupportedError::ALIGN: usize
pub unsafe fn image::error::UnsupportedError::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::UnsupportedError::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::UnsupportedError::drop(ptr: usize)
pub unsafe fn image::error::UnsupportedError::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::UnsupportedError
pub type image::error::ImageResult<T> = core::result::Result<T, image::error::ImageError>
pub mod image::flat
pub enum image::flat::Error
pub image::flat::Error::ChannelCountMismatch(u8, u8)
pub image::flat::Error::NormalFormRequired(image::flat::NormalForm)
pub image::flat::Error::TooLarge
pub image::flat::Error::WrongColor(image::ColorType)
impl core::clone::Clone for image::flat::Error
pub fn image::flat::Error::clone(&self) -> image::flat::Error
impl core::cmp::Eq for image::flat::Error
impl core::cmp::PartialEq for image::flat::Error
pub fn image::flat::Error::eq(&self, other: &image::flat::Error) -> bool
impl core::convert::From<image::flat::Error> for image::error::ImageError
pub fn image::error::ImageError::from(error: image::flat::Error) -> image::error::ImageError
impl core::error::Error for image::flat::Error
impl core::fmt::Debug for image::flat::Error
pub fn image::flat::Error::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for image::flat::Error
pub fn image::flat::Error::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::flat::Error
pub fn image::flat::Error::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for image::flat::Error
impl core::marker::StructuralPartialEq for image::flat::Error
impl core::marker::Freeze for image::flat::Error
impl core::marker::Send for image::flat::Error
impl core::marker::Sync for image::flat::Error
impl core::marker::Unpin for image::flat::Error
impl core::panic::unwind_safe::RefUnwindSafe for image::flat::Error
impl core::panic::unwind_safe::UnwindSafe for image::flat::Error
impl<T, U> core::convert::Into<U> for image::flat::Error where U: core::convert::From<T>
pub fn image::flat::Error::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::flat::Error where U: core::convert::Into<T>
pub type image::flat::Error::Error = core::convert::Infallible
pub fn image::flat::Error::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::flat::Error where U: core::convert::TryFrom<T>
pub type image::flat::Error::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::flat::Error::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::flat::Error where T: core::clone::Clone
pub type image::flat::Error::Owned = T
pub fn image::flat::Error::clone_into(&self, target: &mut T)
pub fn image::flat::Error::to_owned(&self) -> T
impl<T> alloc::string::ToString for image::flat::Error where T: core::fmt::Display + ?core::marker::Sized
pub fn image::flat::Error::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for image::flat::Error where T: 'static + ?core::marker::Sized
pub fn image::flat::Error::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::flat::Error where T: ?core::marker::Sized
pub fn image::flat::Error::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::flat::Error where T: ?core::marker::Sized
pub fn image::flat::Error::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::flat::Error where T: core::clone::Clone
pub unsafe fn image::flat::Error::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::flat::Error
pub fn image::flat::Error::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::flat::Error
pub type image::flat::Error::Init = T
pub const image::flat::Error::ALIGN: usize
pub unsafe fn image::flat::Error::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::flat::Error::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::flat::Error::drop(ptr: usize)
pub unsafe fn image::flat::Error::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::flat::Error
pub enum image::flat::NormalForm
pub image::flat::NormalForm::ColumnMajorPacked
pub image::flat::NormalForm::ImagePacked
pub image::flat::NormalForm::PixelPacked
pub image::flat::NormalForm::RowMajorPacked
pub image::flat::NormalForm::Unaliased
impl core::clone::Clone for image::flat::NormalForm
pub fn image::flat::NormalForm::clone(&self) -> image::flat::NormalForm
impl core::cmp::Eq for image::flat::NormalForm
impl core::cmp::PartialEq for image::flat::NormalForm
pub fn image::flat::NormalForm::eq(&self, other: &image::flat::NormalForm) -> bool
impl core::cmp::PartialOrd for image::flat::NormalForm
pub fn image::flat::NormalForm::partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering>
impl core::fmt::Debug for image::flat::NormalForm
pub fn image::flat::NormalForm::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::flat::NormalForm
pub fn image::flat::NormalForm::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for image::flat::NormalForm
impl core::marker::StructuralPartialEq for image::flat::NormalForm
impl core::marker::Freeze for image::flat::NormalForm
impl core::marker::Send for image::flat::NormalForm
impl core::marker::Sync for image::flat::NormalForm
impl core::marker::Unpin for image::flat::NormalForm
impl core::panic::unwind_safe::RefUnwindSafe for image::flat::NormalForm
impl core::panic::unwind_safe::UnwindSafe for image::flat::NormalForm
impl<T, U> core::convert::Into<U> for image::flat::NormalForm where U: core::convert::From<T>
pub fn image::flat::NormalForm::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::flat::NormalForm where U: core::convert::Into<T>
pub type image::flat::NormalForm::Error = core::convert::Infallible
pub fn image::flat::NormalForm::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::flat::NormalForm where U: core::convert::TryFrom<T>
pub type image::flat::NormalForm::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::flat::NormalForm::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::flat::NormalForm where T: core::clone::Clone
pub type image::flat::NormalForm::Owned = T
pub fn image::flat::NormalForm::clone_into(&self, target: &mut T)
pub fn image::flat::NormalForm::to_owned(&self) -> T
impl<T> core::any::Any for image::flat::NormalForm where T: 'static + ?core::marker::Sized
pub fn image::flat::NormalForm::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::flat::NormalForm where T: ?core::marker::Sized
pub fn image::flat::NormalForm::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::flat::NormalForm where T: ?core::marker::Sized
pub fn image::flat::NormalForm::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::flat::NormalForm where T: core::clone::Clone
pub unsafe fn image::flat::NormalForm::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::flat::NormalForm
pub fn image::flat::NormalForm::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::flat::NormalForm
pub type image::flat::NormalForm::Init = T
pub const image::flat::NormalForm::ALIGN: usize
pub unsafe fn image::flat::NormalForm::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::flat::NormalForm::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::flat::NormalForm::drop(ptr: usize)
pub unsafe fn image::flat::NormalForm::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::flat::NormalForm
pub struct image::flat::FlatSamples<Buffer>
pub image::flat::FlatSamples::color_hint: core::option::Option<image::ColorType>
pub image::flat::FlatSamples::layout: image::flat::SampleLayout
pub image::flat::FlatSamples::samples: Buffer
impl<'buf, Subpixel> image::flat::FlatSamples<&'buf [Subpixel]>
pub fn image::flat::FlatSamples<&'buf [Subpixel]>::with_monocolor<P>(pixel: &'buf P, width: u32, height: u32) -> Self where P: image::Pixel<Subpixel = Subpixel>, Subpixel: image::Primitive
impl<Buffer> image::flat::FlatSamples<Buffer>
pub fn image::flat::FlatSamples<Buffer>::as_mut<T>(&mut self) -> image::flat::FlatSamples<&mut [T]> where Buffer: core::convert::AsMut<[T]>
pub fn image::flat::FlatSamples<Buffer>::as_mut_slice<T>(&mut self) -> &mut [T] where Buffer: core::convert::AsMut<[T]>
pub fn image::flat::FlatSamples<Buffer>::as_ref<T>(&self) -> image::flat::FlatSamples<&[T]> where Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::as_slice<T>(&self) -> &[T] where Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::as_view<P>(&self) -> core::result::Result<image::flat::View<&[<P as image::Pixel>::Subpixel], P>, image::flat::Error> where P: image::Pixel, Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::FlatSamples<Buffer>::as_view_mut<P>(&mut self) -> core::result::Result<image::flat::ViewMut<&mut [<P as image::Pixel>::Subpixel], P>, image::flat::Error> where P: image::Pixel, Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::FlatSamples<Buffer>::as_view_with_mut_samples<P>(&mut self) -> core::result::Result<image::flat::View<&mut [<P as image::Pixel>::Subpixel], P>, image::flat::Error> where P: image::Pixel, Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::FlatSamples<Buffer>::bounds(&self) -> (u8, u32, u32)
pub fn image::flat::FlatSamples<Buffer>::extents(&self) -> (usize, usize, usize)
pub fn image::flat::FlatSamples<Buffer>::fits(&self, len: usize) -> bool
pub fn image::flat::FlatSamples<Buffer>::get_mut_sample<T>(&mut self, channel: u8, x: u32, y: u32) -> core::option::Option<&mut T> where Buffer: core::convert::AsMut<[T]>
pub fn image::flat::FlatSamples<Buffer>::get_sample<T>(&self, channel: u8, x: u32, y: u32) -> core::option::Option<&T> where Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::has_aliased_samples(&self) -> bool
pub fn image::flat::FlatSamples<Buffer>::image_mut_slice<T>(&mut self) -> core::option::Option<&mut [T]> where Buffer: core::convert::AsMut<[T]>
pub fn image::flat::FlatSamples<Buffer>::image_slice<T>(&self) -> core::option::Option<&[T]> where Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::in_bounds(&self, channel: u8, x: u32, y: u32) -> bool
pub fn image::flat::FlatSamples<Buffer>::in_bounds_index(&self, channel: u8, x: u32, y: u32) -> usize
pub fn image::flat::FlatSamples<Buffer>::index(&self, channel: u8, x: u32, y: u32) -> core::option::Option<usize>
pub fn image::flat::FlatSamples<Buffer>::index_ignoring_bounds(&self, channel: usize, x: usize, y: usize) -> core::option::Option<usize>
pub fn image::flat::FlatSamples<Buffer>::is_normal(&self, form: image::flat::NormalForm) -> bool
pub fn image::flat::FlatSamples<Buffer>::min_length(&self) -> core::option::Option<usize>
pub fn image::flat::FlatSamples<Buffer>::shrink_to(&mut self, channels: u8, width: u32, height: u32)
pub fn image::flat::FlatSamples<Buffer>::strides_cwh(&self) -> (usize, usize, usize)
pub fn image::flat::FlatSamples<Buffer>::to_vec<T>(&self) -> image::flat::FlatSamples<alloc::vec::Vec<T>> where T: core::clone::Clone, Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::try_into_buffer<P>(self) -> core::result::Result<image::ImageBuffer<P, Buffer>, (image::flat::Error, Self)> where P: image::Pixel + 'static, <P as image::Pixel>::Subpixel: 'static, Buffer: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
impl<Buffer: core::clone::Clone> core::clone::Clone for image::flat::FlatSamples<Buffer>
pub fn image::flat::FlatSamples<Buffer>::clone(&self) -> image::flat::FlatSamples<Buffer>
impl<Buffer: core::fmt::Debug> core::fmt::Debug for image::flat::FlatSamples<Buffer>
pub fn image::flat::FlatSamples<Buffer>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<Buffer> core::ops::index::Index<(u8, u32, u32)> for image::flat::FlatSamples<Buffer> where Buffer: core::ops::index::Index<usize>
pub type image::flat::FlatSamples<Buffer>::Output = <Buffer as core::ops::index::Index<usize>>::Output
pub fn image::flat::FlatSamples<Buffer>::index(&self, (c, x, y): (u8, u32, u32)) -> &Self::Output
impl<Buffer> core::ops::index::IndexMut<(u8, u32, u32)> for image::flat::FlatSamples<Buffer> where Buffer: core::ops::index::IndexMut<usize>
pub fn image::flat::FlatSamples<Buffer>::index_mut(&mut self, (c, x, y): (u8, u32, u32)) -> &mut Self::Output
impl<Buffer> core::marker::Freeze for image::flat::FlatSamples<Buffer> where Buffer: core::marker::Freeze
impl<Buffer> core::marker::Send for image::flat::FlatSamples<Buffer> where Buffer: core::marker::Send
impl<Buffer> core::marker::Sync for image::flat::FlatSamples<Buffer> where Buffer: core::marker::Sync
impl<Buffer> core::marker::Unpin for image::flat::FlatSamples<Buffer> where Buffer: core::marker::Unpin
impl<Buffer> core::panic::unwind_safe::RefUnwindSafe for image::flat::FlatSamples<Buffer> where Buffer: core::panic::unwind_safe::RefUnwindSafe
impl<Buffer> core::panic::unwind_safe::UnwindSafe for image::flat::FlatSamples<Buffer> where Buffer: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::flat::FlatSamples<Buffer> where U: core::convert::From<T>
pub fn image::flat::FlatSamples<Buffer>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::flat::FlatSamples<Buffer> where U: core::convert::Into<T>
pub type image::flat::FlatSamples<Buffer>::Error = core::convert::Infallible
pub fn image::flat::FlatSamples<Buffer>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::flat::FlatSamples<Buffer> where U: core::convert::TryFrom<T>
pub type image::flat::FlatSamples<Buffer>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::flat::FlatSamples<Buffer>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::flat::FlatSamples<Buffer> where T: core::clone::Clone
pub type image::flat::FlatSamples<Buffer>::Owned = T
pub fn image::flat::FlatSamples<Buffer>::clone_into(&self, target: &mut T)
pub fn image::flat::FlatSamples<Buffer>::to_owned(&self) -> T
impl<T> core::any::Any for image::flat::FlatSamples<Buffer> where T: 'static + ?core::marker::Sized
pub fn image::flat::FlatSamples<Buffer>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::flat::FlatSamples<Buffer> where T: ?core::marker::Sized
pub fn image::flat::FlatSamples<Buffer>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::flat::FlatSamples<Buffer> where T: ?core::marker::Sized
pub fn image::flat::FlatSamples<Buffer>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::flat::FlatSamples<Buffer> where T: core::clone::Clone
pub unsafe fn image::flat::FlatSamples<Buffer>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::flat::FlatSamples<Buffer>
pub fn image::flat::FlatSamples<Buffer>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::flat::FlatSamples<Buffer>
pub type image::flat::FlatSamples<Buffer>::Init = T
pub const image::flat::FlatSamples<Buffer>::ALIGN: usize
pub unsafe fn image::flat::FlatSamples<Buffer>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::flat::FlatSamples<Buffer>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::flat::FlatSamples<Buffer>::drop(ptr: usize)
pub unsafe fn image::flat::FlatSamples<Buffer>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::flat::FlatSamples<Buffer>
#[repr(C)] pub struct image::flat::SampleLayout
pub image::flat::SampleLayout::channel_stride: usize
pub image::flat::SampleLayout::channels: u8
pub image::flat::SampleLayout::height: u32
pub image::flat::SampleLayout::height_stride: usize
pub image::flat::SampleLayout::width: u32
pub image::flat::SampleLayout::width_stride: usize
impl image::flat::SampleLayout
pub fn image::flat::SampleLayout::bounds(&self) -> (u8, u32, u32)
pub fn image::flat::SampleLayout::column_major_packed(channels: u8, width: u32, height: u32) -> Self
pub fn image::flat::SampleLayout::extents(&self) -> (usize, usize, usize)
pub fn image::flat::SampleLayout::fits(&self, len: usize) -> bool
pub fn image::flat::SampleLayout::has_aliased_samples(&self) -> bool
pub fn image::flat::SampleLayout::in_bounds(&self, channel: u8, x: u32, y: u32) -> bool
pub fn image::flat::SampleLayout::in_bounds_index(&self, c: u8, x: u32, y: u32) -> usize
pub fn image::flat::SampleLayout::index(&self, channel: u8, x: u32, y: u32) -> core::option::Option<usize>
pub fn image::flat::SampleLayout::index_ignoring_bounds(&self, channel: usize, x: usize, y: usize) -> core::option::Option<usize>
pub fn image::flat::SampleLayout::is_normal(&self, form: image::flat::NormalForm) -> bool
pub fn image::flat::SampleLayout::min_length(&self) -> core::option::Option<usize>
pub fn image::flat::SampleLayout::row_major_packed(channels: u8, width: u32, height: u32) -> Self
pub fn image::flat::SampleLayout::shrink_to(&mut self, channels: u8, width: u32, height: u32)
pub fn image::flat::SampleLayout::strides_cwh(&self) -> (usize, usize, usize)
impl core::clone::Clone for image::flat::SampleLayout
pub fn image::flat::SampleLayout::clone(&self) -> image::flat::SampleLayout
impl core::cmp::Eq for image::flat::SampleLayout
impl core::cmp::PartialEq for image::flat::SampleLayout
pub fn image::flat::SampleLayout::eq(&self, other: &image::flat::SampleLayout) -> bool
impl core::fmt::Debug for image::flat::SampleLayout
pub fn image::flat::SampleLayout::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::flat::SampleLayout
pub fn image::flat::SampleLayout::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for image::flat::SampleLayout
impl core::marker::StructuralPartialEq for image::flat::SampleLayout
impl core::marker::Freeze for image::flat::SampleLayout
impl core::marker::Send for image::flat::SampleLayout
impl core::marker::Sync for image::flat::SampleLayout
impl core::marker::Unpin for image::flat::SampleLayout
impl core::panic::unwind_safe::RefUnwindSafe for image::flat::SampleLayout
impl core::panic::unwind_safe::UnwindSafe for image::flat::SampleLayout
impl<T, U> core::convert::Into<U> for image::flat::SampleLayout where U: core::convert::From<T>
pub fn image::flat::SampleLayout::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::flat::SampleLayout where U: core::convert::Into<T>
pub type image::flat::SampleLayout::Error = core::convert::Infallible
pub fn image::flat::SampleLayout::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::flat::SampleLayout where U: core::convert::TryFrom<T>
pub type image::flat::SampleLayout::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::flat::SampleLayout::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::flat::SampleLayout where T: core::clone::Clone
pub type image::flat::SampleLayout::Owned = T
pub fn image::flat::SampleLayout::clone_into(&self, target: &mut T)
pub fn image::flat::SampleLayout::to_owned(&self) -> T
impl<T> core::any::Any for image::flat::SampleLayout where T: 'static + ?core::marker::Sized
pub fn image::flat::SampleLayout::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::flat::SampleLayout where T: ?core::marker::Sized
pub fn image::flat::SampleLayout::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::flat::SampleLayout where T: ?core::marker::Sized
pub fn image::flat::SampleLayout::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::flat::SampleLayout where T: core::clone::Clone
pub unsafe fn image::flat::SampleLayout::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::flat::SampleLayout
pub fn image::flat::SampleLayout::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::flat::SampleLayout
pub type image::flat::SampleLayout::Init = T
pub const image::flat::SampleLayout::ALIGN: usize
pub unsafe fn image::flat::SampleLayout::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::flat::SampleLayout::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::flat::SampleLayout::drop(ptr: usize)
pub unsafe fn image::flat::SampleLayout::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::flat::SampleLayout
pub struct image::flat::View<Buffer, P: image::Pixel> where Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
impl<Buffer, P: image::Pixel> image::flat::View<Buffer, P> where Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::View<Buffer, P>::flat(&self) -> &image::flat::FlatSamples<Buffer>
pub fn image::flat::View<Buffer, P>::get_mut_sample(&mut self, channel: u8, x: u32, y: u32) -> core::option::Option<&mut <P as image::Pixel>::Subpixel> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::View<Buffer, P>::get_sample(&self, channel: u8, x: u32, y: u32) -> core::option::Option<&<P as image::Pixel>::Subpixel>
pub fn image::flat::View<Buffer, P>::image_mut_slice(&mut self) -> &mut [<P as image::Pixel>::Subpixel] where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::View<Buffer, P>::image_slice(&self) -> &[<P as image::Pixel>::Subpixel]
pub fn image::flat::View<Buffer, P>::into_inner(self) -> image::flat::FlatSamples<Buffer>
pub fn image::flat::View<Buffer, P>::min_length(&self) -> usize
pub fn image::flat::View<Buffer, P>::samples(&self) -> &Buffer
pub fn image::flat::View<Buffer, P>::shrink_to(&mut self, width: u32, height: u32)
pub fn image::flat::View<Buffer, P>::try_upgrade(self) -> core::result::Result<image::flat::ViewMut<Buffer, P>, (image::flat::Error, Self)> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
impl<Buffer, P: core::clone::Clone + image::Pixel> core::clone::Clone for image::flat::View<Buffer, P> where Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]> + core::clone::Clone
pub fn image::flat::View<Buffer, P>::clone(&self) -> image::flat::View<Buffer, P>
impl<Buffer, P: core::fmt::Debug + image::Pixel> core::fmt::Debug for image::flat::View<Buffer, P> where Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]> + core::fmt::Debug
pub fn image::flat::View<Buffer, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<Buffer, P: image::Pixel> image::GenericImageView for image::flat::View<Buffer, P> where Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub type image::flat::View<Buffer, P>::Pixel = P
pub fn image::flat::View<Buffer, P>::dimensions(&self) -> (u32, u32)
pub fn image::flat::View<Buffer, P>::get_pixel(&self, x: u32, y: u32) -> Self::Pixel
impl<Buffer, P> core::marker::Freeze for image::flat::View<Buffer, P> where Buffer: core::marker::Freeze
impl<Buffer, P> core::marker::Send for image::flat::View<Buffer, P> where Buffer: core::marker::Send, P: core::marker::Send
impl<Buffer, P> core::marker::Sync for image::flat::View<Buffer, P> where Buffer: core::marker::Sync, P: core::marker::Sync
impl<Buffer, P> core::marker::Unpin for image::flat::View<Buffer, P> where Buffer: core::marker::Unpin, P: core::marker::Unpin
impl<Buffer, P> core::panic::unwind_safe::RefUnwindSafe for image::flat::View<Buffer, P> where Buffer: core::panic::unwind_safe::RefUnwindSafe, P: core::panic::unwind_safe::RefUnwindSafe
impl<Buffer, P> core::panic::unwind_safe::UnwindSafe for image::flat::View<Buffer, P> where Buffer: core::panic::unwind_safe::UnwindSafe, P: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::flat::View<Buffer, P> where U: core::convert::From<T>
pub fn image::flat::View<Buffer, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::flat::View<Buffer, P> where U: core::convert::Into<T>
pub type image::flat::View<Buffer, P>::Error = core::convert::Infallible
pub fn image::flat::View<Buffer, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::flat::View<Buffer, P> where U: core::convert::TryFrom<T>
pub type image::flat::View<Buffer, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::flat::View<Buffer, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::flat::View<Buffer, P> where T: core::clone::Clone
pub type image::flat::View<Buffer, P>::Owned = T
pub fn image::flat::View<Buffer, P>::clone_into(&self, target: &mut T)
pub fn image::flat::View<Buffer, P>::to_owned(&self) -> T
impl<T> core::any::Any for image::flat::View<Buffer, P> where T: 'static + ?core::marker::Sized
pub fn image::flat::View<Buffer, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::flat::View<Buffer, P> where T: ?core::marker::Sized
pub fn image::flat::View<Buffer, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::flat::View<Buffer, P> where T: ?core::marker::Sized
pub fn image::flat::View<Buffer, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::flat::View<Buffer, P> where T: core::clone::Clone
pub unsafe fn image::flat::View<Buffer, P>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::flat::View<Buffer, P>
pub fn image::flat::View<Buffer, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::flat::View<Buffer, P>
pub type image::flat::View<Buffer, P>::Init = T
pub const image::flat::View<Buffer, P>::ALIGN: usize
pub unsafe fn image::flat::View<Buffer, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::flat::View<Buffer, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::flat::View<Buffer, P>::drop(ptr: usize)
pub unsafe fn image::flat::View<Buffer, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::flat::View<Buffer, P>
pub struct image::flat::ViewMut<Buffer, P: image::Pixel> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
impl<Buffer, P: image::Pixel> image::flat::ViewMut<Buffer, P> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::ViewMut<Buffer, P>::flat(&self) -> &image::flat::FlatSamples<Buffer>
pub fn image::flat::ViewMut<Buffer, P>::get_mut_sample(&mut self, channel: u8, x: u32, y: u32) -> core::option::Option<&mut <P as image::Pixel>::Subpixel>
pub fn image::flat::ViewMut<Buffer, P>::get_sample(&self, channel: u8, x: u32, y: u32) -> core::option::Option<&<P as image::Pixel>::Subpixel> where Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::ViewMut<Buffer, P>::image_mut_slice(&mut self) -> &mut [<P as image::Pixel>::Subpixel]
pub fn image::flat::ViewMut<Buffer, P>::image_slice(&self) -> &[<P as image::Pixel>::Subpixel] where Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::ViewMut<Buffer, P>::into_inner(self) -> image::flat::FlatSamples<Buffer>
pub fn image::flat::ViewMut<Buffer, P>::min_length(&self) -> usize
pub fn image::flat::ViewMut<Buffer, P>::samples(&self) -> &Buffer
pub fn image::flat::ViewMut<Buffer, P>::shrink_to(&mut self, width: u32, height: u32)
impl<Buffer, P: core::clone::Clone + image::Pixel> core::clone::Clone for image::flat::ViewMut<Buffer, P> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]> + core::clone::Clone
pub fn image::flat::ViewMut<Buffer, P>::clone(&self) -> image::flat::ViewMut<Buffer, P>
impl<Buffer, P: core::fmt::Debug + image::Pixel> core::fmt::Debug for image::flat::ViewMut<Buffer, P> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]> + core::fmt::Debug
pub fn image::flat::ViewMut<Buffer, P>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<Buffer, P: image::Pixel> image::GenericImage for image::flat::ViewMut<Buffer, P> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]> + core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::ViewMut<Buffer, P>::blend_pixel(&mut self, x: u32, y: u32, pixel: Self::Pixel)
pub fn image::flat::ViewMut<Buffer, P>::get_pixel_mut(&mut self, x: u32, y: u32) -> &mut Self::Pixel
pub fn image::flat::ViewMut<Buffer, P>::put_pixel(&mut self, x: u32, y: u32, pixel: Self::Pixel)
impl<Buffer, P: image::Pixel> image::GenericImageView for image::flat::ViewMut<Buffer, P> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]> + core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub type image::flat::ViewMut<Buffer, P>::Pixel = P
pub fn image::flat::ViewMut<Buffer, P>::dimensions(&self) -> (u32, u32)
pub fn image::flat::ViewMut<Buffer, P>::get_pixel(&self, x: u32, y: u32) -> Self::Pixel
impl<Buffer, P> core::marker::Freeze for image::flat::ViewMut<Buffer, P> where Buffer: core::marker::Freeze
impl<Buffer, P> core::marker::Send for image::flat::ViewMut<Buffer, P> where Buffer: core::marker::Send, P: core::marker::Send
impl<Buffer, P> core::marker::Sync for image::flat::ViewMut<Buffer, P> where Buffer: core::marker::Sync, P: core::marker::Sync
impl<Buffer, P> core::marker::Unpin for image::flat::ViewMut<Buffer, P> where Buffer: core::marker::Unpin, P: core::marker::Unpin
impl<Buffer, P> core::panic::unwind_safe::RefUnwindSafe for image::flat::ViewMut<Buffer, P> where Buffer: core::panic::unwind_safe::RefUnwindSafe, P: core::panic::unwind_safe::RefUnwindSafe
impl<Buffer, P> core::panic::unwind_safe::UnwindSafe for image::flat::ViewMut<Buffer, P> where Buffer: core::panic::unwind_safe::UnwindSafe, P: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::flat::ViewMut<Buffer, P> where U: core::convert::From<T>
pub fn image::flat::ViewMut<Buffer, P>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::flat::ViewMut<Buffer, P> where U: core::convert::Into<T>
pub type image::flat::ViewMut<Buffer, P>::Error = core::convert::Infallible
pub fn image::flat::ViewMut<Buffer, P>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::flat::ViewMut<Buffer, P> where U: core::convert::TryFrom<T>
pub type image::flat::ViewMut<Buffer, P>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::flat::ViewMut<Buffer, P>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::flat::ViewMut<Buffer, P> where T: core::clone::Clone
pub type image::flat::ViewMut<Buffer, P>::Owned = T
pub fn image::flat::ViewMut<Buffer, P>::clone_into(&self, target: &mut T)
pub fn image::flat::ViewMut<Buffer, P>::to_owned(&self) -> T
impl<T> core::any::Any for image::flat::ViewMut<Buffer, P> where T: 'static + ?core::marker::Sized
pub fn image::flat::ViewMut<Buffer, P>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::flat::ViewMut<Buffer, P> where T: ?core::marker::Sized
pub fn image::flat::ViewMut<Buffer, P>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::flat::ViewMut<Buffer, P> where T: ?core::marker::Sized
pub fn image::flat::ViewMut<Buffer, P>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::flat::ViewMut<Buffer, P> where T: core::clone::Clone
pub unsafe fn image::flat::ViewMut<Buffer, P>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::flat::ViewMut<Buffer, P>
pub fn image::flat::ViewMut<Buffer, P>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::flat::ViewMut<Buffer, P>
pub type image::flat::ViewMut<Buffer, P>::Init = T
pub const image::flat::ViewMut<Buffer, P>::ALIGN: usize
pub unsafe fn image::flat::ViewMut<Buffer, P>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::flat::ViewMut<Buffer, P>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::flat::ViewMut<Buffer, P>::drop(ptr: usize)
pub unsafe fn image::flat::ViewMut<Buffer, P>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::flat::ViewMut<Buffer, P>
pub mod image::imageops
pub mod image::imageops::colorops
pub struct image::imageops::colorops::BiLevel
impl core::clone::Clone for image::imageops::colorops::BiLevel
pub fn image::imageops::colorops::BiLevel::clone(&self) -> image::imageops::colorops::BiLevel
impl core::marker::Copy for image::imageops::colorops::BiLevel
impl image::imageops::colorops::ColorMap for image::imageops::colorops::BiLevel
pub type image::imageops::colorops::BiLevel::Color = image::Luma<u8>
pub fn image::imageops::colorops::BiLevel::has_lookup(&self) -> bool
pub fn image::imageops::colorops::BiLevel::index_of(&self, color: &image::Luma<u8>) -> usize
pub fn image::imageops::colorops::BiLevel::lookup(&self, idx: usize) -> core::option::Option<Self::Color>
pub fn image::imageops::colorops::BiLevel::map_color(&self, color: &mut image::Luma<u8>)
impl core::marker::Freeze for image::imageops::colorops::BiLevel
impl core::marker::Send for image::imageops::colorops::BiLevel
impl core::marker::Sync for image::imageops::colorops::BiLevel
impl core::marker::Unpin for image::imageops::colorops::BiLevel
impl core::panic::unwind_safe::RefUnwindSafe for image::imageops::colorops::BiLevel
impl core::panic::unwind_safe::UnwindSafe for image::imageops::colorops::BiLevel
impl<T, U> core::convert::Into<U> for image::imageops::colorops::BiLevel where U: core::convert::From<T>
pub fn image::imageops::colorops::BiLevel::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::imageops::colorops::BiLevel where U: core::convert::Into<T>
pub type image::imageops::colorops::BiLevel::Error = core::convert::Infallible
pub fn image::imageops::colorops::BiLevel::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::imageops::colorops::BiLevel where U: core::convert::TryFrom<T>
pub type image::imageops::colorops::BiLevel::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::imageops::colorops::BiLevel::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::imageops::colorops::BiLevel where T: core::clone::Clone
pub type image::imageops::colorops::BiLevel::Owned = T
pub fn image::imageops::colorops::BiLevel::clone_into(&self, target: &mut T)
pub fn image::imageops::colorops::BiLevel::to_owned(&self) -> T
impl<T> core::any::Any for image::imageops::colorops::BiLevel where T: 'static + ?core::marker::Sized
pub fn image::imageops::colorops::BiLevel::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::imageops::colorops::BiLevel where T: ?core::marker::Sized
pub fn image::imageops::colorops::BiLevel::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::imageops::colorops::BiLevel where T: ?core::marker::Sized
pub fn image::imageops::colorops::BiLevel::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::imageops::colorops::BiLevel where T: core::clone::Clone
pub unsafe fn image::imageops::colorops::BiLevel::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::imageops::colorops::BiLevel
pub fn image::imageops::colorops::BiLevel::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::imageops::colorops::BiLevel
pub type image::imageops::colorops::BiLevel::Init = T
pub const image::imageops::colorops::BiLevel::ALIGN: usize
pub unsafe fn image::imageops::colorops::BiLevel::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::imageops::colorops::BiLevel::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::imageops::colorops::BiLevel::drop(ptr: usize)
pub unsafe fn image::imageops::colorops::BiLevel::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::imageops::colorops::BiLevel
pub trait image::imageops::colorops::ColorMap
pub type image::imageops::colorops::ColorMap::Color
pub fn image::imageops::colorops::ColorMap::has_lookup(&self) -> bool
pub fn image::imageops::colorops::ColorMap::index_of(&self, color: &Self::Color) -> usize
pub fn image::imageops::colorops::ColorMap::lookup(&self, index: usize) -> core::option::Option<Self::Color>
pub fn image::imageops::colorops::ColorMap::map_color(&self, color: &mut Self::Color)
impl image::imageops::colorops::ColorMap for image::imageops::colorops::BiLevel
pub type image::imageops::colorops::BiLevel::Color = image::Luma<u8>
pub fn image::imageops::colorops::BiLevel::has_lookup(&self) -> bool
pub fn image::imageops::colorops::BiLevel::index_of(&self, color: &image::Luma<u8>) -> usize
pub fn image::imageops::colorops::BiLevel::lookup(&self, idx: usize) -> core::option::Option<Self::Color>
pub fn image::imageops::colorops::BiLevel::map_color(&self, color: &mut image::Luma<u8>)
pub fn image::imageops::colorops::brighten<I, P, S>(image: &I, value: i32) -> image::ImageBuffer<P, alloc::vec::Vec<S>> where I: image::GenericImageView<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + 'static
pub fn image::imageops::colorops::brighten_in_place<I>(image: &mut I, value: i32) where I: image::GenericImage
pub fn image::imageops::colorops::contrast<I, P, S>(image: &I, contrast: f32) -> image::ImageBuffer<P, alloc::vec::Vec<S>> where I: image::GenericImageView<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + 'static
pub fn image::imageops::colorops::contrast_in_place<I>(image: &mut I, contrast: f32) where I: image::GenericImage
pub fn image::imageops::colorops::dither<Pix, Map>(image: &mut image::ImageBuffer<Pix, alloc::vec::Vec<u8>>, color_map: &Map) where Map: image::imageops::colorops::ColorMap<Color = Pix> + ?core::marker::Sized, Pix: image::Pixel<Subpixel = u8> + 'static
pub fn image::imageops::colorops::grayscale<I: image::GenericImageView>(image: &I) -> image::ImageBuffer<image::Luma<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>>
pub fn image::imageops::colorops::grayscale_alpha<I: image::GenericImageView>(image: &I) -> image::ImageBuffer<image::LumaA<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>>
pub fn image::imageops::colorops::grayscale_with_type<NewPixel, I: image::GenericImageView>(image: &I) -> image::ImageBuffer<NewPixel, alloc::vec::Vec<<NewPixel as image::Pixel>::Subpixel>> where NewPixel: image::Pixel + image::color::FromColor<image::Luma<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>>
pub fn image::imageops::colorops::grayscale_with_type_alpha<NewPixel, I: image::GenericImageView>(image: &I) -> image::ImageBuffer<NewPixel, alloc::vec::Vec<<NewPixel as image::Pixel>::Subpixel>> where NewPixel: image::Pixel + image::color::FromColor<image::LumaA<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>>
pub fn image::imageops::colorops::huerotate<I, P, S>(image: &I, value: i32) -> image::ImageBuffer<P, alloc::vec::Vec<S>> where I: image::GenericImageView<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + 'static
pub fn image::imageops::colorops::huerotate_in_place<I>(image: &mut I, value: i32) where I: image::GenericImage
pub fn image::imageops::colorops::index_colors<Pix, Map>(image: &image::ImageBuffer<Pix, alloc::vec::Vec<u8>>, color_map: &Map) -> image::ImageBuffer<image::Luma<u8>, alloc::vec::Vec<u8>> where Map: image::imageops::colorops::ColorMap<Color = Pix> + ?core::marker::Sized, Pix: image::Pixel<Subpixel = u8> + 'static
pub fn image::imageops::colorops::invert<I: image::GenericImage>(image: &mut I)
pub enum image::imageops::FilterType
pub image::imageops::FilterType::CatmullRom
pub image::imageops::FilterType::Gaussian
pub image::imageops::FilterType::Lanczos3
pub image::imageops::FilterType::Nearest
pub image::imageops::FilterType::Triangle
impl core::clone::Clone for image::imageops::FilterType
pub fn image::imageops::FilterType::clone(&self) -> image::imageops::FilterType
impl core::cmp::Eq for image::imageops::FilterType
impl core::cmp::PartialEq for image::imageops::FilterType
pub fn image::imageops::FilterType::eq(&self, other: &image::imageops::FilterType) -> bool
impl core::fmt::Debug for image::imageops::FilterType
pub fn image::imageops::FilterType::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::imageops::FilterType
pub fn image::imageops::FilterType::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for image::imageops::FilterType
impl core::marker::StructuralPartialEq for image::imageops::FilterType
impl core::marker::Freeze for image::imageops::FilterType
impl core::marker::Send for image::imageops::FilterType
impl core::marker::Sync for image::imageops::FilterType
impl core::marker::Unpin for image::imageops::FilterType
impl core::panic::unwind_safe::RefUnwindSafe for image::imageops::FilterType
impl core::panic::unwind_safe::UnwindSafe for image::imageops::FilterType
impl<T, U> core::convert::Into<U> for image::imageops::FilterType where U: core::convert::From<T>
pub fn image::imageops::FilterType::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::imageops::FilterType where U: core::convert::Into<T>
pub type image::imageops::FilterType::Error = core::convert::Infallible
pub fn image::imageops::FilterType::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::imageops::FilterType where U: core::convert::TryFrom<T>
pub type image::imageops::FilterType::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::imageops::FilterType::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::imageops::FilterType where T: core::clone::Clone
pub type image::imageops::FilterType::Owned = T
pub fn image::imageops::FilterType::clone_into(&self, target: &mut T)
pub fn image::imageops::FilterType::to_owned(&self) -> T
impl<T> core::any::Any for image::imageops::FilterType where T: 'static + ?core::marker::Sized
pub fn image::imageops::FilterType::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::imageops::FilterType where T: ?core::marker::Sized
pub fn image::imageops::FilterType::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::imageops::FilterType where T: ?core::marker::Sized
pub fn image::imageops::FilterType::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::imageops::FilterType where T: core::clone::Clone
pub unsafe fn image::imageops::FilterType::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::imageops::FilterType
pub fn image::imageops::FilterType::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::imageops::FilterType
pub type image::imageops::FilterType::Init = T
pub const image::imageops::FilterType::ALIGN: usize
pub unsafe fn image::imageops::FilterType::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::imageops::FilterType::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::imageops::FilterType::drop(ptr: usize)
pub unsafe fn image::imageops::FilterType::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::imageops::FilterType
pub struct image::imageops::BiLevel
impl core::clone::Clone for image::imageops::colorops::BiLevel
pub fn image::imageops::colorops::BiLevel::clone(&self) -> image::imageops::colorops::BiLevel
impl core::marker::Copy for image::imageops::colorops::BiLevel
impl image::imageops::colorops::ColorMap for image::imageops::colorops::BiLevel
pub type image::imageops::colorops::BiLevel::Color = image::Luma<u8>
pub fn image::imageops::colorops::BiLevel::has_lookup(&self) -> bool
pub fn image::imageops::colorops::BiLevel::index_of(&self, color: &image::Luma<u8>) -> usize
pub fn image::imageops::colorops::BiLevel::lookup(&self, idx: usize) -> core::option::Option<Self::Color>
pub fn image::imageops::colorops::BiLevel::map_color(&self, color: &mut image::Luma<u8>)
impl core::marker::Freeze for image::imageops::colorops::BiLevel
impl core::marker::Send for image::imageops::colorops::BiLevel
impl core::marker::Sync for image::imageops::colorops::BiLevel
impl core::marker::Unpin for image::imageops::colorops::BiLevel
impl core::panic::unwind_safe::RefUnwindSafe for image::imageops::colorops::BiLevel
impl core::panic::unwind_safe::UnwindSafe for image::imageops::colorops::BiLevel
impl<T, U> core::convert::Into<U> for image::imageops::colorops::BiLevel where U: core::convert::From<T>
pub fn image::imageops::colorops::BiLevel::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::imageops::colorops::BiLevel where U: core::convert::Into<T>
pub type image::imageops::colorops::BiLevel::Error = core::convert::Infallible
pub fn image::imageops::colorops::BiLevel::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::imageops::colorops::BiLevel where U: core::convert::TryFrom<T>
pub type image::imageops::colorops::BiLevel::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::imageops::colorops::BiLevel::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::imageops::colorops::BiLevel where T: core::clone::Clone
pub type image::imageops::colorops::BiLevel::Owned = T
pub fn image::imageops::colorops::BiLevel::clone_into(&self, target: &mut T)
pub fn image::imageops::colorops::BiLevel::to_owned(&self) -> T
impl<T> core::any::Any for image::imageops::colorops::BiLevel where T: 'static + ?core::marker::Sized
pub fn image::imageops::colorops::BiLevel::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::imageops::colorops::BiLevel where T: ?core::marker::Sized
pub fn image::imageops::colorops::BiLevel::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::imageops::colorops::BiLevel where T: ?core::marker::Sized
pub fn image::imageops::colorops::BiLevel::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::imageops::colorops::BiLevel where T: core::clone::Clone
pub unsafe fn image::imageops::colorops::BiLevel::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::imageops::colorops::BiLevel
pub fn image::imageops::colorops::BiLevel::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::imageops::colorops::BiLevel
pub type image::imageops::colorops::BiLevel::Init = T
pub const image::imageops::colorops::BiLevel::ALIGN: usize
pub unsafe fn image::imageops::colorops::BiLevel::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::imageops::colorops::BiLevel::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::imageops::colorops::BiLevel::drop(ptr: usize)
pub unsafe fn image::imageops::colorops::BiLevel::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::imageops::colorops::BiLevel
pub image::imageops::CatmullRom
pub image::imageops::Gaussian
pub image::imageops::Lanczos3
pub image::imageops::Nearest
pub image::imageops::Triangle
pub trait image::imageops::ColorMap
pub type image::imageops::ColorMap::Color
pub fn image::imageops::ColorMap::has_lookup(&self) -> bool
pub fn image::imageops::ColorMap::index_of(&self, color: &Self::Color) -> usize
pub fn image::imageops::ColorMap::lookup(&self, index: usize) -> core::option::Option<Self::Color>
pub fn image::imageops::ColorMap::map_color(&self, color: &mut Self::Color)
impl image::imageops::colorops::ColorMap for image::imageops::colorops::BiLevel
pub type image::imageops::colorops::BiLevel::Color = image::Luma<u8>
pub fn image::imageops::colorops::BiLevel::has_lookup(&self) -> bool
pub fn image::imageops::colorops::BiLevel::index_of(&self, color: &image::Luma<u8>) -> usize
pub fn image::imageops::colorops::BiLevel::lookup(&self, idx: usize) -> core::option::Option<Self::Color>
pub fn image::imageops::colorops::BiLevel::map_color(&self, color: &mut image::Luma<u8>)
pub fn image::imageops::blur<I: image::GenericImageView>(image: &I, sigma: f32) -> image::ImageBuffer<<I as image::GenericImageView>::Pixel, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>> where <I as image::GenericImageView>::Pixel: 'static
pub fn image::imageops::brighten<I, P, S>(image: &I, value: i32) -> image::ImageBuffer<P, alloc::vec::Vec<S>> where I: image::GenericImageView<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + 'static
pub fn image::imageops::contrast<I, P, S>(image: &I, contrast: f32) -> image::ImageBuffer<P, alloc::vec::Vec<S>> where I: image::GenericImageView<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + 'static
pub fn image::imageops::crop<I: image::GenericImageView>(image: &mut I, x: u32, y: u32, width: u32, height: u32) -> image::SubImage<&mut I>
pub fn image::imageops::crop_imm<I: image::GenericImageView>(image: &I, x: u32, y: u32, width: u32, height: u32) -> image::SubImage<&I>
pub fn image::imageops::dither<Pix, Map>(image: &mut image::ImageBuffer<Pix, alloc::vec::Vec<u8>>, color_map: &Map) where Map: image::imageops::colorops::ColorMap<Color = Pix> + ?core::marker::Sized, Pix: image::Pixel<Subpixel = u8> + 'static
pub fn image::imageops::fast_blur<P: image::Pixel>(image_buffer: &image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>, sigma: f32) -> image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>
pub fn image::imageops::filter3x3<I, P, S>(image: &I, kernel: &[f32]) -> image::ImageBuffer<P, alloc::vec::Vec<S>> where I: image::GenericImageView<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + 'static
pub fn image::imageops::flip_horizontal<I: image::GenericImageView>(image: &I) -> image::ImageBuffer<<I as image::GenericImageView>::Pixel, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>> where <I as image::GenericImageView>::Pixel: 'static
pub fn image::imageops::flip_horizontal_in<I, Container>(image: &I, destination: &mut image::ImageBuffer<<I as image::GenericImageView>::Pixel, Container>) -> image::error::ImageResult<()> where I: image::GenericImageView, <I as image::GenericImageView>::Pixel: 'static, Container: core::ops::deref::DerefMut<Target = [<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel]>
pub fn image::imageops::flip_horizontal_in_place<I: image::GenericImage>(image: &mut I)
pub fn image::imageops::flip_vertical<I: image::GenericImageView>(image: &I) -> image::ImageBuffer<<I as image::GenericImageView>::Pixel, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>> where <I as image::GenericImageView>::Pixel: 'static
pub fn image::imageops::flip_vertical_in<I, Container>(image: &I, destination: &mut image::ImageBuffer<<I as image::GenericImageView>::Pixel, Container>) -> image::error::ImageResult<()> where I: image::GenericImageView, <I as image::GenericImageView>::Pixel: 'static, Container: core::ops::deref::DerefMut<Target = [<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel]>
pub fn image::imageops::flip_vertical_in_place<I: image::GenericImage>(image: &mut I)
pub fn image::imageops::grayscale<I: image::GenericImageView>(image: &I) -> image::ImageBuffer<image::Luma<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>>
pub fn image::imageops::grayscale_alpha<I: image::GenericImageView>(image: &I) -> image::ImageBuffer<image::LumaA<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>>
pub fn image::imageops::grayscale_with_type<NewPixel, I: image::GenericImageView>(image: &I) -> image::ImageBuffer<NewPixel, alloc::vec::Vec<<NewPixel as image::Pixel>::Subpixel>> where NewPixel: image::Pixel + image::color::FromColor<image::Luma<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>>
pub fn image::imageops::grayscale_with_type_alpha<NewPixel, I: image::GenericImageView>(image: &I) -> image::ImageBuffer<NewPixel, alloc::vec::Vec<<NewPixel as image::Pixel>::Subpixel>> where NewPixel: image::Pixel + image::color::FromColor<image::LumaA<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>>
pub fn image::imageops::horizontal_gradient<S, P, I>(img: &mut I, start: &P, stop: &P) where I: image::GenericImage<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + image::traits::Lerp + 'static
pub fn image::imageops::huerotate<I, P, S>(image: &I, value: i32) -> image::ImageBuffer<P, alloc::vec::Vec<S>> where I: image::GenericImageView<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + 'static
pub fn image::imageops::index_colors<Pix, Map>(image: &image::ImageBuffer<Pix, alloc::vec::Vec<u8>>, color_map: &Map) -> image::ImageBuffer<image::Luma<u8>, alloc::vec::Vec<u8>> where Map: image::imageops::colorops::ColorMap<Color = Pix> + ?core::marker::Sized, Pix: image::Pixel<Subpixel = u8> + 'static
pub fn image::imageops::interpolate_bilinear<P: image::Pixel>(img: &impl image::GenericImageView<Pixel = P>, x: f32, y: f32) -> core::option::Option<P>
pub fn image::imageops::interpolate_nearest<P: image::Pixel>(img: &impl image::GenericImageView<Pixel = P>, x: f32, y: f32) -> core::option::Option<P>
pub fn image::imageops::invert<I: image::GenericImage>(image: &mut I)
pub fn image::imageops::overlay<I, J>(bottom: &mut I, top: &J, x: i64, y: i64) where I: image::GenericImage, J: image::GenericImageView<Pixel = <I as image::GenericImageView>::Pixel>
pub fn image::imageops::overlay_bounds((bottom_width, bottom_height): (u32, u32), (top_width, top_height): (u32, u32), x: u32, y: u32) -> (u32, u32)
pub fn image::imageops::replace<I, J>(bottom: &mut I, top: &J, x: i64, y: i64) where I: image::GenericImage, J: image::GenericImageView<Pixel = <I as image::GenericImageView>::Pixel>
pub fn image::imageops::resize<I: image::GenericImageView>(image: &I, nwidth: u32, nheight: u32, filter: image::imageops::FilterType) -> image::ImageBuffer<<I as image::GenericImageView>::Pixel, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>> where <I as image::GenericImageView>::Pixel: 'static, <<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel: 'static
pub fn image::imageops::rotate180<I: image::GenericImageView>(image: &I) -> image::ImageBuffer<<I as image::GenericImageView>::Pixel, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>> where <I as image::GenericImageView>::Pixel: 'static
pub fn image::imageops::rotate180_in<I, Container>(image: &I, destination: &mut image::ImageBuffer<<I as image::GenericImageView>::Pixel, Container>) -> image::error::ImageResult<()> where I: image::GenericImageView, <I as image::GenericImageView>::Pixel: 'static, Container: core::ops::deref::DerefMut<Target = [<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel]>
pub fn image::imageops::rotate180_in_place<I: image::GenericImage>(image: &mut I)
pub fn image::imageops::rotate270<I: image::GenericImageView>(image: &I) -> image::ImageBuffer<<I as image::GenericImageView>::Pixel, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>> where <I as image::GenericImageView>::Pixel: 'static
pub fn image::imageops::rotate270_in<I, Container>(image: &I, destination: &mut image::ImageBuffer<<I as image::GenericImageView>::Pixel, Container>) -> image::error::ImageResult<()> where I: image::GenericImageView, <I as image::GenericImageView>::Pixel: 'static, Container: core::ops::deref::DerefMut<Target = [<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel]>
pub fn image::imageops::rotate90<I: image::GenericImageView>(image: &I) -> image::ImageBuffer<<I as image::GenericImageView>::Pixel, alloc::vec::Vec<<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>> where <I as image::GenericImageView>::Pixel: 'static
pub fn image::imageops::rotate90_in<I, Container>(image: &I, destination: &mut image::ImageBuffer<<I as image::GenericImageView>::Pixel, Container>) -> image::error::ImageResult<()> where I: image::GenericImageView, <I as image::GenericImageView>::Pixel: 'static, Container: core::ops::deref::DerefMut<Target = [<<I as image::GenericImageView>::Pixel as image::Pixel>::Subpixel]>
pub fn image::imageops::sample_bilinear<P: image::Pixel>(img: &impl image::GenericImageView<Pixel = P>, u: f32, v: f32) -> core::option::Option<P>
pub fn image::imageops::sample_nearest<P: image::Pixel>(img: &impl image::GenericImageView<Pixel = P>, u: f32, v: f32) -> core::option::Option<P>
pub fn image::imageops::thumbnail<I, P, S>(image: &I, new_width: u32, new_height: u32) -> image::ImageBuffer<P, alloc::vec::Vec<S>> where I: image::GenericImageView<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + image::traits::Enlargeable + 'static
pub fn image::imageops::tile<I, J>(bottom: &mut I, top: &J) where I: image::GenericImage, J: image::GenericImageView<Pixel = <I as image::GenericImageView>::Pixel>
pub fn image::imageops::unsharpen<I, P, S>(image: &I, sigma: f32, threshold: i32) -> image::ImageBuffer<P, alloc::vec::Vec<S>> where I: image::GenericImageView<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + 'static
pub fn image::imageops::vertical_gradient<S, P, I>(img: &mut I, start: &P, stop: &P) where I: image::GenericImage<Pixel = P>, P: image::Pixel<Subpixel = S> + 'static, S: image::Primitive + image::traits::Lerp + 'static
pub mod image::io
pub type image::io::LimitSupport = image::LimitSupport
pub type image::io::Limits = image::Limits
pub type image::io::Reader<R> = image::ImageReader<R>
pub mod image::math
pub struct image::math::Rect
pub image::math::Rect::height: u32
pub image::math::Rect::width: u32
pub image::math::Rect::x: u32
pub image::math::Rect::y: u32
impl core::clone::Clone for image::math::Rect
pub fn image::math::Rect::clone(&self) -> image::math::Rect
impl core::cmp::Eq for image::math::Rect
impl core::cmp::PartialEq for image::math::Rect
pub fn image::math::Rect::eq(&self, other: &image::math::Rect) -> bool
impl core::fmt::Debug for image::math::Rect
pub fn image::math::Rect::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::math::Rect
pub fn image::math::Rect::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for image::math::Rect
impl core::marker::StructuralPartialEq for image::math::Rect
impl core::marker::Freeze for image::math::Rect
impl core::marker::Send for image::math::Rect
impl core::marker::Sync for image::math::Rect
impl core::marker::Unpin for image::math::Rect
impl core::panic::unwind_safe::RefUnwindSafe for image::math::Rect
impl core::panic::unwind_safe::UnwindSafe for image::math::Rect
impl<T, U> core::convert::Into<U> for image::math::Rect where U: core::convert::From<T>
pub fn image::math::Rect::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::math::Rect where U: core::convert::Into<T>
pub type image::math::Rect::Error = core::convert::Infallible
pub fn image::math::Rect::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::math::Rect where U: core::convert::TryFrom<T>
pub type image::math::Rect::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::math::Rect::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::math::Rect where T: core::clone::Clone
pub type image::math::Rect::Owned = T
pub fn image::math::Rect::clone_into(&self, target: &mut T)
pub fn image::math::Rect::to_owned(&self) -> T
impl<T> core::any::Any for image::math::Rect where T: 'static + ?core::marker::Sized
pub fn image::math::Rect::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::math::Rect where T: ?core::marker::Sized
pub fn image::math::Rect::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::math::Rect where T: ?core::marker::Sized
pub fn image::math::Rect::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::math::Rect where T: core::clone::Clone
pub unsafe fn image::math::Rect::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::math::Rect
pub fn image::math::Rect::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::math::Rect
pub type image::math::Rect::Init = T
pub const image::math::Rect::ALIGN: usize
pub unsafe fn image::math::Rect::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::math::Rect::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::math::Rect::drop(ptr: usize)
pub unsafe fn image::math::Rect::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::math::Rect
pub mod image::metadata
pub enum image::metadata::Orientation
pub image::metadata::Orientation::FlipHorizontal
pub image::metadata::Orientation::FlipVertical
pub image::metadata::Orientation::NoTransforms
pub image::metadata::Orientation::Rotate180
pub image::metadata::Orientation::Rotate270
pub image::metadata::Orientation::Rotate270FlipH
pub image::metadata::Orientation::Rotate90
pub image::metadata::Orientation::Rotate90FlipH
impl image::metadata::Orientation
pub fn image::metadata::Orientation::from_exif(exif_orientation: u8) -> core::option::Option<Self>
pub fn image::metadata::Orientation::to_exif(self) -> u8
impl core::clone::Clone for image::metadata::Orientation
pub fn image::metadata::Orientation::clone(&self) -> image::metadata::Orientation
impl core::cmp::Eq for image::metadata::Orientation
impl core::cmp::PartialEq for image::metadata::Orientation
pub fn image::metadata::Orientation::eq(&self, other: &image::metadata::Orientation) -> bool
impl core::fmt::Debug for image::metadata::Orientation
pub fn image::metadata::Orientation::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::metadata::Orientation
pub fn image::metadata::Orientation::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for image::metadata::Orientation
impl core::marker::StructuralPartialEq for image::metadata::Orientation
impl core::marker::Freeze for image::metadata::Orientation
impl core::marker::Send for image::metadata::Orientation
impl core::marker::Sync for image::metadata::Orientation
impl core::marker::Unpin for image::metadata::Orientation
impl core::panic::unwind_safe::RefUnwindSafe for image::metadata::Orientation
impl core::panic::unwind_safe::UnwindSafe for image::metadata::Orientation
impl<T, U> core::convert::Into<U> for image::metadata::Orientation where U: core::convert::From<T>
pub fn image::metadata::Orientation::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::metadata::Orientation where U: core::convert::Into<T>
pub type image::metadata::Orientation::Error = core::convert::Infallible
pub fn image::metadata::Orientation::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::metadata::Orientation where U: core::convert::TryFrom<T>
pub type image::metadata::Orientation::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::metadata::Orientation::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::metadata::Orientation where T: core::clone::Clone
pub type image::metadata::Orientation::Owned = T
pub fn image::metadata::Orientation::clone_into(&self, target: &mut T)
pub fn image::metadata::Orientation::to_owned(&self) -> T
impl<T> core::any::Any for image::metadata::Orientation where T: 'static + ?core::marker::Sized
pub fn image::metadata::Orientation::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::metadata::Orientation where T: ?core::marker::Sized
pub fn image::metadata::Orientation::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::metadata::Orientation where T: ?core::marker::Sized
pub fn image::metadata::Orientation::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::metadata::Orientation where T: core::clone::Clone
pub unsafe fn image::metadata::Orientation::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::metadata::Orientation
pub fn image::metadata::Orientation::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::metadata::Orientation
pub type image::metadata::Orientation::Init = T
pub const image::metadata::Orientation::ALIGN: usize
pub unsafe fn image::metadata::Orientation::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::metadata::Orientation::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::metadata::Orientation::drop(ptr: usize)
pub unsafe fn image::metadata::Orientation::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::metadata::Orientation
#[non_exhaustive] pub enum image::ColorType
pub image::ColorType::L16
pub image::ColorType::L8
pub image::ColorType::La16
pub image::ColorType::La8
pub image::ColorType::Rgb16
pub image::ColorType::Rgb32F
pub image::ColorType::Rgb8
pub image::ColorType::Rgba16
pub image::ColorType::Rgba32F
pub image::ColorType::Rgba8
impl image::ColorType
pub fn image::ColorType::bits_per_pixel(self) -> u16
pub fn image::ColorType::bytes_per_pixel(self) -> u8
pub fn image::ColorType::channel_count(self) -> u8
pub fn image::ColorType::has_alpha(self) -> bool
pub fn image::ColorType::has_color(self) -> bool
impl core::clone::Clone for image::ColorType
pub fn image::ColorType::clone(&self) -> image::ColorType
impl core::cmp::Eq for image::ColorType
impl core::cmp::PartialEq for image::ColorType
pub fn image::ColorType::eq(&self, other: &image::ColorType) -> bool
impl core::convert::From<image::ColorType> for image::ExtendedColorType
pub fn image::ExtendedColorType::from(c: image::ColorType) -> Self
impl core::fmt::Debug for image::ColorType
pub fn image::ColorType::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::ColorType
pub fn image::ColorType::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for image::ColorType
impl core::marker::StructuralPartialEq for image::ColorType
impl core::marker::Freeze for image::ColorType
impl core::marker::Send for image::ColorType
impl core::marker::Sync for image::ColorType
impl core::marker::Unpin for image::ColorType
impl core::panic::unwind_safe::RefUnwindSafe for image::ColorType
impl core::panic::unwind_safe::UnwindSafe for image::ColorType
impl<T, U> core::convert::Into<U> for image::ColorType where U: core::convert::From<T>
pub fn image::ColorType::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::ColorType where U: core::convert::Into<T>
pub type image::ColorType::Error = core::convert::Infallible
pub fn image::ColorType::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::ColorType where U: core::convert::TryFrom<T>
pub type image::ColorType::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::ColorType::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::ColorType where T: core::clone::Clone
pub type image::ColorType::Owned = T
pub fn image::ColorType::clone_into(&self, target: &mut T)
pub fn image::ColorType::to_owned(&self) -> T
impl<T> core::any::Any for image::ColorType where T: 'static + ?core::marker::Sized
pub fn image::ColorType::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::ColorType where T: ?core::marker::Sized
pub fn image::ColorType::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::ColorType where T: ?core::marker::Sized
pub fn image::ColorType::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::ColorType where T: core::clone::Clone
pub unsafe fn image::ColorType::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::ColorType
pub fn image::ColorType::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::ColorType
pub type image::ColorType::Init = T
pub const image::ColorType::ALIGN: usize
pub unsafe fn image::ColorType::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::ColorType::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::ColorType::drop(ptr: usize)
pub unsafe fn image::ColorType::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::ColorType
#[non_exhaustive] pub enum image::DynamicImage
pub image::DynamicImage::ImageLuma16(image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>)
pub image::DynamicImage::ImageLuma8(image::GrayImage)
pub image::DynamicImage::ImageLumaA16(image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>)
pub image::DynamicImage::ImageLumaA8(image::GrayAlphaImage)
pub image::DynamicImage::ImageRgb16(image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>)
pub image::DynamicImage::ImageRgb32F(image::Rgb32FImage)
pub image::DynamicImage::ImageRgb8(image::RgbImage)
pub image::DynamicImage::ImageRgba16(image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>)
pub image::DynamicImage::ImageRgba32F(image::Rgba32FImage)
pub image::DynamicImage::ImageRgba8(image::RgbaImage)
impl image::DynamicImage
pub fn image::DynamicImage::adjust_contrast(&self, c: f32) -> image::DynamicImage
pub fn image::DynamicImage::apply_orientation(&mut self, orientation: image::metadata::Orientation)
pub fn image::DynamicImage::as_bytes(&self) -> &[u8]
pub fn image::DynamicImage::as_flat_samples_f32(&self) -> core::option::Option<image::flat::FlatSamples<&[f32]>>
pub fn image::DynamicImage::as_flat_samples_u16(&self) -> core::option::Option<image::flat::FlatSamples<&[u16]>>
pub fn image::DynamicImage::as_flat_samples_u8(&self) -> core::option::Option<image::flat::FlatSamples<&[u8]>>
pub fn image::DynamicImage::as_luma16(&self) -> core::option::Option<&image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>>
pub fn image::DynamicImage::as_luma8(&self) -> core::option::Option<&image::GrayImage>
pub fn image::DynamicImage::as_luma_alpha16(&self) -> core::option::Option<&image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>>
pub fn image::DynamicImage::as_luma_alpha8(&self) -> core::option::Option<&image::GrayAlphaImage>
pub fn image::DynamicImage::as_mut_luma16(&mut self) -> core::option::Option<&mut image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>>
pub fn image::DynamicImage::as_mut_luma8(&mut self) -> core::option::Option<&mut image::GrayImage>
pub fn image::DynamicImage::as_mut_luma_alpha16(&mut self) -> core::option::Option<&mut image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>>
pub fn image::DynamicImage::as_mut_luma_alpha8(&mut self) -> core::option::Option<&mut image::GrayAlphaImage>
pub fn image::DynamicImage::as_mut_rgb16(&mut self) -> core::option::Option<&mut image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>>
pub fn image::DynamicImage::as_mut_rgb32f(&mut self) -> core::option::Option<&mut image::Rgb32FImage>
pub fn image::DynamicImage::as_mut_rgb8(&mut self) -> core::option::Option<&mut image::RgbImage>
pub fn image::DynamicImage::as_mut_rgba16(&mut self) -> core::option::Option<&mut image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>>
pub fn image::DynamicImage::as_mut_rgba32f(&mut self) -> core::option::Option<&mut image::Rgba32FImage>
pub fn image::DynamicImage::as_mut_rgba8(&mut self) -> core::option::Option<&mut image::RgbaImage>
pub fn image::DynamicImage::as_rgb16(&self) -> core::option::Option<&image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>>
pub fn image::DynamicImage::as_rgb32f(&self) -> core::option::Option<&image::Rgb32FImage>
pub fn image::DynamicImage::as_rgb8(&self) -> core::option::Option<&image::RgbImage>
pub fn image::DynamicImage::as_rgba16(&self) -> core::option::Option<&image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>>
pub fn image::DynamicImage::as_rgba32f(&self) -> core::option::Option<&image::Rgba32FImage>
pub fn image::DynamicImage::as_rgba8(&self) -> core::option::Option<&image::RgbaImage>
pub fn image::DynamicImage::blur(&self, sigma: f32) -> image::DynamicImage
pub fn image::DynamicImage::brighten(&self, value: i32) -> image::DynamicImage
pub fn image::DynamicImage::color(&self) -> image::ColorType
pub fn image::DynamicImage::crop(&mut self, x: u32, y: u32, width: u32, height: u32) -> image::DynamicImage
pub fn image::DynamicImage::crop_imm(&self, x: u32, y: u32, width: u32, height: u32) -> image::DynamicImage
pub fn image::DynamicImage::fast_blur(&self, sigma: f32) -> image::DynamicImage
pub fn image::DynamicImage::filter3x3(&self, kernel: &[f32]) -> image::DynamicImage
pub fn image::DynamicImage::fliph(&self) -> image::DynamicImage
pub fn image::DynamicImage::flipv(&self) -> image::DynamicImage
pub fn image::DynamicImage::from_decoder(decoder: impl image::ImageDecoder) -> image::error::ImageResult<Self>
pub fn image::DynamicImage::grayscale(&self) -> image::DynamicImage
pub fn image::DynamicImage::height(&self) -> u32
pub fn image::DynamicImage::huerotate(&self, value: i32) -> image::DynamicImage
pub fn image::DynamicImage::into_bytes(self) -> alloc::vec::Vec<u8>
pub fn image::DynamicImage::into_luma16(self) -> image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>
pub fn image::DynamicImage::into_luma8(self) -> image::GrayImage
pub fn image::DynamicImage::into_luma_alpha16(self) -> image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>
pub fn image::DynamicImage::into_luma_alpha8(self) -> image::GrayAlphaImage
pub fn image::DynamicImage::into_rgb16(self) -> image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>
pub fn image::DynamicImage::into_rgb32f(self) -> image::Rgb32FImage
pub fn image::DynamicImage::into_rgb8(self) -> image::RgbImage
pub fn image::DynamicImage::into_rgba16(self) -> image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>
pub fn image::DynamicImage::into_rgba32f(self) -> image::Rgba32FImage
pub fn image::DynamicImage::into_rgba8(self) -> image::RgbaImage
pub fn image::DynamicImage::invert(&mut self)
pub fn image::DynamicImage::new(w: u32, h: u32, color: image::ColorType) -> image::DynamicImage
pub fn image::DynamicImage::new_luma16(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::new_luma8(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::new_luma_a16(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::new_luma_a8(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::new_rgb16(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::new_rgb32f(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::new_rgb8(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::new_rgba16(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::new_rgba32f(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::new_rgba8(w: u32, h: u32) -> image::DynamicImage
pub fn image::DynamicImage::resize(&self, nwidth: u32, nheight: u32, filter: image::imageops::FilterType) -> image::DynamicImage
pub fn image::DynamicImage::resize_exact(&self, nwidth: u32, nheight: u32, filter: image::imageops::FilterType) -> image::DynamicImage
pub fn image::DynamicImage::resize_to_fill(&self, nwidth: u32, nheight: u32, filter: image::imageops::FilterType) -> image::DynamicImage
pub fn image::DynamicImage::rotate180(&self) -> image::DynamicImage
pub fn image::DynamicImage::rotate270(&self) -> image::DynamicImage
pub fn image::DynamicImage::rotate90(&self) -> image::DynamicImage
pub fn image::DynamicImage::save<Q>(&self, path: Q) -> image::error::ImageResult<()> where Q: core::convert::AsRef<std::path::Path>
pub fn image::DynamicImage::save_with_format<Q>(&self, path: Q, format: image::ImageFormat) -> image::error::ImageResult<()> where Q: core::convert::AsRef<std::path::Path>
pub fn image::DynamicImage::thumbnail(&self, nwidth: u32, nheight: u32) -> image::DynamicImage
pub fn image::DynamicImage::thumbnail_exact(&self, nwidth: u32, nheight: u32) -> image::DynamicImage
pub fn image::DynamicImage::to<T: image::Pixel + image::color::FromColor<image::Rgb<u8>> + image::color::FromColor<image::Rgb<f32>> + image::color::FromColor<image::Rgba<u8>> + image::color::FromColor<image::Rgba<u16>> + image::color::FromColor<image::Rgba<f32>> + image::color::FromColor<image::Rgb<u16>> + image::color::FromColor<image::Luma<u8>> + image::color::FromColor<image::Luma<u16>> + image::color::FromColor<image::LumaA<u16>> + image::color::FromColor<image::LumaA<u8>>>(&self) -> image::ImageBuffer<T, alloc::vec::Vec<<T as image::Pixel>::Subpixel>>
pub fn image::DynamicImage::to_luma16(&self) -> image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>
pub fn image::DynamicImage::to_luma32f(&self) -> image::ImageBuffer<image::Luma<f32>, alloc::vec::Vec<f32>>
pub fn image::DynamicImage::to_luma8(&self) -> image::GrayImage
pub fn image::DynamicImage::to_luma_alpha16(&self) -> image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>
pub fn image::DynamicImage::to_luma_alpha32f(&self) -> image::ImageBuffer<image::LumaA<f32>, alloc::vec::Vec<f32>>
pub fn image::DynamicImage::to_luma_alpha8(&self) -> image::GrayAlphaImage
pub fn image::DynamicImage::to_rgb16(&self) -> image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>
pub fn image::DynamicImage::to_rgb32f(&self) -> image::Rgb32FImage
pub fn image::DynamicImage::to_rgb8(&self) -> image::RgbImage
pub fn image::DynamicImage::to_rgba16(&self) -> image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>
pub fn image::DynamicImage::to_rgba32f(&self) -> image::Rgba32FImage
pub fn image::DynamicImage::to_rgba8(&self) -> image::RgbaImage
pub fn image::DynamicImage::unsharpen(&self, sigma: f32, threshold: i32) -> image::DynamicImage
pub fn image::DynamicImage::width(&self) -> u32
pub fn image::DynamicImage::write_to<W: std::io::Write + std::io::Seek>(&self, w: &mut W, format: image::ImageFormat) -> image::error::ImageResult<()>
pub fn image::DynamicImage::write_with_encoder(&self, encoder: impl image::ImageEncoder) -> image::error::ImageResult<()>
impl core::clone::Clone for image::DynamicImage
pub fn image::DynamicImage::clone(&self) -> Self
pub fn image::DynamicImage::clone_from(&mut self, source: &Self)
impl core::cmp::PartialEq for image::DynamicImage
pub fn image::DynamicImage::eq(&self, other: &image::DynamicImage) -> bool
impl core::convert::From<image::DynamicImage> for image::GrayAlphaImage
pub fn image::GrayAlphaImage::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::GrayImage
pub fn image::GrayImage::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>
pub fn image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>
pub fn image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>
pub fn image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>
pub fn image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::RgbImage
pub fn image::RgbImage::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::Rgba32FImage
pub fn image::Rgba32FImage::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::RgbaImage
pub fn image::RgbaImage::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Luma<f32>, alloc::vec::Vec<f32>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::Luma<f32>, alloc::vec::Vec<f32>>) -> Self
impl core::convert::From<image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>) -> Self
impl core::convert::From<image::ImageBuffer<image::Luma<u8>, alloc::vec::Vec<u8>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::GrayImage) -> Self
impl core::convert::From<image::ImageBuffer<image::LumaA<f32>, alloc::vec::Vec<f32>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::LumaA<f32>, alloc::vec::Vec<f32>>) -> Self
impl core::convert::From<image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>) -> Self
impl core::convert::From<image::ImageBuffer<image::LumaA<u8>, alloc::vec::Vec<u8>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::GrayAlphaImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgb<f32>, alloc::vec::Vec<f32>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::Rgb32FImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgb<u8>, alloc::vec::Vec<u8>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::RgbImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgba<f32>, alloc::vec::Vec<f32>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::Rgba32FImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgba<u8>, alloc::vec::Vec<u8>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::RgbaImage) -> Self
impl core::default::Default for image::DynamicImage
pub fn image::DynamicImage::default() -> Self
impl core::fmt::Debug for image::DynamicImage
pub fn image::DynamicImage::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::StructuralPartialEq for image::DynamicImage
impl image::GenericImage for image::DynamicImage
pub fn image::DynamicImage::blend_pixel(&mut self, x: u32, y: u32, pixel: image::Rgba<u8>)
pub fn image::DynamicImage::get_pixel_mut(&mut self, _: u32, _: u32) -> &mut image::Rgba<u8>
pub fn image::DynamicImage::put_pixel(&mut self, x: u32, y: u32, pixel: image::Rgba<u8>)
impl image::GenericImageView for image::DynamicImage
pub type image::DynamicImage::Pixel = image::Rgba<u8>
pub fn image::DynamicImage::dimensions(&self) -> (u32, u32)
pub fn image::DynamicImage::get_pixel(&self, x: u32, y: u32) -> image::Rgba<u8>
impl core::marker::Freeze for image::DynamicImage
impl core::marker::Send for image::DynamicImage
impl core::marker::Sync for image::DynamicImage
impl core::marker::Unpin for image::DynamicImage
impl core::panic::unwind_safe::RefUnwindSafe for image::DynamicImage
impl core::panic::unwind_safe::UnwindSafe for image::DynamicImage
impl<R, P> lebe::io::ReadPrimitive<R> for image::DynamicImage where R: std::io::Read + lebe::io::ReadEndian<P>, P: core::default::Default
impl<T, U> core::convert::Into<U> for image::DynamicImage where U: core::convert::From<T>
pub fn image::DynamicImage::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::DynamicImage where U: core::convert::Into<T>
pub type image::DynamicImage::Error = core::convert::Infallible
pub fn image::DynamicImage::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::DynamicImage where U: core::convert::TryFrom<T>
pub type image::DynamicImage::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::DynamicImage::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::DynamicImage where T: core::clone::Clone
pub type image::DynamicImage::Owned = T
pub fn image::DynamicImage::clone_into(&self, target: &mut T)
pub fn image::DynamicImage::to_owned(&self) -> T
impl<T> core::any::Any for image::DynamicImage where T: 'static + ?core::marker::Sized
pub fn image::DynamicImage::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::DynamicImage where T: ?core::marker::Sized
pub fn image::DynamicImage::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::DynamicImage where T: ?core::marker::Sized
pub fn image::DynamicImage::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::DynamicImage where T: core::clone::Clone
pub unsafe fn image::DynamicImage::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::DynamicImage
pub fn image::DynamicImage::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::DynamicImage
pub type image::DynamicImage::Init = T
pub const image::DynamicImage::ALIGN: usize
pub unsafe fn image::DynamicImage::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::DynamicImage::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::DynamicImage::drop(ptr: usize)
pub unsafe fn image::DynamicImage::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::DynamicImage
#[non_exhaustive] pub enum image::ExtendedColorType
pub image::ExtendedColorType::A8
pub image::ExtendedColorType::Bgr8
pub image::ExtendedColorType::Bgra8
pub image::ExtendedColorType::Cmyk8
pub image::ExtendedColorType::L1
pub image::ExtendedColorType::L16
pub image::ExtendedColorType::L2
pub image::ExtendedColorType::L4
pub image::ExtendedColorType::L8
pub image::ExtendedColorType::La1
pub image::ExtendedColorType::La16
pub image::ExtendedColorType::La2
pub image::ExtendedColorType::La4
pub image::ExtendedColorType::La8
pub image::ExtendedColorType::Rgb1
pub image::ExtendedColorType::Rgb16
pub image::ExtendedColorType::Rgb2
pub image::ExtendedColorType::Rgb32F
pub image::ExtendedColorType::Rgb4
pub image::ExtendedColorType::Rgb8
pub image::ExtendedColorType::Rgba1
pub image::ExtendedColorType::Rgba16
pub image::ExtendedColorType::Rgba2
pub image::ExtendedColorType::Rgba32F
pub image::ExtendedColorType::Rgba4
pub image::ExtendedColorType::Rgba8
pub image::ExtendedColorType::Unknown(u8)
impl image::ExtendedColorType
pub fn image::ExtendedColorType::bits_per_pixel(&self) -> u16
pub fn image::ExtendedColorType::channel_count(self) -> u8
impl core::clone::Clone for image::ExtendedColorType
pub fn image::ExtendedColorType::clone(&self) -> image::ExtendedColorType
impl core::cmp::Eq for image::ExtendedColorType
impl core::cmp::PartialEq for image::ExtendedColorType
pub fn image::ExtendedColorType::eq(&self, other: &image::ExtendedColorType) -> bool
impl core::convert::From<image::ColorType> for image::ExtendedColorType
pub fn image::ExtendedColorType::from(c: image::ColorType) -> Self
impl core::fmt::Debug for image::ExtendedColorType
pub fn image::ExtendedColorType::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::ExtendedColorType
pub fn image::ExtendedColorType::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for image::ExtendedColorType
impl core::marker::StructuralPartialEq for image::ExtendedColorType
impl core::marker::Freeze for image::ExtendedColorType
impl core::marker::Send for image::ExtendedColorType
impl core::marker::Sync for image::ExtendedColorType
impl core::marker::Unpin for image::ExtendedColorType
impl core::panic::unwind_safe::RefUnwindSafe for image::ExtendedColorType
impl core::panic::unwind_safe::UnwindSafe for image::ExtendedColorType
impl<T, U> core::convert::Into<U> for image::ExtendedColorType where U: core::convert::From<T>
pub fn image::ExtendedColorType::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::ExtendedColorType where U: core::convert::Into<T>
pub type image::ExtendedColorType::Error = core::convert::Infallible
pub fn image::ExtendedColorType::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::ExtendedColorType where U: core::convert::TryFrom<T>
pub type image::ExtendedColorType::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::ExtendedColorType::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::ExtendedColorType where T: core::clone::Clone
pub type image::ExtendedColorType::Owned = T
pub fn image::ExtendedColorType::clone_into(&self, target: &mut T)
pub fn image::ExtendedColorType::to_owned(&self) -> T
impl<T> core::any::Any for image::ExtendedColorType where T: 'static + ?core::marker::Sized
pub fn image::ExtendedColorType::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::ExtendedColorType where T: ?core::marker::Sized
pub fn image::ExtendedColorType::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::ExtendedColorType where T: ?core::marker::Sized
pub fn image::ExtendedColorType::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::ExtendedColorType where T: core::clone::Clone
pub unsafe fn image::ExtendedColorType::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::ExtendedColorType
pub fn image::ExtendedColorType::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::ExtendedColorType
pub type image::ExtendedColorType::Init = T
pub const image::ExtendedColorType::ALIGN: usize
pub unsafe fn image::ExtendedColorType::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::ExtendedColorType::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::ExtendedColorType::drop(ptr: usize)
pub unsafe fn image::ExtendedColorType::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::ExtendedColorType
pub enum image::ImageError
pub image::ImageError::Decoding(image::error::DecodingError)
pub image::ImageError::Encoding(image::error::EncodingError)
pub image::ImageError::IoError(std::io::error::Error)
pub image::ImageError::Limits(image::error::LimitError)
pub image::ImageError::Parameter(image::error::ParameterError)
pub image::ImageError::Unsupported(image::error::UnsupportedError)
impl core::convert::From<image::flat::Error> for image::error::ImageError
pub fn image::error::ImageError::from(error: image::flat::Error) -> image::error::ImageError
impl core::convert::From<std::io::error::Error> for image::error::ImageError
pub fn image::error::ImageError::from(err: std::io::error::Error) -> image::error::ImageError
impl core::error::Error for image::error::ImageError
pub fn image::error::ImageError::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl core::fmt::Debug for image::error::ImageError
pub fn image::error::ImageError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::fmt::Display for image::error::ImageError
pub fn image::error::ImageError::fmt(&self, fmt: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error>
impl core::marker::Freeze for image::error::ImageError
impl core::marker::Send for image::error::ImageError
impl core::marker::Sync for image::error::ImageError
impl core::marker::Unpin for image::error::ImageError
impl !core::panic::unwind_safe::RefUnwindSafe for image::error::ImageError
impl !core::panic::unwind_safe::UnwindSafe for image::error::ImageError
impl<T, U> core::convert::Into<U> for image::error::ImageError where U: core::convert::From<T>
pub fn image::error::ImageError::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::error::ImageError where U: core::convert::Into<T>
pub type image::error::ImageError::Error = core::convert::Infallible
pub fn image::error::ImageError::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::error::ImageError where U: core::convert::TryFrom<T>
pub type image::error::ImageError::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::error::ImageError::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::string::ToString for image::error::ImageError where T: core::fmt::Display + ?core::marker::Sized
pub fn image::error::ImageError::to_string(&self) -> alloc::string::String
impl<T> core::any::Any for image::error::ImageError where T: 'static + ?core::marker::Sized
pub fn image::error::ImageError::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::error::ImageError where T: ?core::marker::Sized
pub fn image::error::ImageError::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::error::ImageError where T: ?core::marker::Sized
pub fn image::error::ImageError::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::error::ImageError
pub fn image::error::ImageError::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::error::ImageError
pub type image::error::ImageError::Init = T
pub const image::error::ImageError::ALIGN: usize
pub unsafe fn image::error::ImageError::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::error::ImageError::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::error::ImageError::drop(ptr: usize)
pub unsafe fn image::error::ImageError::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::error::ImageError
#[non_exhaustive] pub enum image::ImageFormat
pub image::ImageFormat::Avif
pub image::ImageFormat::Bmp
pub image::ImageFormat::Dds
pub image::ImageFormat::Farbfeld
pub image::ImageFormat::Gif
pub image::ImageFormat::Hdr
pub image::ImageFormat::Ico
pub image::ImageFormat::Jpeg
pub image::ImageFormat::OpenExr
pub image::ImageFormat::Pcx
pub image::ImageFormat::Png
pub image::ImageFormat::Pnm
pub image::ImageFormat::Qoi
pub image::ImageFormat::Tga
pub image::ImageFormat::Tiff
pub image::ImageFormat::WebP
impl image::ImageFormat
pub fn image::ImageFormat::all() -> impl core::iter::traits::iterator::Iterator<Item = image::ImageFormat>
pub fn image::ImageFormat::can_read(&self) -> bool
pub fn image::ImageFormat::can_write(&self) -> bool
pub fn image::ImageFormat::extensions_str(self) -> &'static [&'static str]
pub fn image::ImageFormat::from_extension<S>(ext: S) -> core::option::Option<Self> where S: core::convert::AsRef<std::ffi::os_str::OsStr>
pub fn image::ImageFormat::from_mime_type<M>(mime_type: M) -> core::option::Option<Self> where M: core::convert::AsRef<str>
pub fn image::ImageFormat::from_path<P>(path: P) -> image::error::ImageResult<Self> where P: core::convert::AsRef<std::path::Path>
pub fn image::ImageFormat::reading_enabled(&self) -> bool
pub fn image::ImageFormat::to_mime_type(&self) -> &'static str
pub fn image::ImageFormat::writing_enabled(&self) -> bool
impl core::clone::Clone for image::ImageFormat
pub fn image::ImageFormat::clone(&self) -> image::ImageFormat
impl core::cmp::Eq for image::ImageFormat
impl core::cmp::PartialEq for image::ImageFormat
pub fn image::ImageFormat::eq(&self, other: &image::ImageFormat) -> bool
impl core::convert::From<image::ImageFormat> for image::error::ImageFormatHint
pub fn image::error::ImageFormatHint::from(format: image::ImageFormat) -> Self
impl core::fmt::Debug for image::ImageFormat
pub fn image::ImageFormat::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::ImageFormat
pub fn image::ImageFormat::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::Copy for image::ImageFormat
impl core::marker::StructuralPartialEq for image::ImageFormat
impl core::marker::Freeze for image::ImageFormat
impl core::marker::Send for image::ImageFormat
impl core::marker::Sync for image::ImageFormat
impl core::marker::Unpin for image::ImageFormat
impl core::panic::unwind_safe::RefUnwindSafe for image::ImageFormat
impl core::panic::unwind_safe::UnwindSafe for image::ImageFormat
impl<T, U> core::convert::Into<U> for image::ImageFormat where U: core::convert::From<T>
pub fn image::ImageFormat::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::ImageFormat where U: core::convert::Into<T>
pub type image::ImageFormat::Error = core::convert::Infallible
pub fn image::ImageFormat::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::ImageFormat where U: core::convert::TryFrom<T>
pub type image::ImageFormat::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::ImageFormat::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::ImageFormat where T: core::clone::Clone
pub type image::ImageFormat::Owned = T
pub fn image::ImageFormat::clone_into(&self, target: &mut T)
pub fn image::ImageFormat::to_owned(&self) -> T
impl<T> core::any::Any for image::ImageFormat where T: 'static + ?core::marker::Sized
pub fn image::ImageFormat::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::ImageFormat where T: ?core::marker::Sized
pub fn image::ImageFormat::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::ImageFormat where T: ?core::marker::Sized
pub fn image::ImageFormat::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::ImageFormat where T: core::clone::Clone
pub unsafe fn image::ImageFormat::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::ImageFormat
pub fn image::ImageFormat::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::ImageFormat
pub type image::ImageFormat::Init = T
pub const image::ImageFormat::ALIGN: usize
pub unsafe fn image::ImageFormat::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::ImageFormat::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::ImageFormat::drop(ptr: usize)
pub unsafe fn image::ImageFormat::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::ImageFormat
pub struct image::Delay
impl image::Delay
pub fn image::Delay::from_numer_denom_ms(numerator: u32, denominator: u32) -> Self
pub fn image::Delay::from_saturating_duration(duration: core::time::Duration) -> Self
pub fn image::Delay::numer_denom_ms(self) -> (u32, u32)
impl core::clone::Clone for image::Delay
pub fn image::Delay::clone(&self) -> image::Delay
impl core::cmp::Eq for image::Delay
impl core::cmp::PartialEq for image::Delay
pub fn image::Delay::eq(&self, other: &image::Delay) -> bool
impl core::cmp::PartialOrd for image::Delay
pub fn image::Delay::partial_cmp(&self, other: &image::Delay) -> core::option::Option<core::cmp::Ordering>
impl core::convert::From<image::Delay> for core::time::Duration
pub fn core::time::Duration::from(delay: image::Delay) -> Self
impl core::fmt::Debug for image::Delay
pub fn image::Delay::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for image::Delay
impl core::marker::StructuralPartialEq for image::Delay
impl core::marker::Freeze for image::Delay
impl core::marker::Send for image::Delay
impl core::marker::Sync for image::Delay
impl core::marker::Unpin for image::Delay
impl core::panic::unwind_safe::RefUnwindSafe for image::Delay
impl core::panic::unwind_safe::UnwindSafe for image::Delay
impl<T, U> core::convert::Into<U> for image::Delay where U: core::convert::From<T>
pub fn image::Delay::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::Delay where U: core::convert::Into<T>
pub type image::Delay::Error = core::convert::Infallible
pub fn image::Delay::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::Delay where U: core::convert::TryFrom<T>
pub type image::Delay::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::Delay::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::Delay where T: core::clone::Clone
pub type image::Delay::Owned = T
pub fn image::Delay::clone_into(&self, target: &mut T)
pub fn image::Delay::to_owned(&self) -> T
impl<T> core::any::Any for image::Delay where T: 'static + ?core::marker::Sized
pub fn image::Delay::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::Delay where T: ?core::marker::Sized
pub fn image::Delay::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::Delay where T: ?core::marker::Sized
pub fn image::Delay::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::Delay where T: core::clone::Clone
pub unsafe fn image::Delay::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::Delay
pub fn image::Delay::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::Delay
pub type image::Delay::Init = T
pub const image::Delay::ALIGN: usize
pub unsafe fn image::Delay::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::Delay::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::Delay::drop(ptr: usize)
pub unsafe fn image::Delay::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::Delay
pub struct image::FlatSamples<Buffer>
pub image::FlatSamples::color_hint: core::option::Option<image::ColorType>
pub image::FlatSamples::layout: image::flat::SampleLayout
pub image::FlatSamples::samples: Buffer
impl<'buf, Subpixel> image::flat::FlatSamples<&'buf [Subpixel]>
pub fn image::flat::FlatSamples<&'buf [Subpixel]>::with_monocolor<P>(pixel: &'buf P, width: u32, height: u32) -> Self where P: image::Pixel<Subpixel = Subpixel>, Subpixel: image::Primitive
impl<Buffer> image::flat::FlatSamples<Buffer>
pub fn image::flat::FlatSamples<Buffer>::as_mut<T>(&mut self) -> image::flat::FlatSamples<&mut [T]> where Buffer: core::convert::AsMut<[T]>
pub fn image::flat::FlatSamples<Buffer>::as_mut_slice<T>(&mut self) -> &mut [T] where Buffer: core::convert::AsMut<[T]>
pub fn image::flat::FlatSamples<Buffer>::as_ref<T>(&self) -> image::flat::FlatSamples<&[T]> where Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::as_slice<T>(&self) -> &[T] where Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::as_view<P>(&self) -> core::result::Result<image::flat::View<&[<P as image::Pixel>::Subpixel], P>, image::flat::Error> where P: image::Pixel, Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::FlatSamples<Buffer>::as_view_mut<P>(&mut self) -> core::result::Result<image::flat::ViewMut<&mut [<P as image::Pixel>::Subpixel], P>, image::flat::Error> where P: image::Pixel, Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::FlatSamples<Buffer>::as_view_with_mut_samples<P>(&mut self) -> core::result::Result<image::flat::View<&mut [<P as image::Pixel>::Subpixel], P>, image::flat::Error> where P: image::Pixel, Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::FlatSamples<Buffer>::bounds(&self) -> (u8, u32, u32)
pub fn image::flat::FlatSamples<Buffer>::extents(&self) -> (usize, usize, usize)
pub fn image::flat::FlatSamples<Buffer>::fits(&self, len: usize) -> bool
pub fn image::flat::FlatSamples<Buffer>::get_mut_sample<T>(&mut self, channel: u8, x: u32, y: u32) -> core::option::Option<&mut T> where Buffer: core::convert::AsMut<[T]>
pub fn image::flat::FlatSamples<Buffer>::get_sample<T>(&self, channel: u8, x: u32, y: u32) -> core::option::Option<&T> where Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::has_aliased_samples(&self) -> bool
pub fn image::flat::FlatSamples<Buffer>::image_mut_slice<T>(&mut self) -> core::option::Option<&mut [T]> where Buffer: core::convert::AsMut<[T]>
pub fn image::flat::FlatSamples<Buffer>::image_slice<T>(&self) -> core::option::Option<&[T]> where Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::in_bounds(&self, channel: u8, x: u32, y: u32) -> bool
pub fn image::flat::FlatSamples<Buffer>::in_bounds_index(&self, channel: u8, x: u32, y: u32) -> usize
pub fn image::flat::FlatSamples<Buffer>::index(&self, channel: u8, x: u32, y: u32) -> core::option::Option<usize>
pub fn image::flat::FlatSamples<Buffer>::index_ignoring_bounds(&self, channel: usize, x: usize, y: usize) -> core::option::Option<usize>
pub fn image::flat::FlatSamples<Buffer>::is_normal(&self, form: image::flat::NormalForm) -> bool
pub fn image::flat::FlatSamples<Buffer>::min_length(&self) -> core::option::Option<usize>
pub fn image::flat::FlatSamples<Buffer>::shrink_to(&mut self, channels: u8, width: u32, height: u32)
pub fn image::flat::FlatSamples<Buffer>::strides_cwh(&self) -> (usize, usize, usize)
pub fn image::flat::FlatSamples<Buffer>::to_vec<T>(&self) -> image::flat::FlatSamples<alloc::vec::Vec<T>> where T: core::clone::Clone, Buffer: core::convert::AsRef<[T]>
pub fn image::flat::FlatSamples<Buffer>::try_into_buffer<P>(self) -> core::result::Result<image::ImageBuffer<P, Buffer>, (image::flat::Error, Self)> where P: image::Pixel + 'static, <P as image::Pixel>::Subpixel: 'static, Buffer: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
impl<Buffer: core::clone::Clone> core::clone::Clone for image::flat::FlatSamples<Buffer>
pub fn image::flat::FlatSamples<Buffer>::clone(&self) -> image::flat::FlatSamples<Buffer>
impl<Buffer: core::fmt::Debug> core::fmt::Debug for image::flat::FlatSamples<Buffer>
pub fn image::flat::FlatSamples<Buffer>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<Buffer> core::ops::index::Index<(u8, u32, u32)> for image::flat::FlatSamples<Buffer> where Buffer: core::ops::index::Index<usize>
pub type image::flat::FlatSamples<Buffer>::Output = <Buffer as core::ops::index::Index<usize>>::Output
pub fn image::flat::FlatSamples<Buffer>::index(&self, (c, x, y): (u8, u32, u32)) -> &Self::Output
impl<Buffer> core::ops::index::IndexMut<(u8, u32, u32)> for image::flat::FlatSamples<Buffer> where Buffer: core::ops::index::IndexMut<usize>
pub fn image::flat::FlatSamples<Buffer>::index_mut(&mut self, (c, x, y): (u8, u32, u32)) -> &mut Self::Output
impl<Buffer> core::marker::Freeze for image::flat::FlatSamples<Buffer> where Buffer: core::marker::Freeze
impl<Buffer> core::marker::Send for image::flat::FlatSamples<Buffer> where Buffer: core::marker::Send
impl<Buffer> core::marker::Sync for image::flat::FlatSamples<Buffer> where Buffer: core::marker::Sync
impl<Buffer> core::marker::Unpin for image::flat::FlatSamples<Buffer> where Buffer: core::marker::Unpin
impl<Buffer> core::panic::unwind_safe::RefUnwindSafe for image::flat::FlatSamples<Buffer> where Buffer: core::panic::unwind_safe::RefUnwindSafe
impl<Buffer> core::panic::unwind_safe::UnwindSafe for image::flat::FlatSamples<Buffer> where Buffer: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::flat::FlatSamples<Buffer> where U: core::convert::From<T>
pub fn image::flat::FlatSamples<Buffer>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::flat::FlatSamples<Buffer> where U: core::convert::Into<T>
pub type image::flat::FlatSamples<Buffer>::Error = core::convert::Infallible
pub fn image::flat::FlatSamples<Buffer>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::flat::FlatSamples<Buffer> where U: core::convert::TryFrom<T>
pub type image::flat::FlatSamples<Buffer>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::flat::FlatSamples<Buffer>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::flat::FlatSamples<Buffer> where T: core::clone::Clone
pub type image::flat::FlatSamples<Buffer>::Owned = T
pub fn image::flat::FlatSamples<Buffer>::clone_into(&self, target: &mut T)
pub fn image::flat::FlatSamples<Buffer>::to_owned(&self) -> T
impl<T> core::any::Any for image::flat::FlatSamples<Buffer> where T: 'static + ?core::marker::Sized
pub fn image::flat::FlatSamples<Buffer>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::flat::FlatSamples<Buffer> where T: ?core::marker::Sized
pub fn image::flat::FlatSamples<Buffer>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::flat::FlatSamples<Buffer> where T: ?core::marker::Sized
pub fn image::flat::FlatSamples<Buffer>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::flat::FlatSamples<Buffer> where T: core::clone::Clone
pub unsafe fn image::flat::FlatSamples<Buffer>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::flat::FlatSamples<Buffer>
pub fn image::flat::FlatSamples<Buffer>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::flat::FlatSamples<Buffer>
pub type image::flat::FlatSamples<Buffer>::Init = T
pub const image::flat::FlatSamples<Buffer>::ALIGN: usize
pub unsafe fn image::flat::FlatSamples<Buffer>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::flat::FlatSamples<Buffer>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::flat::FlatSamples<Buffer>::drop(ptr: usize)
pub unsafe fn image::flat::FlatSamples<Buffer>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::flat::FlatSamples<Buffer>
pub struct image::Frame
impl image::Frame
pub fn image::Frame::buffer(&self) -> &image::RgbaImage
pub fn image::Frame::buffer_mut(&mut self) -> &mut image::RgbaImage
pub fn image::Frame::delay(&self) -> image::Delay
pub fn image::Frame::from_parts(buffer: image::RgbaImage, left: u32, top: u32, delay: image::Delay) -> image::Frame
pub fn image::Frame::into_buffer(self) -> image::RgbaImage
pub fn image::Frame::left(&self) -> u32
pub fn image::Frame::new(buffer: image::RgbaImage) -> image::Frame
pub fn image::Frame::top(&self) -> u32
impl core::clone::Clone for image::Frame
pub fn image::Frame::clone(&self) -> Self
pub fn image::Frame::clone_from(&mut self, source: &Self)
impl core::marker::Freeze for image::Frame
impl core::marker::Send for image::Frame
impl core::marker::Sync for image::Frame
impl core::marker::Unpin for image::Frame
impl core::panic::unwind_safe::RefUnwindSafe for image::Frame
impl core::panic::unwind_safe::UnwindSafe for image::Frame
impl<T, U> core::convert::Into<U> for image::Frame where U: core::convert::From<T>
pub fn image::Frame::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::Frame where U: core::convert::Into<T>
pub type image::Frame::Error = core::convert::Infallible
pub fn image::Frame::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::Frame where U: core::convert::TryFrom<T>
pub type image::Frame::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::Frame::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::Frame where T: core::clone::Clone
pub type image::Frame::Owned = T
pub fn image::Frame::clone_into(&self, target: &mut T)
pub fn image::Frame::to_owned(&self) -> T
impl<T> core::any::Any for image::Frame where T: 'static + ?core::marker::Sized
pub fn image::Frame::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::Frame where T: ?core::marker::Sized
pub fn image::Frame::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::Frame where T: ?core::marker::Sized
pub fn image::Frame::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::Frame where T: core::clone::Clone
pub unsafe fn image::Frame::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::Frame
pub fn image::Frame::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::Frame
pub type image::Frame::Init = T
pub const image::Frame::ALIGN: usize
pub unsafe fn image::Frame::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::Frame::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::Frame::drop(ptr: usize)
pub unsafe fn image::Frame::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::Frame
pub struct image::Frames<'a>
impl<'a> image::Frames<'a>
pub fn image::Frames<'a>::collect_frames(self) -> image::error::ImageResult<alloc::vec::Vec<image::Frame>>
pub fn image::Frames<'a>::new(iterator: alloc::boxed::Box<(dyn core::iter::traits::iterator::Iterator<Item = image::error::ImageResult<image::Frame>> + 'a)>) -> Self
impl core::iter::traits::iterator::Iterator for image::Frames<'_>
pub type image::Frames<'_>::Item = core::result::Result<image::Frame, image::error::ImageError>
pub fn image::Frames<'_>::next(&mut self) -> core::option::Option<image::error::ImageResult<image::Frame>>
impl<'a> core::marker::Freeze for image::Frames<'a>
impl<'a> !core::marker::Send for image::Frames<'a>
impl<'a> !core::marker::Sync for image::Frames<'a>
impl<'a> core::marker::Unpin for image::Frames<'a>
impl<'a> !core::panic::unwind_safe::RefUnwindSafe for image::Frames<'a>
impl<'a> !core::panic::unwind_safe::UnwindSafe for image::Frames<'a>
impl<I> core::iter::traits::collect::IntoIterator for image::Frames<'a> where I: core::iter::traits::iterator::Iterator
pub type image::Frames<'a>::IntoIter = I
pub type image::Frames<'a>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::Frames<'a>::into_iter(self) -> I
impl<T, U> core::convert::Into<U> for image::Frames<'a> where U: core::convert::From<T>
pub fn image::Frames<'a>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::Frames<'a> where U: core::convert::Into<T>
pub type image::Frames<'a>::Error = core::convert::Infallible
pub fn image::Frames<'a>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::Frames<'a> where U: core::convert::TryFrom<T>
pub type image::Frames<'a>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::Frames<'a>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::Frames<'a> where T: 'static + ?core::marker::Sized
pub fn image::Frames<'a>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::Frames<'a> where T: ?core::marker::Sized
pub fn image::Frames<'a>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::Frames<'a> where T: ?core::marker::Sized
pub fn image::Frames<'a>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::Frames<'a>
pub fn image::Frames<'a>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::Frames<'a>
pub type image::Frames<'a>::Init = T
pub const image::Frames<'a>::ALIGN: usize
pub unsafe fn image::Frames<'a>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::Frames<'a>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::Frames<'a>::drop(ptr: usize)
pub unsafe fn image::Frames<'a>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::Frames<'a>
impl<T> itertools::Itertools for image::Frames<'a> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
pub struct image::ImageBuffer<P: image::Pixel, Container>
impl image::ImageBuffer<image::Luma<u8>, alloc::vec::Vec<u8>>
pub fn image::ImageBuffer<image::Luma<u8>, alloc::vec::Vec<u8>>::expand_palette(self, palette: &[(u8, u8, u8)], transparent_idx: core::option::Option<u8>) -> image::RgbaImage
impl<P, Container> image::ImageBuffer<P, Container> where P: image::Pixel + core::marker::Send + core::marker::Sync, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]> + core::ops::deref::DerefMut
pub fn image::ImageBuffer<P, Container>::par_enumerate_pixels_mut(&mut self) -> image::buffer::EnumeratePixelsMutPar<'_, P>
pub fn image::ImageBuffer<P, Container>::par_pixels_mut(&mut self) -> image::buffer::PixelsMutPar<'_, P>
impl<P, Container> image::ImageBuffer<P, Container> where P: image::Pixel + core::marker::Sync, <P as image::Pixel>::Subpixel: core::marker::Sync, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
pub fn image::ImageBuffer<P, Container>::par_enumerate_pixels(&self) -> image::buffer::EnumeratePixelsPar<'_, P>
pub fn image::ImageBuffer<P, Container>::par_pixels(&self) -> image::buffer::PixelsPar<'_, P>
impl<P, Container> image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]> + core::ops::deref::DerefMut
pub fn image::ImageBuffer<P, Container>::enumerate_pixels_mut(&mut self) -> image::buffer::EnumeratePixelsMut<'_, P>
pub fn image::ImageBuffer<P, Container>::enumerate_rows_mut(&mut self) -> image::buffer::EnumerateRowsMut<'_, P>
pub fn image::ImageBuffer<P, Container>::get_pixel_mut(&mut self, x: u32, y: u32) -> &mut P
pub fn image::ImageBuffer<P, Container>::get_pixel_mut_checked(&mut self, x: u32, y: u32) -> core::option::Option<&mut P>
pub fn image::ImageBuffer<P, Container>::pixels_mut(&mut self) -> image::buffer::PixelsMut<'_, P>
pub fn image::ImageBuffer<P, Container>::put_pixel(&mut self, x: u32, y: u32, pixel: P)
pub fn image::ImageBuffer<P, Container>::rows_mut(&mut self) -> image::buffer::RowsMut<'_, P>
impl<P, Container> image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
pub fn image::ImageBuffer<P, Container>::as_flat_samples(&self) -> image::flat::FlatSamples<&[<P as image::Pixel>::Subpixel]> where Container: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub fn image::ImageBuffer<P, Container>::as_flat_samples_mut(&mut self) -> image::flat::FlatSamples<&mut [<P as image::Pixel>::Subpixel]> where Container: core::convert::AsMut<[<P as image::Pixel>::Subpixel]>
pub fn image::ImageBuffer<P, Container>::as_raw(&self) -> &Container
pub fn image::ImageBuffer<P, Container>::dimensions(&self) -> (u32, u32)
pub fn image::ImageBuffer<P, Container>::enumerate_pixels(&self) -> image::buffer::EnumeratePixels<'_, P>
pub fn image::ImageBuffer<P, Container>::enumerate_rows(&self) -> image::buffer::EnumerateRows<'_, P>
pub fn image::ImageBuffer<P, Container>::from_raw(width: u32, height: u32, buf: Container) -> core::option::Option<image::ImageBuffer<P, Container>>
pub fn image::ImageBuffer<P, Container>::get_pixel(&self, x: u32, y: u32) -> &P
pub fn image::ImageBuffer<P, Container>::get_pixel_checked(&self, x: u32, y: u32) -> core::option::Option<&P>
pub fn image::ImageBuffer<P, Container>::height(&self) -> u32
pub fn image::ImageBuffer<P, Container>::into_flat_samples(self) -> image::flat::FlatSamples<Container> where Container: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub fn image::ImageBuffer<P, Container>::into_raw(self) -> Container
pub fn image::ImageBuffer<P, Container>::pixels(&self) -> image::buffer::Pixels<'_, P>
pub fn image::ImageBuffer<P, Container>::rows(&self) -> image::buffer::Rows<'_, P>
pub fn image::ImageBuffer<P, Container>::sample_layout(&self) -> image::flat::SampleLayout
pub fn image::ImageBuffer<P, Container>::width(&self) -> u32
impl<P, Container> image::ImageBuffer<P, Container> where P: image::Pixel, [<P as image::Pixel>::Subpixel]: image::EncodableLayout, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
pub fn image::ImageBuffer<P, Container>::save<Q>(&self, path: Q) -> image::error::ImageResult<()> where Q: core::convert::AsRef<std::path::Path>, P: image::PixelWithColorType
impl<P, Container> image::ImageBuffer<P, Container> where P: image::Pixel, [<P as image::Pixel>::Subpixel]: image::EncodableLayout, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
pub fn image::ImageBuffer<P, Container>::save_with_format<Q>(&self, path: Q, format: image::ImageFormat) -> image::error::ImageResult<()> where Q: core::convert::AsRef<std::path::Path>, P: image::PixelWithColorType
impl<P, Container> image::ImageBuffer<P, Container> where P: image::Pixel, [<P as image::Pixel>::Subpixel]: image::EncodableLayout, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
pub fn image::ImageBuffer<P, Container>::write_to<W>(&self, writer: &mut W, format: image::ImageFormat) -> image::error::ImageResult<()> where W: std::io::Write + std::io::Seek, P: image::PixelWithColorType
impl<P, Container> image::ImageBuffer<P, Container> where P: image::Pixel, [<P as image::Pixel>::Subpixel]: image::EncodableLayout, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
pub fn image::ImageBuffer<P, Container>::write_with_encoder<E>(&self, encoder: E) -> image::error::ImageResult<()> where E: image::ImageEncoder, P: image::PixelWithColorType
impl<P: image::Pixel> image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>
pub fn image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>::from_fn<F>(width: u32, height: u32, f: F) -> image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>> where F: core::ops::function::FnMut(u32, u32) -> P
pub fn image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>::from_pixel(width: u32, height: u32, pixel: P) -> image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>
pub fn image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>::from_vec(width: u32, height: u32, buf: alloc::vec::Vec<<P as image::Pixel>::Subpixel>) -> core::option::Option<image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>>
pub fn image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>::into_vec(self) -> alloc::vec::Vec<<P as image::Pixel>::Subpixel>
pub fn image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>::new(width: u32, height: u32) -> image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>
impl<P> image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>> where P: image::Pixel + core::marker::Send + core::marker::Sync, <P as image::Pixel>::Subpixel: core::marker::Send + core::marker::Sync
pub fn image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>>::from_par_fn<F>(width: u32, height: u32, f: F) -> image::ImageBuffer<P, alloc::vec::Vec<<P as image::Pixel>::Subpixel>> where F: core::ops::function::Fn(u32, u32) -> P + core::marker::Send + core::marker::Sync
impl core::convert::From<image::DynamicImage> for image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>
pub fn image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>
pub fn image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>
pub fn image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::DynamicImage> for image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>
pub fn image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>::from(value: image::DynamicImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Luma<f32>, alloc::vec::Vec<f32>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::Luma<f32>, alloc::vec::Vec<f32>>) -> Self
impl core::convert::From<image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::Luma<u16>, alloc::vec::Vec<u16>>) -> Self
impl core::convert::From<image::ImageBuffer<image::Luma<u8>, alloc::vec::Vec<u8>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::GrayImage) -> Self
impl core::convert::From<image::ImageBuffer<image::LumaA<f32>, alloc::vec::Vec<f32>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::LumaA<f32>, alloc::vec::Vec<f32>>) -> Self
impl core::convert::From<image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::LumaA<u16>, alloc::vec::Vec<u16>>) -> Self
impl core::convert::From<image::ImageBuffer<image::LumaA<u8>, alloc::vec::Vec<u8>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::GrayAlphaImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgb<f32>, alloc::vec::Vec<f32>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::Rgb32FImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::Rgb<u16>, alloc::vec::Vec<u16>>) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgb<u8>, alloc::vec::Vec<u8>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::RgbImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgba<f32>, alloc::vec::Vec<f32>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::Rgba32FImage) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::ImageBuffer<image::Rgba<u16>, alloc::vec::Vec<u16>>) -> Self
impl core::convert::From<image::ImageBuffer<image::Rgba<u8>, alloc::vec::Vec<u8>>> for image::DynamicImage
pub fn image::DynamicImage::from(image: image::RgbaImage) -> Self
impl<Container, FromType: image::Pixel, ToType> image::buffer::ConvertBuffer<image::ImageBuffer<ToType, alloc::vec::Vec<<ToType as image::Pixel>::Subpixel>>> for image::ImageBuffer<FromType, Container> where Container: core::ops::deref::Deref<Target = [<FromType as image::Pixel>::Subpixel]>, ToType: image::color::FromColor<FromType> + image::Pixel
pub fn image::ImageBuffer<FromType, Container>::convert(&self) -> image::ImageBuffer<ToType, alloc::vec::Vec<<ToType as image::Pixel>::Subpixel>>
impl<P, Container> core::clone::Clone for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]> + core::clone::Clone
pub fn image::ImageBuffer<P, Container>::clone(&self) -> image::ImageBuffer<P, Container>
pub fn image::ImageBuffer<P, Container>::clone_from(&mut self, source: &Self)
impl<P, Container> core::default::Default for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::default::Default
pub fn image::ImageBuffer<P, Container>::default() -> Self
impl<P, Container> core::ops::deref::Deref for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
pub type image::ImageBuffer<P, Container>::Target = [<P as image::Pixel>::Subpixel]
pub fn image::ImageBuffer<P, Container>::deref(&self) -> &<Self as core::ops::deref::Deref>::Target
impl<P, Container> core::ops::deref::DerefMut for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]> + core::ops::deref::DerefMut
pub fn image::ImageBuffer<P, Container>::deref_mut(&mut self) -> &mut <Self as core::ops::deref::Deref>::Target
impl<P, Container> core::ops::index::Index<(u32, u32)> for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]>
pub type image::ImageBuffer<P, Container>::Output = P
pub fn image::ImageBuffer<P, Container>::index(&self, (x, y): (u32, u32)) -> &P
impl<P, Container> core::ops::index::IndexMut<(u32, u32)> for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]> + core::ops::deref::DerefMut
pub fn image::ImageBuffer<P, Container>::index_mut(&mut self, (x, y): (u32, u32)) -> &mut P
impl<P, Container> image::GenericImage for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]> + core::ops::deref::DerefMut
pub fn image::ImageBuffer<P, Container>::blend_pixel(&mut self, x: u32, y: u32, p: P)
pub fn image::ImageBuffer<P, Container>::copy_within(&mut self, source: image::math::Rect, x: u32, y: u32) -> bool
pub fn image::ImageBuffer<P, Container>::get_pixel_mut(&mut self, x: u32, y: u32) -> &mut P
pub fn image::ImageBuffer<P, Container>::put_pixel(&mut self, x: u32, y: u32, pixel: P)
pub unsafe fn image::ImageBuffer<P, Container>::unsafe_put_pixel(&mut self, x: u32, y: u32, pixel: P)
impl<P, Container> image::GenericImageView for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]> + core::ops::deref::Deref
pub type image::ImageBuffer<P, Container>::Pixel = P
pub fn image::ImageBuffer<P, Container>::dimensions(&self) -> (u32, u32)
pub fn image::ImageBuffer<P, Container>::get_pixel(&self, x: u32, y: u32) -> P
pub unsafe fn image::ImageBuffer<P, Container>::unsafe_get_pixel(&self, x: u32, y: u32) -> P
impl<P: core::cmp::Eq + image::Pixel, Container: core::cmp::Eq> core::cmp::Eq for image::ImageBuffer<P, Container>
impl<P: core::cmp::PartialEq + image::Pixel, Container: core::cmp::PartialEq> core::cmp::PartialEq for image::ImageBuffer<P, Container>
pub fn image::ImageBuffer<P, Container>::eq(&self, other: &image::ImageBuffer<P, Container>) -> bool
impl<P: core::fmt::Debug + image::Pixel, Container: core::fmt::Debug> core::fmt::Debug for image::ImageBuffer<P, Container>
pub fn image::ImageBuffer<P, Container>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<P: core::hash::Hash + image::Pixel, Container: core::hash::Hash> core::hash::Hash for image::ImageBuffer<P, Container>
pub fn image::ImageBuffer<P, Container>::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl<P: image::Pixel, Container> core::marker::StructuralPartialEq for image::ImageBuffer<P, Container>
impl<P, Container> core::marker::Freeze for image::ImageBuffer<P, Container> where Container: core::marker::Freeze
impl<P, Container> core::marker::Send for image::ImageBuffer<P, Container> where Container: core::marker::Send, P: core::marker::Send
impl<P, Container> core::marker::Sync for image::ImageBuffer<P, Container> where Container: core::marker::Sync, P: core::marker::Sync
impl<P, Container> core::marker::Unpin for image::ImageBuffer<P, Container> where Container: core::marker::Unpin, P: core::marker::Unpin
impl<P, Container> core::panic::unwind_safe::RefUnwindSafe for image::ImageBuffer<P, Container> where Container: core::panic::unwind_safe::RefUnwindSafe, P: core::panic::unwind_safe::RefUnwindSafe
impl<P, Container> core::panic::unwind_safe::UnwindSafe for image::ImageBuffer<P, Container> where Container: core::panic::unwind_safe::UnwindSafe, P: core::panic::unwind_safe::UnwindSafe
impl<P, T> core::ops::deref::Receiver for image::ImageBuffer<P, Container> where P: core::ops::deref::Deref<Target = T> + ?core::marker::Sized, T: ?core::marker::Sized
pub type image::ImageBuffer<P, Container>::Target = T
impl<R, P> lebe::io::ReadPrimitive<R> for image::ImageBuffer<P, Container> where R: std::io::Read + lebe::io::ReadEndian<P>, P: core::default::Default
impl<T, U> core::convert::Into<U> for image::ImageBuffer<P, Container> where U: core::convert::From<T>
pub fn image::ImageBuffer<P, Container>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::ImageBuffer<P, Container> where U: core::convert::Into<T>
pub type image::ImageBuffer<P, Container>::Error = core::convert::Infallible
pub fn image::ImageBuffer<P, Container>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::ImageBuffer<P, Container> where U: core::convert::TryFrom<T>
pub type image::ImageBuffer<P, Container>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::ImageBuffer<P, Container>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::ImageBuffer<P, Container> where T: core::clone::Clone
pub type image::ImageBuffer<P, Container>::Owned = T
pub fn image::ImageBuffer<P, Container>::clone_into(&self, target: &mut T)
pub fn image::ImageBuffer<P, Container>::to_owned(&self) -> T
impl<T> core::any::Any for image::ImageBuffer<P, Container> where T: 'static + ?core::marker::Sized
pub fn image::ImageBuffer<P, Container>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::ImageBuffer<P, Container> where T: ?core::marker::Sized
pub fn image::ImageBuffer<P, Container>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::ImageBuffer<P, Container> where T: ?core::marker::Sized
pub fn image::ImageBuffer<P, Container>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::ImageBuffer<P, Container> where T: core::clone::Clone
pub unsafe fn image::ImageBuffer<P, Container>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::ImageBuffer<P, Container>
pub fn image::ImageBuffer<P, Container>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::ImageBuffer<P, Container>
pub type image::ImageBuffer<P, Container>::Init = T
pub const image::ImageBuffer<P, Container>::ALIGN: usize
pub unsafe fn image::ImageBuffer<P, Container>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::ImageBuffer<P, Container>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::ImageBuffer<P, Container>::drop(ptr: usize)
pub unsafe fn image::ImageBuffer<P, Container>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::ImageBuffer<P, Container>
pub struct image::ImageReader<R: std::io::Read + std::io::Seek>
impl image::ImageReader<std::io::buffered::bufreader::BufReader<std::fs::File>>
pub fn image::ImageReader<std::io::buffered::bufreader::BufReader<std::fs::File>>::open<P>(path: P) -> std::io::error::Result<Self> where P: core::convert::AsRef<std::path::Path>
impl<'a, R: 'a + std::io::BufRead + std::io::Seek> image::ImageReader<R>
pub fn image::ImageReader<R>::clear_format(&mut self)
pub fn image::ImageReader<R>::decode(self) -> image::error::ImageResult<image::DynamicImage>
pub fn image::ImageReader<R>::format(&self) -> core::option::Option<image::ImageFormat>
pub fn image::ImageReader<R>::into_decoder(self) -> image::error::ImageResult<impl image::ImageDecoder + 'a>
pub fn image::ImageReader<R>::into_dimensions(self) -> image::error::ImageResult<(u32, u32)>
pub fn image::ImageReader<R>::into_inner(self) -> R
pub fn image::ImageReader<R>::limits(&mut self, limits: image::Limits)
pub fn image::ImageReader<R>::new(buffered_reader: R) -> Self
pub fn image::ImageReader<R>::no_limits(&mut self)
pub fn image::ImageReader<R>::set_format(&mut self, format: image::ImageFormat)
pub fn image::ImageReader<R>::with_format(buffered_reader: R, format: image::ImageFormat) -> Self
pub fn image::ImageReader<R>::with_guessed_format(self) -> std::io::error::Result<Self>
impl<R> core::marker::Freeze for image::ImageReader<R> where R: core::marker::Freeze
impl<R> core::marker::Send for image::ImageReader<R> where R: core::marker::Send
impl<R> core::marker::Sync for image::ImageReader<R> where R: core::marker::Sync
impl<R> core::marker::Unpin for image::ImageReader<R> where R: core::marker::Unpin
impl<R> core::panic::unwind_safe::RefUnwindSafe for image::ImageReader<R> where R: core::panic::unwind_safe::RefUnwindSafe
impl<R> core::panic::unwind_safe::UnwindSafe for image::ImageReader<R> where R: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::ImageReader<R> where U: core::convert::From<T>
pub fn image::ImageReader<R>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::ImageReader<R> where U: core::convert::Into<T>
pub type image::ImageReader<R>::Error = core::convert::Infallible
pub fn image::ImageReader<R>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::ImageReader<R> where U: core::convert::TryFrom<T>
pub type image::ImageReader<R>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::ImageReader<R>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for image::ImageReader<R> where T: 'static + ?core::marker::Sized
pub fn image::ImageReader<R>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::ImageReader<R> where T: ?core::marker::Sized
pub fn image::ImageReader<R>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::ImageReader<R> where T: ?core::marker::Sized
pub fn image::ImageReader<R>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for image::ImageReader<R>
pub fn image::ImageReader<R>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::ImageReader<R>
pub type image::ImageReader<R>::Init = T
pub const image::ImageReader<R>::ALIGN: usize
pub unsafe fn image::ImageReader<R>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::ImageReader<R>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::ImageReader<R>::drop(ptr: usize)
pub unsafe fn image::ImageReader<R>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::ImageReader<R>
#[non_exhaustive] pub struct image::LimitSupport
impl core::clone::Clone for image::LimitSupport
pub fn image::LimitSupport::clone(&self) -> image::LimitSupport
impl core::cmp::Eq for image::LimitSupport
impl core::cmp::PartialEq for image::LimitSupport
pub fn image::LimitSupport::eq(&self, other: &image::LimitSupport) -> bool
impl core::default::Default for image::LimitSupport
pub fn image::LimitSupport::default() -> image::LimitSupport
impl core::fmt::Debug for image::LimitSupport
pub fn image::LimitSupport::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::LimitSupport
pub fn image::LimitSupport::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for image::LimitSupport
impl core::marker::Freeze for image::LimitSupport
impl core::marker::Send for image::LimitSupport
impl core::marker::Sync for image::LimitSupport
impl core::marker::Unpin for image::LimitSupport
impl core::panic::unwind_safe::RefUnwindSafe for image::LimitSupport
impl core::panic::unwind_safe::UnwindSafe for image::LimitSupport
impl<R, P> lebe::io::ReadPrimitive<R> for image::LimitSupport where R: std::io::Read + lebe::io::ReadEndian<P>, P: core::default::Default
impl<T, U> core::convert::Into<U> for image::LimitSupport where U: core::convert::From<T>
pub fn image::LimitSupport::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::LimitSupport where U: core::convert::Into<T>
pub type image::LimitSupport::Error = core::convert::Infallible
pub fn image::LimitSupport::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::LimitSupport where U: core::convert::TryFrom<T>
pub type image::LimitSupport::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::LimitSupport::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::LimitSupport where T: core::clone::Clone
pub type image::LimitSupport::Owned = T
pub fn image::LimitSupport::clone_into(&self, target: &mut T)
pub fn image::LimitSupport::to_owned(&self) -> T
impl<T> core::any::Any for image::LimitSupport where T: 'static + ?core::marker::Sized
pub fn image::LimitSupport::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::LimitSupport where T: ?core::marker::Sized
pub fn image::LimitSupport::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::LimitSupport where T: ?core::marker::Sized
pub fn image::LimitSupport::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::LimitSupport where T: core::clone::Clone
pub unsafe fn image::LimitSupport::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::LimitSupport
pub fn image::LimitSupport::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::LimitSupport
pub type image::LimitSupport::Init = T
pub const image::LimitSupport::ALIGN: usize
pub unsafe fn image::LimitSupport::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::LimitSupport::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::LimitSupport::drop(ptr: usize)
pub unsafe fn image::LimitSupport::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::LimitSupport
#[non_exhaustive] pub struct image::Limits
pub image::Limits::max_alloc: core::option::Option<u64>
pub image::Limits::max_image_height: core::option::Option<u32>
pub image::Limits::max_image_width: core::option::Option<u32>
impl image::Limits
pub fn image::Limits::check_dimensions(&self, width: u32, height: u32) -> image::error::ImageResult<()>
pub fn image::Limits::check_support(&self, _supported: &image::LimitSupport) -> image::error::ImageResult<()>
pub fn image::Limits::free(&mut self, amount: u64)
pub fn image::Limits::free_usize(&mut self, amount: usize)
pub fn image::Limits::no_limits() -> image::Limits
pub fn image::Limits::reserve(&mut self, amount: u64) -> image::error::ImageResult<()>
pub fn image::Limits::reserve_buffer(&mut self, width: u32, height: u32, color_type: image::ColorType) -> image::error::ImageResult<()>
pub fn image::Limits::reserve_usize(&mut self, amount: usize) -> image::error::ImageResult<()>
impl core::clone::Clone for image::Limits
pub fn image::Limits::clone(&self) -> image::Limits
impl core::cmp::Eq for image::Limits
impl core::cmp::PartialEq for image::Limits
pub fn image::Limits::eq(&self, other: &image::Limits) -> bool
impl core::default::Default for image::Limits
pub fn image::Limits::default() -> image::Limits
impl core::fmt::Debug for image::Limits
pub fn image::Limits::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::hash::Hash for image::Limits
pub fn image::Limits::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl core::marker::StructuralPartialEq for image::Limits
impl core::marker::Freeze for image::Limits
impl core::marker::Send for image::Limits
impl core::marker::Sync for image::Limits
impl core::marker::Unpin for image::Limits
impl core::panic::unwind_safe::RefUnwindSafe for image::Limits
impl core::panic::unwind_safe::UnwindSafe for image::Limits
impl<R, P> lebe::io::ReadPrimitive<R> for image::Limits where R: std::io::Read + lebe::io::ReadEndian<P>, P: core::default::Default
impl<T, U> core::convert::Into<U> for image::Limits where U: core::convert::From<T>
pub fn image::Limits::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::Limits where U: core::convert::Into<T>
pub type image::Limits::Error = core::convert::Infallible
pub fn image::Limits::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::Limits where U: core::convert::TryFrom<T>
pub type image::Limits::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::Limits::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::Limits where T: core::clone::Clone
pub type image::Limits::Owned = T
pub fn image::Limits::clone_into(&self, target: &mut T)
pub fn image::Limits::to_owned(&self) -> T
impl<T> core::any::Any for image::Limits where T: 'static + ?core::marker::Sized
pub fn image::Limits::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::Limits where T: ?core::marker::Sized
pub fn image::Limits::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::Limits where T: ?core::marker::Sized
pub fn image::Limits::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::Limits where T: core::clone::Clone
pub unsafe fn image::Limits::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::Limits
pub fn image::Limits::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::Limits
pub type image::Limits::Init = T
pub const image::Limits::ALIGN: usize
pub unsafe fn image::Limits::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::Limits::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::Limits::drop(ptr: usize)
pub unsafe fn image::Limits::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::Limits
#[repr(transparent)] pub struct image::Luma<T>(pub [T; 1])
impl image::PixelWithColorType for image::Luma<u16>
pub const image::Luma<u16>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Luma<u8>
pub const image::Luma<u8>::COLOR_TYPE: image::ExtendedColorType
impl<T: core::clone::Clone> core::clone::Clone for image::Luma<T>
pub fn image::Luma<T>::clone(&self) -> image::Luma<T>
impl<T: core::cmp::Eq> core::cmp::Eq for image::Luma<T>
impl<T: core::cmp::PartialEq> core::cmp::PartialEq for image::Luma<T>
pub fn image::Luma<T>::eq(&self, other: &image::Luma<T>) -> bool
impl<T: core::fmt::Debug> core::fmt::Debug for image::Luma<T>
pub fn image::Luma<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::hash::Hash> core::hash::Hash for image::Luma<T>
pub fn image::Luma<T>::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl<T: core::marker::Copy> core::marker::Copy for image::Luma<T>
impl<T: image::Primitive> image::Pixel for image::Luma<T>
pub type image::Luma<T>::Subpixel = T
pub const image::Luma<T>::CHANNEL_COUNT: u8
pub const image::Luma<T>::COLOR_MODEL: &'static str
pub fn image::Luma<T>::apply<F>(&mut self, f: F) where F: core::ops::function::FnMut(T) -> T
pub fn image::Luma<T>::apply2<F>(&mut self, other: &image::Luma<T>, f: F) where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Luma<T>::apply_with_alpha<F, G>(&mut self, f: F, g: G) where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Luma<T>::blend(&mut self, other: &image::Luma<T>)
pub fn image::Luma<T>::channels(&self) -> &[T]
pub fn image::Luma<T>::channels4(&self) -> (T, T, T, T)
pub fn image::Luma<T>::channels_mut(&mut self) -> &mut [T]
pub fn image::Luma<T>::from_channels(a: T, b: T, c: T, d: T) -> image::Luma<T>
pub fn image::Luma<T>::from_slice(slice: &[T]) -> &image::Luma<T>
pub fn image::Luma<T>::from_slice_mut(slice: &mut [T]) -> &mut image::Luma<T>
pub fn image::Luma<T>::invert(&mut self)
pub fn image::Luma<T>::map<F>(&self, f: F) -> image::Luma<T> where F: core::ops::function::FnMut(T) -> T
pub fn image::Luma<T>::map2<F>(&self, other: &Self, f: F) -> image::Luma<T> where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Luma<T>::map_with_alpha<F, G>(&self, f: F, g: G) -> image::Luma<T> where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Luma<T>::to_luma(&self) -> image::Luma<T>
pub fn image::Luma<T>::to_luma_alpha(&self) -> image::LumaA<T>
pub fn image::Luma<T>::to_rgb(&self) -> image::Rgb<T>
pub fn image::Luma<T>::to_rgba(&self) -> image::Rgba<T>
impl<T> core::convert::From<[T; 1]> for image::Luma<T>
pub fn image::Luma<T>::from(c: [T; 1]) -> Self
impl<T> core::marker::StructuralPartialEq for image::Luma<T>
impl<T> core::ops::index::Index<usize> for image::Luma<T>
pub type image::Luma<T>::Output = T
pub fn image::Luma<T>::index(&self, _index: usize) -> &T
impl<T> core::ops::index::IndexMut<usize> for image::Luma<T>
pub fn image::Luma<T>::index_mut(&mut self, _index: usize) -> &mut T
impl<T> core::marker::Freeze for image::Luma<T> where T: core::marker::Freeze
impl<T> core::marker::Send for image::Luma<T> where T: core::marker::Send
impl<T> core::marker::Sync for image::Luma<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for image::Luma<T> where T: core::marker::Unpin
impl<T> core::panic::unwind_safe::RefUnwindSafe for image::Luma<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for image::Luma<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::Luma<T> where U: core::convert::From<T>
pub fn image::Luma<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::Luma<T> where U: core::convert::Into<T>
pub type image::Luma<T>::Error = core::convert::Infallible
pub fn image::Luma<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::Luma<T> where U: core::convert::TryFrom<T>
pub type image::Luma<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::Luma<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::Luma<T> where T: core::clone::Clone
pub type image::Luma<T>::Owned = T
pub fn image::Luma<T>::clone_into(&self, target: &mut T)
pub fn image::Luma<T>::to_owned(&self) -> T
impl<T> core::any::Any for image::Luma<T> where T: 'static + ?core::marker::Sized
pub fn image::Luma<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::Luma<T> where T: ?core::marker::Sized
pub fn image::Luma<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::Luma<T> where T: ?core::marker::Sized
pub fn image::Luma<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::Luma<T> where T: core::clone::Clone
pub unsafe fn image::Luma<T>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::Luma<T>
pub fn image::Luma<T>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::Luma<T>
pub type image::Luma<T>::Init = T
pub const image::Luma<T>::ALIGN: usize
pub unsafe fn image::Luma<T>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::Luma<T>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::Luma<T>::drop(ptr: usize)
pub unsafe fn image::Luma<T>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::Luma<T>
#[repr(transparent)] pub struct image::LumaA<T>(pub [T; 2])
impl image::PixelWithColorType for image::LumaA<u16>
pub const image::LumaA<u16>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::LumaA<u8>
pub const image::LumaA<u8>::COLOR_TYPE: image::ExtendedColorType
impl<T: core::clone::Clone> core::clone::Clone for image::LumaA<T>
pub fn image::LumaA<T>::clone(&self) -> image::LumaA<T>
impl<T: core::cmp::Eq> core::cmp::Eq for image::LumaA<T>
impl<T: core::cmp::PartialEq> core::cmp::PartialEq for image::LumaA<T>
pub fn image::LumaA<T>::eq(&self, other: &image::LumaA<T>) -> bool
impl<T: core::fmt::Debug> core::fmt::Debug for image::LumaA<T>
pub fn image::LumaA<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::hash::Hash> core::hash::Hash for image::LumaA<T>
pub fn image::LumaA<T>::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl<T: core::marker::Copy> core::marker::Copy for image::LumaA<T>
impl<T: image::Primitive> image::Pixel for image::LumaA<T>
pub type image::LumaA<T>::Subpixel = T
pub const image::LumaA<T>::CHANNEL_COUNT: u8
pub const image::LumaA<T>::COLOR_MODEL: &'static str
pub fn image::LumaA<T>::apply<F>(&mut self, f: F) where F: core::ops::function::FnMut(T) -> T
pub fn image::LumaA<T>::apply2<F>(&mut self, other: &image::LumaA<T>, f: F) where F: core::ops::function::FnMut(T, T) -> T
pub fn image::LumaA<T>::apply_with_alpha<F, G>(&mut self, f: F, g: G) where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::LumaA<T>::blend(&mut self, other: &image::LumaA<T>)
pub fn image::LumaA<T>::channels(&self) -> &[T]
pub fn image::LumaA<T>::channels4(&self) -> (T, T, T, T)
pub fn image::LumaA<T>::channels_mut(&mut self) -> &mut [T]
pub fn image::LumaA<T>::from_channels(a: T, b: T, c: T, d: T) -> image::LumaA<T>
pub fn image::LumaA<T>::from_slice(slice: &[T]) -> &image::LumaA<T>
pub fn image::LumaA<T>::from_slice_mut(slice: &mut [T]) -> &mut image::LumaA<T>
pub fn image::LumaA<T>::invert(&mut self)
pub fn image::LumaA<T>::map<F>(&self, f: F) -> image::LumaA<T> where F: core::ops::function::FnMut(T) -> T
pub fn image::LumaA<T>::map2<F>(&self, other: &Self, f: F) -> image::LumaA<T> where F: core::ops::function::FnMut(T, T) -> T
pub fn image::LumaA<T>::map_with_alpha<F, G>(&self, f: F, g: G) -> image::LumaA<T> where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::LumaA<T>::to_luma(&self) -> image::Luma<T>
pub fn image::LumaA<T>::to_luma_alpha(&self) -> image::LumaA<T>
pub fn image::LumaA<T>::to_rgb(&self) -> image::Rgb<T>
pub fn image::LumaA<T>::to_rgba(&self) -> image::Rgba<T>
impl<T> core::convert::From<[T; 2]> for image::LumaA<T>
pub fn image::LumaA<T>::from(c: [T; 2]) -> Self
impl<T> core::marker::StructuralPartialEq for image::LumaA<T>
impl<T> core::ops::index::Index<usize> for image::LumaA<T>
pub type image::LumaA<T>::Output = T
pub fn image::LumaA<T>::index(&self, _index: usize) -> &T
impl<T> core::ops::index::IndexMut<usize> for image::LumaA<T>
pub fn image::LumaA<T>::index_mut(&mut self, _index: usize) -> &mut T
impl<T> core::marker::Freeze for image::LumaA<T> where T: core::marker::Freeze
impl<T> core::marker::Send for image::LumaA<T> where T: core::marker::Send
impl<T> core::marker::Sync for image::LumaA<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for image::LumaA<T> where T: core::marker::Unpin
impl<T> core::panic::unwind_safe::RefUnwindSafe for image::LumaA<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for image::LumaA<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::LumaA<T> where U: core::convert::From<T>
pub fn image::LumaA<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::LumaA<T> where U: core::convert::Into<T>
pub type image::LumaA<T>::Error = core::convert::Infallible
pub fn image::LumaA<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::LumaA<T> where U: core::convert::TryFrom<T>
pub type image::LumaA<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::LumaA<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::LumaA<T> where T: core::clone::Clone
pub type image::LumaA<T>::Owned = T
pub fn image::LumaA<T>::clone_into(&self, target: &mut T)
pub fn image::LumaA<T>::to_owned(&self) -> T
impl<T> core::any::Any for image::LumaA<T> where T: 'static + ?core::marker::Sized
pub fn image::LumaA<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::LumaA<T> where T: ?core::marker::Sized
pub fn image::LumaA<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::LumaA<T> where T: ?core::marker::Sized
pub fn image::LumaA<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::LumaA<T> where T: core::clone::Clone
pub unsafe fn image::LumaA<T>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::LumaA<T>
pub fn image::LumaA<T>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::LumaA<T>
pub type image::LumaA<T>::Init = T
pub const image::LumaA<T>::ALIGN: usize
pub unsafe fn image::LumaA<T>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::LumaA<T>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::LumaA<T>::drop(ptr: usize)
pub unsafe fn image::LumaA<T>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::LumaA<T>
pub struct image::Pixels<'a, I: ?core::marker::Sized + 'a>
impl<'a, I: core::fmt::Debug + ?core::marker::Sized + 'a> core::fmt::Debug for image::Pixels<'a, I>
pub fn image::Pixels<'a, I>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<I: ?core::marker::Sized> core::clone::Clone for image::Pixels<'_, I>
pub fn image::Pixels<'_, I>::clone(&self) -> Self
impl<I: image::GenericImageView> core::iter::traits::iterator::Iterator for image::Pixels<'_, I>
pub type image::Pixels<'_, I>::Item = (u32, u32, <I as image::GenericImageView>::Pixel)
pub fn image::Pixels<'_, I>::next(&mut self) -> core::option::Option<(u32, u32, <I as image::GenericImageView>::Pixel)>
impl<'a, I> core::marker::Freeze for image::Pixels<'a, I> where I: ?core::marker::Sized
impl<'a, I> core::marker::Send for image::Pixels<'a, I> where I: core::marker::Sync + ?core::marker::Sized
impl<'a, I> core::marker::Sync for image::Pixels<'a, I> where I: core::marker::Sync + ?core::marker::Sized
impl<'a, I> core::marker::Unpin for image::Pixels<'a, I> where I: ?core::marker::Sized
impl<'a, I> core::panic::unwind_safe::RefUnwindSafe for image::Pixels<'a, I> where I: core::panic::unwind_safe::RefUnwindSafe + ?core::marker::Sized
impl<'a, I> core::panic::unwind_safe::UnwindSafe for image::Pixels<'a, I> where I: core::panic::unwind_safe::RefUnwindSafe + ?core::marker::Sized
impl<I> core::iter::traits::collect::IntoIterator for image::Pixels<'a, I> where I: core::iter::traits::iterator::Iterator
pub type image::Pixels<'a, I>::IntoIter = I
pub type image::Pixels<'a, I>::Item = <I as core::iter::traits::iterator::Iterator>::Item
pub fn image::Pixels<'a, I>::into_iter(self) -> I
impl<IT, A, FromA, B, FromB, C, FromC> itertools::unziptuple::MultiUnzip<(FromA, FromB, FromC)> for image::Pixels<'a, I> where IT: core::iter::traits::iterator::Iterator<Item = (A, B, C)>, FromA: core::default::Default + core::iter::traits::collect::Extend<A>, FromB: core::default::Default + core::iter::traits::collect::Extend<B>, FromC: core::default::Default + core::iter::traits::collect::Extend<C>
pub fn image::Pixels<'a, I>::multiunzip(self) -> (FromA, FromB, FromC)
impl<T, U> core::convert::Into<U> for image::Pixels<'a, I> where U: core::convert::From<T>
pub fn image::Pixels<'a, I>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::Pixels<'a, I> where U: core::convert::Into<T>
pub type image::Pixels<'a, I>::Error = core::convert::Infallible
pub fn image::Pixels<'a, I>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::Pixels<'a, I> where U: core::convert::TryFrom<T>
pub type image::Pixels<'a, I>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::Pixels<'a, I>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::Pixels<'a, I> where T: core::clone::Clone
pub type image::Pixels<'a, I>::Owned = T
pub fn image::Pixels<'a, I>::clone_into(&self, target: &mut T)
pub fn image::Pixels<'a, I>::to_owned(&self) -> T
impl<T> core::any::Any for image::Pixels<'a, I> where T: 'static + ?core::marker::Sized
pub fn image::Pixels<'a, I>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::Pixels<'a, I> where T: ?core::marker::Sized
pub fn image::Pixels<'a, I>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::Pixels<'a, I> where T: ?core::marker::Sized
pub fn image::Pixels<'a, I>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::Pixels<'a, I> where T: core::clone::Clone
pub unsafe fn image::Pixels<'a, I>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::Pixels<'a, I>
pub fn image::Pixels<'a, I>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::Pixels<'a, I>
pub type image::Pixels<'a, I>::Init = T
pub const image::Pixels<'a, I>::ALIGN: usize
pub unsafe fn image::Pixels<'a, I>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::Pixels<'a, I>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::Pixels<'a, I>::drop(ptr: usize)
pub unsafe fn image::Pixels<'a, I>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::Pixels<'a, I>
impl<T> itertools::Itertools for image::Pixels<'a, I> where T: core::iter::traits::iterator::Iterator + ?core::marker::Sized
#[repr(transparent)] pub struct image::Rgb<T>(pub [T; 3])
impl image::PixelWithColorType for image::Rgb<f32>
pub const image::Rgb<f32>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgb<u16>
pub const image::Rgb<u16>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgb<u8>
pub const image::Rgb<u8>::COLOR_TYPE: image::ExtendedColorType
impl<T: core::clone::Clone> core::clone::Clone for image::Rgb<T>
pub fn image::Rgb<T>::clone(&self) -> image::Rgb<T>
impl<T: core::cmp::Eq> core::cmp::Eq for image::Rgb<T>
impl<T: core::cmp::PartialEq> core::cmp::PartialEq for image::Rgb<T>
pub fn image::Rgb<T>::eq(&self, other: &image::Rgb<T>) -> bool
impl<T: core::fmt::Debug> core::fmt::Debug for image::Rgb<T>
pub fn image::Rgb<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::hash::Hash> core::hash::Hash for image::Rgb<T>
pub fn image::Rgb<T>::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl<T: core::marker::Copy> core::marker::Copy for image::Rgb<T>
impl<T: image::Primitive + image::traits::Enlargeable> image::Pixel for image::Rgb<T>
pub type image::Rgb<T>::Subpixel = T
pub const image::Rgb<T>::CHANNEL_COUNT: u8
pub const image::Rgb<T>::COLOR_MODEL: &'static str
pub fn image::Rgb<T>::apply<F>(&mut self, f: F) where F: core::ops::function::FnMut(T) -> T
pub fn image::Rgb<T>::apply2<F>(&mut self, other: &image::Rgb<T>, f: F) where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Rgb<T>::apply_with_alpha<F, G>(&mut self, f: F, g: G) where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Rgb<T>::blend(&mut self, other: &image::Rgb<T>)
pub fn image::Rgb<T>::channels(&self) -> &[T]
pub fn image::Rgb<T>::channels4(&self) -> (T, T, T, T)
pub fn image::Rgb<T>::channels_mut(&mut self) -> &mut [T]
pub fn image::Rgb<T>::from_channels(a: T, b: T, c: T, d: T) -> image::Rgb<T>
pub fn image::Rgb<T>::from_slice(slice: &[T]) -> &image::Rgb<T>
pub fn image::Rgb<T>::from_slice_mut(slice: &mut [T]) -> &mut image::Rgb<T>
pub fn image::Rgb<T>::invert(&mut self)
pub fn image::Rgb<T>::map<F>(&self, f: F) -> image::Rgb<T> where F: core::ops::function::FnMut(T) -> T
pub fn image::Rgb<T>::map2<F>(&self, other: &Self, f: F) -> image::Rgb<T> where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Rgb<T>::map_with_alpha<F, G>(&self, f: F, g: G) -> image::Rgb<T> where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Rgb<T>::to_luma(&self) -> image::Luma<T>
pub fn image::Rgb<T>::to_luma_alpha(&self) -> image::LumaA<T>
pub fn image::Rgb<T>::to_rgb(&self) -> image::Rgb<T>
pub fn image::Rgb<T>::to_rgba(&self) -> image::Rgba<T>
impl<T> core::convert::From<[T; 3]> for image::Rgb<T>
pub fn image::Rgb<T>::from(c: [T; 3]) -> Self
impl<T> core::marker::StructuralPartialEq for image::Rgb<T>
impl<T> core::ops::index::Index<usize> for image::Rgb<T>
pub type image::Rgb<T>::Output = T
pub fn image::Rgb<T>::index(&self, _index: usize) -> &T
impl<T> core::ops::index::IndexMut<usize> for image::Rgb<T>
pub fn image::Rgb<T>::index_mut(&mut self, _index: usize) -> &mut T
impl<T> core::marker::Freeze for image::Rgb<T> where T: core::marker::Freeze
impl<T> core::marker::Send for image::Rgb<T> where T: core::marker::Send
impl<T> core::marker::Sync for image::Rgb<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for image::Rgb<T> where T: core::marker::Unpin
impl<T> core::panic::unwind_safe::RefUnwindSafe for image::Rgb<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for image::Rgb<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::Rgb<T> where U: core::convert::From<T>
pub fn image::Rgb<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::Rgb<T> where U: core::convert::Into<T>
pub type image::Rgb<T>::Error = core::convert::Infallible
pub fn image::Rgb<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::Rgb<T> where U: core::convert::TryFrom<T>
pub type image::Rgb<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::Rgb<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::Rgb<T> where T: core::clone::Clone
pub type image::Rgb<T>::Owned = T
pub fn image::Rgb<T>::clone_into(&self, target: &mut T)
pub fn image::Rgb<T>::to_owned(&self) -> T
impl<T> core::any::Any for image::Rgb<T> where T: 'static + ?core::marker::Sized
pub fn image::Rgb<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::Rgb<T> where T: ?core::marker::Sized
pub fn image::Rgb<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::Rgb<T> where T: ?core::marker::Sized
pub fn image::Rgb<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::Rgb<T> where T: core::clone::Clone
pub unsafe fn image::Rgb<T>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::Rgb<T>
pub fn image::Rgb<T>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::Rgb<T>
pub type image::Rgb<T>::Init = T
pub const image::Rgb<T>::ALIGN: usize
pub unsafe fn image::Rgb<T>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::Rgb<T>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::Rgb<T>::drop(ptr: usize)
pub unsafe fn image::Rgb<T>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::Rgb<T>
#[repr(transparent)] pub struct image::Rgba<T>(pub [T; 4])
impl image::PixelWithColorType for image::Rgba<f32>
pub const image::Rgba<f32>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgba<u16>
pub const image::Rgba<u16>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgba<u8>
pub const image::Rgba<u8>::COLOR_TYPE: image::ExtendedColorType
impl<T: core::clone::Clone> core::clone::Clone for image::Rgba<T>
pub fn image::Rgba<T>::clone(&self) -> image::Rgba<T>
impl<T: core::cmp::Eq> core::cmp::Eq for image::Rgba<T>
impl<T: core::cmp::PartialEq> core::cmp::PartialEq for image::Rgba<T>
pub fn image::Rgba<T>::eq(&self, other: &image::Rgba<T>) -> bool
impl<T: core::fmt::Debug> core::fmt::Debug for image::Rgba<T>
pub fn image::Rgba<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::hash::Hash> core::hash::Hash for image::Rgba<T>
pub fn image::Rgba<T>::hash<__H: core::hash::Hasher>(&self, state: &mut __H)
impl<T: core::marker::Copy> core::marker::Copy for image::Rgba<T>
impl<T: image::Primitive + image::traits::Enlargeable> image::Pixel for image::Rgba<T>
pub type image::Rgba<T>::Subpixel = T
pub const image::Rgba<T>::CHANNEL_COUNT: u8
pub const image::Rgba<T>::COLOR_MODEL: &'static str
pub fn image::Rgba<T>::apply<F>(&mut self, f: F) where F: core::ops::function::FnMut(T) -> T
pub fn image::Rgba<T>::apply2<F>(&mut self, other: &image::Rgba<T>, f: F) where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Rgba<T>::apply_with_alpha<F, G>(&mut self, f: F, g: G) where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Rgba<T>::blend(&mut self, other: &image::Rgba<T>)
pub fn image::Rgba<T>::channels(&self) -> &[T]
pub fn image::Rgba<T>::channels4(&self) -> (T, T, T, T)
pub fn image::Rgba<T>::channels_mut(&mut self) -> &mut [T]
pub fn image::Rgba<T>::from_channels(a: T, b: T, c: T, d: T) -> image::Rgba<T>
pub fn image::Rgba<T>::from_slice(slice: &[T]) -> &image::Rgba<T>
pub fn image::Rgba<T>::from_slice_mut(slice: &mut [T]) -> &mut image::Rgba<T>
pub fn image::Rgba<T>::invert(&mut self)
pub fn image::Rgba<T>::map<F>(&self, f: F) -> image::Rgba<T> where F: core::ops::function::FnMut(T) -> T
pub fn image::Rgba<T>::map2<F>(&self, other: &Self, f: F) -> image::Rgba<T> where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Rgba<T>::map_with_alpha<F, G>(&self, f: F, g: G) -> image::Rgba<T> where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Rgba<T>::to_luma(&self) -> image::Luma<T>
pub fn image::Rgba<T>::to_luma_alpha(&self) -> image::LumaA<T>
pub fn image::Rgba<T>::to_rgb(&self) -> image::Rgb<T>
pub fn image::Rgba<T>::to_rgba(&self) -> image::Rgba<T>
impl<T> core::convert::From<[T; 4]> for image::Rgba<T>
pub fn image::Rgba<T>::from(c: [T; 4]) -> Self
impl<T> core::marker::StructuralPartialEq for image::Rgba<T>
impl<T> core::ops::index::Index<usize> for image::Rgba<T>
pub type image::Rgba<T>::Output = T
pub fn image::Rgba<T>::index(&self, _index: usize) -> &T
impl<T> core::ops::index::IndexMut<usize> for image::Rgba<T>
pub fn image::Rgba<T>::index_mut(&mut self, _index: usize) -> &mut T
impl<T> core::marker::Freeze for image::Rgba<T> where T: core::marker::Freeze
impl<T> core::marker::Send for image::Rgba<T> where T: core::marker::Send
impl<T> core::marker::Sync for image::Rgba<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for image::Rgba<T> where T: core::marker::Unpin
impl<T> core::panic::unwind_safe::RefUnwindSafe for image::Rgba<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for image::Rgba<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for image::Rgba<T> where U: core::convert::From<T>
pub fn image::Rgba<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::Rgba<T> where U: core::convert::Into<T>
pub type image::Rgba<T>::Error = core::convert::Infallible
pub fn image::Rgba<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::Rgba<T> where U: core::convert::TryFrom<T>
pub type image::Rgba<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::Rgba<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::Rgba<T> where T: core::clone::Clone
pub type image::Rgba<T>::Owned = T
pub fn image::Rgba<T>::clone_into(&self, target: &mut T)
pub fn image::Rgba<T>::to_owned(&self) -> T
impl<T> core::any::Any for image::Rgba<T> where T: 'static + ?core::marker::Sized
pub fn image::Rgba<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::Rgba<T> where T: ?core::marker::Sized
pub fn image::Rgba<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::Rgba<T> where T: ?core::marker::Sized
pub fn image::Rgba<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::Rgba<T> where T: core::clone::Clone
pub unsafe fn image::Rgba<T>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::Rgba<T>
pub fn image::Rgba<T>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::Rgba<T>
pub type image::Rgba<T>::Init = T
pub const image::Rgba<T>::ALIGN: usize
pub unsafe fn image::Rgba<T>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::Rgba<T>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::Rgba<T>::drop(ptr: usize)
pub unsafe fn image::Rgba<T>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::Rgba<T>
pub struct image::SubImage<I>
impl<I> image::SubImage<I> where I: core::ops::deref::Deref, <I as core::ops::deref::Deref>::Target: image::GenericImageView
pub fn image::SubImage<I>::inner(&self) -> &<I as core::ops::deref::Deref>::Target
pub fn image::SubImage<I>::view(&self, x: u32, y: u32, width: u32, height: u32) -> image::SubImage<&<I as core::ops::deref::Deref>::Target>
impl<I> image::SubImage<I> where I: core::ops::deref::DerefMut, <I as core::ops::deref::Deref>::Target: image::GenericImage
pub fn image::SubImage<I>::inner_mut(&mut self) -> &mut <I as core::ops::deref::Deref>::Target
pub fn image::SubImage<I>::sub_image(&mut self, x: u32, y: u32, width: u32, height: u32) -> image::SubImage<&mut <I as core::ops::deref::Deref>::Target>
impl<I> image::SubImage<I>
pub fn image::SubImage<I>::change_bounds(&mut self, x: u32, y: u32, width: u32, height: u32)
pub fn image::SubImage<I>::new(image: I, x: u32, y: u32, width: u32, height: u32) -> image::SubImage<I>
pub fn image::SubImage<I>::offsets(&self) -> (u32, u32)
pub fn image::SubImage<I>::to_image(&self) -> image::ImageBuffer<<<I as core::ops::deref::Deref>::Target as image::GenericImageView>::Pixel, alloc::vec::Vec<<<<I as core::ops::deref::Deref>::Target as image::GenericImageView>::Pixel as image::Pixel>::Subpixel>> where I: core::ops::deref::Deref, <I as core::ops::deref::Deref>::Target: image::GenericImageView + 'static
impl<I: core::clone::Clone> core::clone::Clone for image::SubImage<I>
pub fn image::SubImage<I>::clone(&self) -> image::SubImage<I>
impl<I: core::marker::Copy> core::marker::Copy for image::SubImage<I>
impl<I> core::ops::deref::Deref for image::SubImage<I> where I: core::ops::deref::Deref
pub type image::SubImage<I>::Target = image::image::SubImageInner<I>
pub fn image::SubImage<I>::deref(&self) -> &Self::Target
impl<I> core::ops::deref::DerefMut for image::SubImage<I> where I: core::ops::deref::DerefMut
pub fn image::SubImage<I>::deref_mut(&mut self) -> &mut Self::Target
impl<I> core::marker::Freeze for image::SubImage<I> where I: core::marker::Freeze
impl<I> core::marker::Send for image::SubImage<I> where I: core::marker::Send
impl<I> core::marker::Sync for image::SubImage<I> where I: core::marker::Sync
impl<I> core::marker::Unpin for image::SubImage<I> where I: core::marker::Unpin
impl<I> core::panic::unwind_safe::RefUnwindSafe for image::SubImage<I> where I: core::panic::unwind_safe::RefUnwindSafe
impl<I> core::panic::unwind_safe::UnwindSafe for image::SubImage<I> where I: core::panic::unwind_safe::UnwindSafe
impl<P, T> core::ops::deref::Receiver for image::SubImage<I> where P: core::ops::deref::Deref<Target = T> + ?core::marker::Sized, T: ?core::marker::Sized
pub type image::SubImage<I>::Target = T
impl<T, U> core::convert::Into<U> for image::SubImage<I> where U: core::convert::From<T>
pub fn image::SubImage<I>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for image::SubImage<I> where U: core::convert::Into<T>
pub type image::SubImage<I>::Error = core::convert::Infallible
pub fn image::SubImage<I>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for image::SubImage<I> where U: core::convert::TryFrom<T>
pub type image::SubImage<I>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn image::SubImage<I>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for image::SubImage<I> where T: core::clone::Clone
pub type image::SubImage<I>::Owned = T
pub fn image::SubImage<I>::clone_into(&self, target: &mut T)
pub fn image::SubImage<I>::to_owned(&self) -> T
impl<T> core::any::Any for image::SubImage<I> where T: 'static + ?core::marker::Sized
pub fn image::SubImage<I>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for image::SubImage<I> where T: ?core::marker::Sized
pub fn image::SubImage<I>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for image::SubImage<I> where T: ?core::marker::Sized
pub fn image::SubImage<I>::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for image::SubImage<I> where T: core::clone::Clone
pub unsafe fn image::SubImage<I>::clone_to_uninit(&self, dest: *mut u8)
impl<T> core::convert::From<T> for image::SubImage<I>
pub fn image::SubImage<I>::from(t: T) -> T
impl<T> crossbeam_epoch::atomic::Pointable for image::SubImage<I>
pub type image::SubImage<I>::Init = T
pub const image::SubImage<I>::ALIGN: usize
pub unsafe fn image::SubImage<I>::deref<'a>(ptr: usize) -> &'a T
pub unsafe fn image::SubImage<I>::deref_mut<'a>(ptr: usize) -> &'a mut T
pub unsafe fn image::SubImage<I>::drop(ptr: usize)
pub unsafe fn image::SubImage<I>::init(init: <T as crossbeam_epoch::atomic::Pointable>::Init) -> usize
impl<T> either::into_either::IntoEither for image::SubImage<I>
pub trait image::AnimationDecoder<'a>
pub fn image::AnimationDecoder::into_frames(self) -> image::Frames<'a>
impl<'a, R: 'a + std::io::BufRead + std::io::Seek> image::AnimationDecoder<'a> for image::codecs::webp::WebPDecoder<R>
pub fn image::codecs::webp::WebPDecoder<R>::into_frames(self) -> image::Frames<'a>
impl<'a, R: std::io::BufRead + std::io::Seek + 'a> image::AnimationDecoder<'a> for image::codecs::gif::GifDecoder<R>
pub fn image::codecs::gif::GifDecoder<R>::into_frames(self) -> image::Frames<'a>
impl<'a, R: std::io::BufRead + std::io::Seek + 'a> image::AnimationDecoder<'a> for image::codecs::png::ApngDecoder<R>
pub fn image::codecs::png::ApngDecoder<R>::into_frames(self) -> image::Frames<'a>
pub trait image::EncodableLayout: image::traits::seals::EncodableLayout
pub fn image::EncodableLayout::as_bytes(&self) -> &[u8]
impl image::EncodableLayout for [f32]
pub fn [f32]::as_bytes(&self) -> &[u8]
impl image::EncodableLayout for [u16]
pub fn [u16]::as_bytes(&self) -> &[u8]
impl image::EncodableLayout for [u8]
pub fn [u8]::as_bytes(&self) -> &[u8]
pub trait image::GenericImage: image::GenericImageView
pub fn image::GenericImage::blend_pixel(&mut self, x: u32, y: u32, pixel: Self::Pixel)
pub fn image::GenericImage::copy_from<O>(&mut self, other: &O, x: u32, y: u32) -> image::error::ImageResult<()> where O: image::GenericImageView<Pixel = Self::Pixel>
pub fn image::GenericImage::copy_within(&mut self, source: image::math::Rect, x: u32, y: u32) -> bool
pub fn image::GenericImage::get_pixel_mut(&mut self, x: u32, y: u32) -> &mut Self::Pixel
pub fn image::GenericImage::put_pixel(&mut self, x: u32, y: u32, pixel: Self::Pixel)
pub fn image::GenericImage::sub_image(&mut self, x: u32, y: u32, width: u32, height: u32) -> image::SubImage<&mut Self> where Self: core::marker::Sized
pub unsafe fn image::GenericImage::unsafe_put_pixel(&mut self, x: u32, y: u32, pixel: Self::Pixel)
impl image::GenericImage for image::DynamicImage
pub fn image::DynamicImage::blend_pixel(&mut self, x: u32, y: u32, pixel: image::Rgba<u8>)
pub fn image::DynamicImage::get_pixel_mut(&mut self, _: u32, _: u32) -> &mut image::Rgba<u8>
pub fn image::DynamicImage::put_pixel(&mut self, x: u32, y: u32, pixel: image::Rgba<u8>)
impl<Buffer, P: image::Pixel> image::GenericImage for image::flat::ViewMut<Buffer, P> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]> + core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub fn image::flat::ViewMut<Buffer, P>::blend_pixel(&mut self, x: u32, y: u32, pixel: Self::Pixel)
pub fn image::flat::ViewMut<Buffer, P>::get_pixel_mut(&mut self, x: u32, y: u32) -> &mut Self::Pixel
pub fn image::flat::ViewMut<Buffer, P>::put_pixel(&mut self, x: u32, y: u32, pixel: Self::Pixel)
impl<P, Container> image::GenericImage for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]> + core::ops::deref::DerefMut
pub fn image::ImageBuffer<P, Container>::blend_pixel(&mut self, x: u32, y: u32, p: P)
pub fn image::ImageBuffer<P, Container>::copy_within(&mut self, source: image::math::Rect, x: u32, y: u32) -> bool
pub fn image::ImageBuffer<P, Container>::get_pixel_mut(&mut self, x: u32, y: u32) -> &mut P
pub fn image::ImageBuffer<P, Container>::put_pixel(&mut self, x: u32, y: u32, pixel: P)
pub unsafe fn image::ImageBuffer<P, Container>::unsafe_put_pixel(&mut self, x: u32, y: u32, pixel: P)
pub trait image::GenericImageView
pub type image::GenericImageView::Pixel: image::Pixel
pub fn image::GenericImageView::dimensions(&self) -> (u32, u32)
pub fn image::GenericImageView::get_pixel(&self, x: u32, y: u32) -> Self::Pixel
pub fn image::GenericImageView::height(&self) -> u32
pub fn image::GenericImageView::in_bounds(&self, x: u32, y: u32) -> bool
pub fn image::GenericImageView::pixels(&self) -> image::Pixels<'_, Self> where Self: core::marker::Sized
pub unsafe fn image::GenericImageView::unsafe_get_pixel(&self, x: u32, y: u32) -> Self::Pixel
pub fn image::GenericImageView::view(&self, x: u32, y: u32, width: u32, height: u32) -> image::SubImage<&Self> where Self: core::marker::Sized
pub fn image::GenericImageView::width(&self) -> u32
impl image::GenericImageView for image::DynamicImage
pub type image::DynamicImage::Pixel = image::Rgba<u8>
pub fn image::DynamicImage::dimensions(&self) -> (u32, u32)
pub fn image::DynamicImage::get_pixel(&self, x: u32, y: u32) -> image::Rgba<u8>
impl<Buffer, P: image::Pixel> image::GenericImageView for image::flat::View<Buffer, P> where Buffer: core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub type image::flat::View<Buffer, P>::Pixel = P
pub fn image::flat::View<Buffer, P>::dimensions(&self) -> (u32, u32)
pub fn image::flat::View<Buffer, P>::get_pixel(&self, x: u32, y: u32) -> Self::Pixel
impl<Buffer, P: image::Pixel> image::GenericImageView for image::flat::ViewMut<Buffer, P> where Buffer: core::convert::AsMut<[<P as image::Pixel>::Subpixel]> + core::convert::AsRef<[<P as image::Pixel>::Subpixel]>
pub type image::flat::ViewMut<Buffer, P>::Pixel = P
pub fn image::flat::ViewMut<Buffer, P>::dimensions(&self) -> (u32, u32)
pub fn image::flat::ViewMut<Buffer, P>::get_pixel(&self, x: u32, y: u32) -> Self::Pixel
impl<P, Container> image::GenericImageView for image::ImageBuffer<P, Container> where P: image::Pixel, Container: core::ops::deref::Deref<Target = [<P as image::Pixel>::Subpixel]> + core::ops::deref::Deref
pub type image::ImageBuffer<P, Container>::Pixel = P
pub fn image::ImageBuffer<P, Container>::dimensions(&self) -> (u32, u32)
pub fn image::ImageBuffer<P, Container>::get_pixel(&self, x: u32, y: u32) -> P
pub unsafe fn image::ImageBuffer<P, Container>::unsafe_get_pixel(&self, x: u32, y: u32) -> P
pub trait image::ImageDecoder
pub fn image::ImageDecoder::color_type(&self) -> image::ColorType
pub fn image::ImageDecoder::dimensions(&self) -> (u32, u32)
pub fn image::ImageDecoder::exif_metadata(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::ImageDecoder::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::ImageDecoder::orientation(&mut self) -> image::error::ImageResult<image::metadata::Orientation>
pub fn image::ImageDecoder::original_color_type(&self) -> image::ExtendedColorType
pub fn image::ImageDecoder::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()> where Self: core::marker::Sized
pub fn image::ImageDecoder::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::ImageDecoder::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
pub fn image::ImageDecoder::total_bytes(&self) -> u64
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::bmp::BmpDecoder<R>
pub fn image::codecs::bmp::BmpDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::bmp::BmpDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::bmp::BmpDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::bmp::BmpDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::gif::GifDecoder<R>
pub fn image::codecs::gif::GifDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::gif::GifDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::gif::GifDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::gif::GifDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::gif::GifDecoder<R>::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::ico::IcoDecoder<R>
pub fn image::codecs::ico::IcoDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::ico::IcoDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::ico::IcoDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::ico::IcoDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::jpeg::JpegDecoder<R>
pub fn image::codecs::jpeg::JpegDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::jpeg::JpegDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::jpeg::JpegDecoder<R>::exif_metadata(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::jpeg::JpegDecoder<R>::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::jpeg::JpegDecoder<R>::orientation(&mut self) -> image::error::ImageResult<image::metadata::Orientation>
pub fn image::codecs::jpeg::JpegDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::jpeg::JpegDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::jpeg::JpegDecoder<R>::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::openexr::OpenExrDecoder<R>
pub fn image::codecs::openexr::OpenExrDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::openexr::OpenExrDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::openexr::OpenExrDecoder<R>::original_color_type(&self) -> image::ExtendedColorType
pub fn image::codecs::openexr::OpenExrDecoder<R>::read_image(self, unaligned_bytes: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::openexr::OpenExrDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::png::PngDecoder<R>
pub fn image::codecs::png::PngDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::png::PngDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::png::PngDecoder<R>::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::png::PngDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::png::PngDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::png::PngDecoder<R>::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::tiff::TiffDecoder<R>
pub fn image::codecs::tiff::TiffDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::tiff::TiffDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::tiff::TiffDecoder<R>::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::tiff::TiffDecoder<R>::orientation(&mut self) -> image::error::ImageResult<image::metadata::Orientation>
pub fn image::codecs::tiff::TiffDecoder<R>::original_color_type(&self) -> image::ExtendedColorType
pub fn image::codecs::tiff::TiffDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::tiff::TiffDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::tiff::TiffDecoder<R>::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoder for image::codecs::webp::WebPDecoder<R>
pub fn image::codecs::webp::WebPDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::webp::WebPDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::webp::WebPDecoder<R>::exif_metadata(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::webp::WebPDecoder<R>::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn image::codecs::webp::WebPDecoder<R>::orientation(&mut self) -> image::error::ImageResult<image::metadata::Orientation>
pub fn image::codecs::webp::WebPDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::webp::WebPDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::dds::DdsDecoder<R>
pub fn image::codecs::dds::DdsDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::dds::DdsDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::dds::DdsDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::dds::DdsDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::farbfeld::FarbfeldDecoder<R>
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::hdr::HdrDecoder<R>
pub fn image::codecs::hdr::HdrDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::hdr::HdrDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::hdr::HdrDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::hdr::HdrDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::pnm::PnmDecoder<R>
pub fn image::codecs::pnm::PnmDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::pnm::PnmDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::pnm::PnmDecoder<R>::original_color_type(&self) -> image::ExtendedColorType
pub fn image::codecs::pnm::PnmDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::pnm::PnmDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::qoi::QoiDecoder<R>
pub fn image::codecs::qoi::QoiDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::qoi::QoiDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::qoi::QoiDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::qoi::QoiDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<R: std::io::Read> image::ImageDecoder for image::codecs::tga::TgaDecoder<R>
pub fn image::codecs::tga::TgaDecoder<R>::color_type(&self) -> image::ColorType
pub fn image::codecs::tga::TgaDecoder<R>::dimensions(&self) -> (u32, u32)
pub fn image::codecs::tga::TgaDecoder<R>::original_color_type(&self) -> image::ExtendedColorType
pub fn image::codecs::tga::TgaDecoder<R>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn image::codecs::tga::TgaDecoder<R>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
impl<T: ?core::marker::Sized + image::ImageDecoder> image::ImageDecoder for alloc::boxed::Box<T>
pub fn alloc::boxed::Box<T>::color_type(&self) -> image::ColorType
pub fn alloc::boxed::Box<T>::dimensions(&self) -> (u32, u32)
pub fn alloc::boxed::Box<T>::exif_metadata(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn alloc::boxed::Box<T>::icc_profile(&mut self) -> image::error::ImageResult<core::option::Option<alloc::vec::Vec<u8>>>
pub fn alloc::boxed::Box<T>::original_color_type(&self) -> image::ExtendedColorType
pub fn alloc::boxed::Box<T>::read_image(self, buf: &mut [u8]) -> image::error::ImageResult<()> where Self: core::marker::Sized
pub fn alloc::boxed::Box<T>::read_image_boxed(self: alloc::boxed::Box<Self>, buf: &mut [u8]) -> image::error::ImageResult<()>
pub fn alloc::boxed::Box<T>::set_limits(&mut self, limits: image::Limits) -> image::error::ImageResult<()>
pub fn alloc::boxed::Box<T>::total_bytes(&self) -> u64
pub trait image::ImageDecoderRect: image::ImageDecoder
pub fn image::ImageDecoderRect::read_rect(&mut self, x: u32, y: u32, width: u32, height: u32, buf: &mut [u8], row_pitch: usize) -> image::error::ImageResult<()>
impl<R: std::io::BufRead + std::io::Seek> image::ImageDecoderRect for image::codecs::bmp::BmpDecoder<R>
pub fn image::codecs::bmp::BmpDecoder<R>::read_rect(&mut self, x: u32, y: u32, width: u32, height: u32, buf: &mut [u8], row_pitch: usize) -> image::error::ImageResult<()>
impl<R: std::io::Read + std::io::Seek> image::ImageDecoderRect for image::codecs::farbfeld::FarbfeldDecoder<R>
pub fn image::codecs::farbfeld::FarbfeldDecoder<R>::read_rect(&mut self, x: u32, y: u32, width: u32, height: u32, buf: &mut [u8], row_pitch: usize) -> image::error::ImageResult<()>
pub trait image::ImageEncoder
pub fn image::ImageEncoder::set_icc_profile(&mut self, icc_profile: alloc::vec::Vec<u8>) -> core::result::Result<(), image::error::UnsupportedError>
pub fn image::ImageEncoder::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write + std::io::Seek> image::ImageEncoder for image::codecs::tiff::TiffEncoder<W>
pub fn image::codecs::tiff::TiffEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::avif::AvifEncoder<W>
pub fn image::codecs::avif::AvifEncoder<W>::write_image(self, data: &[u8], width: u32, height: u32, color: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::bmp::BmpEncoder<'_, W>
pub fn image::codecs::bmp::BmpEncoder<'_, W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::farbfeld::FarbfeldEncoder<W>
pub fn image::codecs::farbfeld::FarbfeldEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::hdr::HdrEncoder<W>
pub fn image::codecs::hdr::HdrEncoder<W>::write_image(self, unaligned_bytes: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::ico::IcoEncoder<W>
pub fn image::codecs::ico::IcoEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::jpeg::JpegEncoder<W>
pub fn image::codecs::jpeg::JpegEncoder<W>::set_icc_profile(&mut self, icc_profile: alloc::vec::Vec<u8>) -> core::result::Result<(), image::error::UnsupportedError>
pub fn image::codecs::jpeg::JpegEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::png::PngEncoder<W>
pub fn image::codecs::png::PngEncoder<W>::set_icc_profile(&mut self, icc_profile: alloc::vec::Vec<u8>) -> core::result::Result<(), image::error::UnsupportedError>
pub fn image::codecs::png::PngEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::pnm::PnmEncoder<W>
pub fn image::codecs::pnm::PnmEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::qoi::QoiEncoder<W>
pub fn image::codecs::qoi::QoiEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::tga::TgaEncoder<W>
pub fn image::codecs::tga::TgaEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W: std::io::Write> image::ImageEncoder for image::codecs::webp::WebPEncoder<W>
pub fn image::codecs::webp::WebPEncoder<W>::set_icc_profile(&mut self, icc_profile: alloc::vec::Vec<u8>) -> core::result::Result<(), image::error::UnsupportedError>
pub fn image::codecs::webp::WebPEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
impl<W> image::ImageEncoder for image::codecs::openexr::OpenExrEncoder<W> where W: std::io::Write + std::io::Seek
pub fn image::codecs::openexr::OpenExrEncoder<W>::write_image(self, buf: &[u8], width: u32, height: u32, color_type: image::ExtendedColorType) -> image::error::ImageResult<()>
pub trait image::Pixel: core::marker::Copy + core::clone::Clone
pub type image::Pixel::Subpixel: image::Primitive
pub const image::Pixel::CHANNEL_COUNT: u8
pub const image::Pixel::COLOR_MODEL: &'static str
pub fn image::Pixel::apply<F>(&mut self, f: F) where F: core::ops::function::FnMut(Self::Subpixel) -> Self::Subpixel
pub fn image::Pixel::apply2<F>(&mut self, other: &Self, f: F) where F: core::ops::function::FnMut(Self::Subpixel, Self::Subpixel) -> Self::Subpixel
pub fn image::Pixel::apply_with_alpha<F, G>(&mut self, f: F, g: G) where F: core::ops::function::FnMut(Self::Subpixel) -> Self::Subpixel, G: core::ops::function::FnMut(Self::Subpixel) -> Self::Subpixel
pub fn image::Pixel::apply_without_alpha<F>(&mut self, f: F) where F: core::ops::function::FnMut(Self::Subpixel) -> Self::Subpixel
pub fn image::Pixel::blend(&mut self, other: &Self)
pub fn image::Pixel::channels(&self) -> &[Self::Subpixel]
pub fn image::Pixel::channels4(&self) -> (Self::Subpixel, Self::Subpixel, Self::Subpixel, Self::Subpixel)
pub fn image::Pixel::channels_mut(&mut self) -> &mut [Self::Subpixel]
pub fn image::Pixel::from_channels(a: Self::Subpixel, b: Self::Subpixel, c: Self::Subpixel, d: Self::Subpixel) -> Self
pub fn image::Pixel::from_slice(slice: &[Self::Subpixel]) -> &Self
pub fn image::Pixel::from_slice_mut(slice: &mut [Self::Subpixel]) -> &mut Self
pub fn image::Pixel::invert(&mut self)
pub fn image::Pixel::map<F>(&self, f: F) -> Self where F: core::ops::function::FnMut(Self::Subpixel) -> Self::Subpixel
pub fn image::Pixel::map2<F>(&self, other: &Self, f: F) -> Self where F: core::ops::function::FnMut(Self::Subpixel, Self::Subpixel) -> Self::Subpixel
pub fn image::Pixel::map_with_alpha<F, G>(&self, f: F, g: G) -> Self where F: core::ops::function::FnMut(Self::Subpixel) -> Self::Subpixel, G: core::ops::function::FnMut(Self::Subpixel) -> Self::Subpixel
pub fn image::Pixel::map_without_alpha<F>(&self, f: F) -> Self where F: core::ops::function::FnMut(Self::Subpixel) -> Self::Subpixel
pub fn image::Pixel::to_luma(&self) -> image::Luma<Self::Subpixel>
pub fn image::Pixel::to_luma_alpha(&self) -> image::LumaA<Self::Subpixel>
pub fn image::Pixel::to_rgb(&self) -> image::Rgb<Self::Subpixel>
pub fn image::Pixel::to_rgba(&self) -> image::Rgba<Self::Subpixel>
impl<T: image::Primitive + image::traits::Enlargeable> image::Pixel for image::Rgb<T>
pub type image::Rgb<T>::Subpixel = T
pub const image::Rgb<T>::CHANNEL_COUNT: u8
pub const image::Rgb<T>::COLOR_MODEL: &'static str
pub fn image::Rgb<T>::apply<F>(&mut self, f: F) where F: core::ops::function::FnMut(T) -> T
pub fn image::Rgb<T>::apply2<F>(&mut self, other: &image::Rgb<T>, f: F) where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Rgb<T>::apply_with_alpha<F, G>(&mut self, f: F, g: G) where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Rgb<T>::blend(&mut self, other: &image::Rgb<T>)
pub fn image::Rgb<T>::channels(&self) -> &[T]
pub fn image::Rgb<T>::channels4(&self) -> (T, T, T, T)
pub fn image::Rgb<T>::channels_mut(&mut self) -> &mut [T]
pub fn image::Rgb<T>::from_channels(a: T, b: T, c: T, d: T) -> image::Rgb<T>
pub fn image::Rgb<T>::from_slice(slice: &[T]) -> &image::Rgb<T>
pub fn image::Rgb<T>::from_slice_mut(slice: &mut [T]) -> &mut image::Rgb<T>
pub fn image::Rgb<T>::invert(&mut self)
pub fn image::Rgb<T>::map<F>(&self, f: F) -> image::Rgb<T> where F: core::ops::function::FnMut(T) -> T
pub fn image::Rgb<T>::map2<F>(&self, other: &Self, f: F) -> image::Rgb<T> where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Rgb<T>::map_with_alpha<F, G>(&self, f: F, g: G) -> image::Rgb<T> where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Rgb<T>::to_luma(&self) -> image::Luma<T>
pub fn image::Rgb<T>::to_luma_alpha(&self) -> image::LumaA<T>
pub fn image::Rgb<T>::to_rgb(&self) -> image::Rgb<T>
pub fn image::Rgb<T>::to_rgba(&self) -> image::Rgba<T>
impl<T: image::Primitive + image::traits::Enlargeable> image::Pixel for image::Rgba<T>
pub type image::Rgba<T>::Subpixel = T
pub const image::Rgba<T>::CHANNEL_COUNT: u8
pub const image::Rgba<T>::COLOR_MODEL: &'static str
pub fn image::Rgba<T>::apply<F>(&mut self, f: F) where F: core::ops::function::FnMut(T) -> T
pub fn image::Rgba<T>::apply2<F>(&mut self, other: &image::Rgba<T>, f: F) where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Rgba<T>::apply_with_alpha<F, G>(&mut self, f: F, g: G) where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Rgba<T>::blend(&mut self, other: &image::Rgba<T>)
pub fn image::Rgba<T>::channels(&self) -> &[T]
pub fn image::Rgba<T>::channels4(&self) -> (T, T, T, T)
pub fn image::Rgba<T>::channels_mut(&mut self) -> &mut [T]
pub fn image::Rgba<T>::from_channels(a: T, b: T, c: T, d: T) -> image::Rgba<T>
pub fn image::Rgba<T>::from_slice(slice: &[T]) -> &image::Rgba<T>
pub fn image::Rgba<T>::from_slice_mut(slice: &mut [T]) -> &mut image::Rgba<T>
pub fn image::Rgba<T>::invert(&mut self)
pub fn image::Rgba<T>::map<F>(&self, f: F) -> image::Rgba<T> where F: core::ops::function::FnMut(T) -> T
pub fn image::Rgba<T>::map2<F>(&self, other: &Self, f: F) -> image::Rgba<T> where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Rgba<T>::map_with_alpha<F, G>(&self, f: F, g: G) -> image::Rgba<T> where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Rgba<T>::to_luma(&self) -> image::Luma<T>
pub fn image::Rgba<T>::to_luma_alpha(&self) -> image::LumaA<T>
pub fn image::Rgba<T>::to_rgb(&self) -> image::Rgb<T>
pub fn image::Rgba<T>::to_rgba(&self) -> image::Rgba<T>
impl<T: image::Primitive> image::Pixel for image::Luma<T>
pub type image::Luma<T>::Subpixel = T
pub const image::Luma<T>::CHANNEL_COUNT: u8
pub const image::Luma<T>::COLOR_MODEL: &'static str
pub fn image::Luma<T>::apply<F>(&mut self, f: F) where F: core::ops::function::FnMut(T) -> T
pub fn image::Luma<T>::apply2<F>(&mut self, other: &image::Luma<T>, f: F) where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Luma<T>::apply_with_alpha<F, G>(&mut self, f: F, g: G) where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Luma<T>::blend(&mut self, other: &image::Luma<T>)
pub fn image::Luma<T>::channels(&self) -> &[T]
pub fn image::Luma<T>::channels4(&self) -> (T, T, T, T)
pub fn image::Luma<T>::channels_mut(&mut self) -> &mut [T]
pub fn image::Luma<T>::from_channels(a: T, b: T, c: T, d: T) -> image::Luma<T>
pub fn image::Luma<T>::from_slice(slice: &[T]) -> &image::Luma<T>
pub fn image::Luma<T>::from_slice_mut(slice: &mut [T]) -> &mut image::Luma<T>
pub fn image::Luma<T>::invert(&mut self)
pub fn image::Luma<T>::map<F>(&self, f: F) -> image::Luma<T> where F: core::ops::function::FnMut(T) -> T
pub fn image::Luma<T>::map2<F>(&self, other: &Self, f: F) -> image::Luma<T> where F: core::ops::function::FnMut(T, T) -> T
pub fn image::Luma<T>::map_with_alpha<F, G>(&self, f: F, g: G) -> image::Luma<T> where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::Luma<T>::to_luma(&self) -> image::Luma<T>
pub fn image::Luma<T>::to_luma_alpha(&self) -> image::LumaA<T>
pub fn image::Luma<T>::to_rgb(&self) -> image::Rgb<T>
pub fn image::Luma<T>::to_rgba(&self) -> image::Rgba<T>
impl<T: image::Primitive> image::Pixel for image::LumaA<T>
pub type image::LumaA<T>::Subpixel = T
pub const image::LumaA<T>::CHANNEL_COUNT: u8
pub const image::LumaA<T>::COLOR_MODEL: &'static str
pub fn image::LumaA<T>::apply<F>(&mut self, f: F) where F: core::ops::function::FnMut(T) -> T
pub fn image::LumaA<T>::apply2<F>(&mut self, other: &image::LumaA<T>, f: F) where F: core::ops::function::FnMut(T, T) -> T
pub fn image::LumaA<T>::apply_with_alpha<F, G>(&mut self, f: F, g: G) where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::LumaA<T>::blend(&mut self, other: &image::LumaA<T>)
pub fn image::LumaA<T>::channels(&self) -> &[T]
pub fn image::LumaA<T>::channels4(&self) -> (T, T, T, T)
pub fn image::LumaA<T>::channels_mut(&mut self) -> &mut [T]
pub fn image::LumaA<T>::from_channels(a: T, b: T, c: T, d: T) -> image::LumaA<T>
pub fn image::LumaA<T>::from_slice(slice: &[T]) -> &image::LumaA<T>
pub fn image::LumaA<T>::from_slice_mut(slice: &mut [T]) -> &mut image::LumaA<T>
pub fn image::LumaA<T>::invert(&mut self)
pub fn image::LumaA<T>::map<F>(&self, f: F) -> image::LumaA<T> where F: core::ops::function::FnMut(T) -> T
pub fn image::LumaA<T>::map2<F>(&self, other: &Self, f: F) -> image::LumaA<T> where F: core::ops::function::FnMut(T, T) -> T
pub fn image::LumaA<T>::map_with_alpha<F, G>(&self, f: F, g: G) -> image::LumaA<T> where F: core::ops::function::FnMut(T) -> T, G: core::ops::function::FnMut(T) -> T
pub fn image::LumaA<T>::to_luma(&self) -> image::Luma<T>
pub fn image::LumaA<T>::to_luma_alpha(&self) -> image::LumaA<T>
pub fn image::LumaA<T>::to_rgb(&self) -> image::Rgb<T>
pub fn image::LumaA<T>::to_rgba(&self) -> image::Rgba<T>
pub trait image::PixelWithColorType: image::Pixel + image::traits::private::SealedPixelWithColorType
pub const image::PixelWithColorType::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Luma<u16>
pub const image::Luma<u16>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Luma<u8>
pub const image::Luma<u8>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::LumaA<u16>
pub const image::LumaA<u16>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::LumaA<u8>
pub const image::LumaA<u8>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgb<f32>
pub const image::Rgb<f32>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgb<u16>
pub const image::Rgb<u16>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgb<u8>
pub const image::Rgb<u8>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgba<f32>
pub const image::Rgba<f32>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgba<u16>
pub const image::Rgba<u16>::COLOR_TYPE: image::ExtendedColorType
impl image::PixelWithColorType for image::Rgba<u8>
pub const image::Rgba<u8>::COLOR_TYPE: image::ExtendedColorType
pub trait image::Primitive: core::marker::Copy + num_traits::cast::NumCast + num_traits::Num + core::cmp::PartialOrd<Self> + core::clone::Clone + num_traits::bounds::Bounded
pub const image::Primitive::DEFAULT_MAX_VALUE: Self
pub const image::Primitive::DEFAULT_MIN_VALUE: Self
impl image::Primitive for f32
pub const f32::DEFAULT_MAX_VALUE: Self
pub const f32::DEFAULT_MIN_VALUE: Self
impl image::Primitive for f64
pub const f64::DEFAULT_MAX_VALUE: Self
pub const f64::DEFAULT_MIN_VALUE: Self
impl image::Primitive for i16
pub const i16::DEFAULT_MAX_VALUE: Self
pub const i16::DEFAULT_MIN_VALUE: Self
impl image::Primitive for i32
pub const i32::DEFAULT_MAX_VALUE: Self
pub const i32::DEFAULT_MIN_VALUE: Self
impl image::Primitive for i64
pub const i64::DEFAULT_MAX_VALUE: Self
pub const i64::DEFAULT_MIN_VALUE: Self
impl image::Primitive for i8
pub const i8::DEFAULT_MAX_VALUE: Self
pub const i8::DEFAULT_MIN_VALUE: Self
impl image::Primitive for isize
pub const isize::DEFAULT_MAX_VALUE: Self
pub const isize::DEFAULT_MIN_VALUE: Self
impl image::Primitive for u16
pub const u16::DEFAULT_MAX_VALUE: Self
pub const u16::DEFAULT_MIN_VALUE: Self
impl image::Primitive for u32
pub const u32::DEFAULT_MAX_VALUE: Self
pub const u32::DEFAULT_MIN_VALUE: Self
impl image::Primitive for u64
pub const u64::DEFAULT_MAX_VALUE: Self
pub const u64::DEFAULT_MIN_VALUE: Self
impl image::Primitive for u8
pub const u8::DEFAULT_MAX_VALUE: Self
pub const u8::DEFAULT_MIN_VALUE: Self
impl image::Primitive for usize
pub const usize::DEFAULT_MAX_VALUE: Self
pub const usize::DEFAULT_MIN_VALUE: Self
pub fn image::guess_format(buffer: &[u8]) -> image::error::ImageResult<image::ImageFormat>
pub fn image::image_dimensions<P>(path: P) -> image::error::ImageResult<(u32, u32)> where P: core::convert::AsRef<std::path::Path>
pub fn image::load<R: std::io::BufRead + std::io::Seek>(r: R, format: image::ImageFormat) -> image::error::ImageResult<image::DynamicImage>
pub fn image::load_from_memory(buffer: &[u8]) -> image::error::ImageResult<image::DynamicImage>
pub fn image::load_from_memory_with_format(buf: &[u8], format: image::ImageFormat) -> image::error::ImageResult<image::DynamicImage>
pub fn image::open<P>(path: P) -> image::error::ImageResult<image::DynamicImage> where P: core::convert::AsRef<std::path::Path>
pub fn image::save_buffer(path: impl core::convert::AsRef<std::path::Path>, buf: &[u8], width: u32, height: u32, color: impl core::convert::Into<image::ExtendedColorType>) -> image::error::ImageResult<()>
pub fn image::save_buffer_with_format(path: impl core::convert::AsRef<std::path::Path>, buf: &[u8], width: u32, height: u32, color: impl core::convert::Into<image::ExtendedColorType>, format: image::ImageFormat) -> image::error::ImageResult<()>
pub fn image::write_buffer_with_format<W: std::io::Write + std::io::Seek>(buffered_writer: &mut W, buf: &[u8], width: u32, height: u32, color: impl core::convert::Into<image::ExtendedColorType>, format: image::ImageFormat) -> image::error::ImageResult<()>
pub type image::GrayAlphaImage = image::ImageBuffer<image::LumaA<u8>, alloc::vec::Vec<u8>>
pub type image::GrayImage = image::ImageBuffer<image::Luma<u8>, alloc::vec::Vec<u8>>
pub type image::ImageResult<T> = core::result::Result<T, image::error::ImageError>
pub type image::Rgb32FImage = image::ImageBuffer<image::Rgb<f32>, alloc::vec::Vec<f32>>
pub type image::RgbImage = image::ImageBuffer<image::Rgb<u8>, alloc::vec::Vec<u8>>
pub type image::Rgba32FImage = image::ImageBuffer<image::Rgba<f32>, alloc::vec::Vec<f32>>
pub type image::RgbaImage = image::ImageBuffer<image::Rgba<u8>, alloc::vec::Vec<u8>>
