#!/bin/bash

# --- Configuration ---
# List of input image source patterns.
# Each entry is "<subfolder_name> <path_pattern_relative_to_script>"
SOURCE_PATTERNS=(
    "jxl/chessboard ../testdata/jxl/chessboard/*.png"
    "jxl/blending ../testdata/jxl/blending/*.png"
    "external/raw.pixls ../testdata/external/raw.pixls/*.png"
    "external/wesaturate/64px ../testdata/external/wesaturate/64px/*.png"
    "external/wesaturate/500px ../testdata/external/wesaturate/500px/*.png"
    "external/wide-gamut-tests ../testdata/external/wide-gamut-tests/*.png"
)
REFERENCE_IMAGE_DIR="src/tests/reference_images"
RUST_TEST_FILE="src/tests/reference_data.rs"

# Encoding parameters to use for generating reference data
CJPEGLI_DISTANCE=1.0
# Or use quality:
# CJPEGLI_QUALITY=90
DOCKER_IMAGE="imazen/jpeg-tools:main"
# --- End Configuration ---

set -e # Exit on errors

# --- Helper Function to Find/Call cjpegli ---
# Sets CJPEGLI_CMD variable to the command needed to run cjpegli
find_and_set_cjpegli_cmd() {
    echo "Searching for cjpegli..."
    if command -v cjpegli >/dev/null 2>&1; then
        echo "Found cjpegli in PATH."
        CJPEGLI_CMD="cjpegli"
    elif [ -x "../tools/cjpegli" ]; then
        echo "Found cjpegli in ../tools/."
        # Use absolute path to avoid issues if script changes directory later
        local script_dir
        script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
        CJPEGLI_CMD="$script_dir/../tools/cjpegli"
    else
        echo "cjpegli not found locally. Checking for Docker..."
        if command -v docker >/dev/null 2>&1; then
            echo "Found Docker. Will attempt to use '$DOCKER_IMAGE'."
            # Map current directory for input/output
            # Use --user to avoid creating files as root
            CJPEGLI_CMD="docker run --rm -u $(id -u):$(id -g) -v $(pwd):/work -w /work $DOCKER_IMAGE cjpegli"
            # Optional: Check if image exists, pull if needed
            # if ! docker image inspect "$DOCKER_IMAGE" &> /dev/null; then
            #    echo "Pulling docker image $DOCKER_IMAGE..."
            #    docker pull "$DOCKER_IMAGE"
            # fi
        else
            echo "Error: cjpegli not found in PATH, ../tools/, and Docker is not available."
            exit 1
        fi
    fi
    echo "Using command: $CJPEGLI_CMD"
}

# --- 1. Check Prerequisites (Python only now) ---
echo "Checking prerequisites..."
MISSING_TOOLS=""
command -v python3 >/dev/null 2>&1 || MISSING_TOOLS+="python3 "

if [ ! -z "$MISSING_TOOLS" ]; then
    echo "The following tools are missing: $MISSING_TOOLS"
    read -p "Attempt to install them using apt? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        sudo apt-get update && sudo apt-get install -y python3
    else
        echo "Please install the missing tools and run the script again."
        exit 1
    fi
fi
echo "Prerequisites met."

# --- 2. Set cjpegli Command ---
find_and_set_cjpegli_cmd # Sets the global CJPEGLI_CMD variable

# --- 3. Setup Directories and Output File ---
echo "Setting up directories and output file..."
mkdir -p "$REFERENCE_IMAGE_DIR"

# Write Rust file header
cat << 'EOF' > "$RUST_TEST_FILE"
// Generated by dct.sh and extract_dqt.py. DO NOT EDIT.

#[cfg(test)]
mod tests {
    // Assuming quantization tables are needed for comparison
    // use crate::quantization::QuantizationTable;

    #[derive(Debug)]
    pub struct ReferenceQuantTestData {
        pub source_group: &'static str,
        pub input_filename: &'static str,
        pub input_format: &'static str, // Format of the *original* input
        pub input_data: &'static [u8],  // Bytes of the *copied* input file
        pub cjpegli_distance: f32,
        pub expected_luma_dqt: [u16; 64],
        pub expected_chroma_dqt: [u16; 64],
    }}

    pub const REFERENCE_QUANT_TEST_DATA: &[ReferenceQuantTestData] = &[
EOF
echo "Header written to $RUST_TEST_FILE"

# --- 4. Process Source Patterns ---
echo "Processing source image patterns..."
for pattern_entry in "${SOURCE_PATTERNS[@]}"; do
    # Split entry into subfolder name and path pattern
    read -r subfolder path_pattern <<<"$pattern_entry"

    echo "  Processing group '$subfolder' with pattern '$path_pattern'..."
    target_subfolder="$REFERENCE_IMAGE_DIR/$subfolder"
    mkdir -p "$target_subfolder"

    # Use find to handle potential lack of matches gracefully and avoid issues with spaces
    # Ensure we handle the case where the directory in the pattern might not exist
    pattern_dir=$(dirname "$path_pattern")
    pattern_base=$(basename "$path_pattern")
    if [ ! -d "$pattern_dir" ]; then
        echo "    Warning: Source directory not found: '$pattern_dir'. Skipping group '$subfolder'." >&2
        continue
    fi

    find "$pattern_dir" -maxdepth 1 -name "$pattern_base" -print0 | while IFS= read -r -d $'\0' img_path; do
        if [ ! -f "$img_path" ]; then
            # This check might be redundant with find -type f, but good practice
            echo "    Warning: Found path is not a file: '$img_path'. Skipping." >&2
            continue
        fi

        img_basename=$(basename "$img_path")
        img_extension="${img_basename##*.}"
        img_name_no_ext="${img_basename%.*}"

        # Use the determined subfolder for copy destination and relative path
        copied_img_path="$target_subfolder/$img_basename"
        # Path for include_bytes! relative from src/tests/reference_data.rs to src/tests/reference_images/
        relative_include_path="reference_images/$subfolder/$img_basename"

        # Define output JPEG filename (in the current directory, relative to script)
        output_jpeg_path="./${img_name_no_ext}_d${CJPEGLI_DISTANCE}.jpg"

        echo "    Processing '$img_path' -> '$output_jpeg_path'..."

        # Copy
        echo "      Copying to '$copied_img_path'..."
        cp "$img_path" "$copied_img_path"

        # Encode
        cjpegli_input_path="$copied_img_path" # Use copied path for encoding
        echo "      Encoding with cjpegli (distance $CJPEGLI_DISTANCE)..."
        eval $CJPEGLI_CMD --distance \"$CJPEGLI_DISTANCE\" \"$cjpegli_input_path\" \"$output_jpeg_path\"
        echo "      Encoding complete: '$output_jpeg_path'"

        # Extract DQT and generate Rust struct entry, passing the subfolder as source group
        echo "      Extracting DQT and generating Rust struct entry..."
        python3 ./extract_dqt.py "$output_jpeg_path" "$relative_include_path" "$CJPEGLI_DISTANCE" "$img_basename" "$img_extension" "$subfolder" >> "$RUST_TEST_FILE"
        echo "," >> "$RUST_TEST_FILE" # Add comma

        # Optional cleanup
        # rm -f "$output_jpeg_path"

        echo "    Finished processing '$img_path'."
    done || echo "    Note: No files found matching pattern '$path_pattern' in group '$subfolder'."

done
echo "Finished processing all patterns."

# --- 5. Create/Update DQT Extractor Script ---
echo "Creating/Updating DQT extractor script (extract_dqt.py)..."
cat << 'EOF' > extract_dqt.py
import sys
import struct
import os

# --- DQT Extraction Logic (from previous version, slightly modified error handling) ---
def extract_dqt(jpeg_path):
    tables = {}
    try:
        with open(jpeg_path, 'rb') as f:
            data = f.read()
    except FileNotFoundError:
        print(f"Error: File not found: {jpeg_path}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file: {e}", file=sys.stderr)
        sys.exit(1)

    pos = 0
    while pos < len(data):
        if data[pos:pos+2] == b'\xff\xd8': # SOI
            pos += 2
            continue
        if pos >= len(data) or data[pos] != 0xff:
            # Allow skipping non-marker bytes
            pos += 1
            continue

        marker = data[pos:pos+2]
        pos += 2

        if marker in [b'\xff\xd9', b'\xff\xd0', b'\xff\xd1', b'\xff\xd2', b'\xff\xd3', b'\xff\xd4', b'\xff\xd5', b'\xff\xd6', b'\xff\xd7', b'\xff\x01']: # EOI or standalone
            continue

        if pos + 2 > len(data):
            print(f"Error: Truncated JPEG file, missing length after marker {marker.hex()} at pos {pos-2}", file=sys.stderr)
            break
        length = struct.unpack('>H', data[pos:pos+2])[0]
        if length < 2:
            print(f"Error: Invalid segment length {length} for marker {marker.hex()} at pos {pos-2}", file=sys.stderr)
            # Try to skip marker code if length is wrong
            pos += 0 # Stay put to reread marker hopefully
            continue

        if pos + length > len(data):
            print(f"Error: Segment length {length} for marker {marker.hex()} exceeds file size at pos {pos-2}", file=sys.stderr)
            break # Prevent reading past end of data
        payload_pos = pos + 2
        segment_end = payload_pos + length - 2 # Position after the payload

        if marker == b'\xff\xdb': # DQT Marker
            current_pos_in_payload = payload_pos
            while current_pos_in_payload < segment_end:
                if current_pos_in_payload + 1 > segment_end:
                    print(f"Error: Truncated DQT segment at pos {current_pos_in_payload}", file=sys.stderr)
                    break
                pq_tq = data[current_pos_in_payload]
                current_pos_in_payload += 1
                precision = (pq_tq >> 4) & 0x0F
                table_id = pq_tq & 0x0F

                if table_id > 3:
                    print(f"Warning: Invalid table ID {table_id} in DQT segment at pos {current_pos_in_payload-1}", file=sys.stderr)
                    break # Stop parsing this DQT segment

                num_quant_values = 64
                bytes_per_val = 2 if precision == 1 else 1
                num_bytes_needed = num_quant_values * bytes_per_val

                if current_pos_in_payload + num_bytes_needed > segment_end:
                    print(f"Error: DQT table data truncated in segment at pos {current_pos_in_payload}. Required {num_bytes_needed}, available {segment_end - current_pos_in_payload}", file=sys.stderr)
                    break

                table = []
                if precision == 1: # 16-bit
                    for _ in range(num_quant_values):
                        table.append(struct.unpack('>H', data[current_pos_in_payload:current_pos_in_payload+2])[0])
                        current_pos_in_payload += 2
                else: # 8-bit
                    for _ in range(num_quant_values):
                        table.append(data[current_pos_in_payload])
                        current_pos_in_payload += 1

                if len(table) == num_quant_values:
                    # Multiply by 8 as per original script's intent for Rust constants
                    tables[table_id] = [x * 8 for x in table]
                else:
                    print(f"Warning: Incomplete table data read for table {table_id} ({len(table)}/{num_quant_values} vals) in DQT segment", file=sys.stderr)
                    break # Stop parsing this DQT segment

            # Ensure parser moves past this segment regardless of inner loops
            pos = segment_end
        else:
            # Skip other segments
            pos = segment_end

    # Add default tables if missing
    if 0 not in tables:
        print(f"Warning: Luma table (Index 0) not found in {jpeg_path}! Using default empty.", file=sys.stderr)
        tables[0] = [0]*64
    if 1 not in tables:
        print(f"Warning: Chroma table (Index 1) not found in {jpeg_path}! Using default empty.", file=sys.stderr)
        tables[1] = [0]*64

    return tables
# --- End DQT Extraction Logic ---

def format_array_as_rust(arr):
    if not arr or len(arr) != 64:
        arr = [0]*64 # Default to empty on error
    rows = []
    for i in range(0, 64, 8):
        rows.append("        " + ", ".join(map(str, arr[i:i+8]))) # Indent lines within struct
    # Indent the whole array block
    return "    [\n" + ",\n".join(rows) + "\n    ]"

if __name__ == "__main__":
    if len(sys.argv) != 7:
        print("Usage: python3 extract_dqt.py <jpeg_file> <relative_include_path> <distance> <orig_filename> <orig_extension> <source_group>", file=sys.stderr)
        sys.exit(1)

    jpeg_file = sys.argv[1]
    relative_include_path_arg = sys.argv[2]
    distance_arg = float(sys.argv[3])
    orig_filename_arg = sys.argv[4]
    orig_extension_arg = sys.argv[5].upper()
    source_group_arg = sys.argv[6]

    dqt_tables = extract_dqt(jpeg_file)

    luma_rust_str = format_array_as_rust(dqt_tables.get(0))
    chroma_rust_str = format_array_as_rust(dqt_tables.get(1))

    # Print just the Rust struct instance, indented for the array
    print(f"        ReferenceQuantTestData {{")
    print(f"            source_group: \"{source_group_arg}\",")
    print(f"            input_filename: \"{orig_filename_arg}\",")
    print(f"            input_format: \"{orig_extension_arg}\",")
    print(f"            input_data: include_bytes!(\"{relative_include_path_arg}\"),")
    print(f"            cjpegli_distance: {distance_arg:.1f}, # Using .1f format")
    print(f"            expected_luma_dqt: {luma_rust_str},")
    print(f"            expected_chroma_dqt: {chroma_rust_str}")
    print(f"        }}") # No comma here, handled by bash script

EOF
chmod +x extract_dqt.py
echo "Extractor script created/updated."

# --- 6. Finalize Rust File ---
echo "Finalizing Rust test file..."
# Write Rust file footer
cat << 'EOF' >> "$RUST_TEST_FILE"
    ];

    // Example test - implement actual comparison logic here
    #[test]
    fn test_reference_quantization_tables_exist() {
        assert!(!REFERENCE_QUANT_TEST_DATA.is_empty(), "No reference test data found.");
        for test_case in REFERENCE_QUANT_TEST_DATA {
            println!("Checking reference data for {} (source: {}, distance: {:.1f})...",
                     test_case.input_filename, test_case.source_group, test_case.cjpegli_distance);
            assert_eq!(test_case.expected_luma_dqt.len(), 64);
            assert_eq!(test_case.expected_chroma_dqt.len(), 64);
            // Check a few values to ensure they're not all zero
            // Allow tables to be all zero if extraction failed, maybe add a check for filename?
            // assert!(test_case.expected_luma_dqt.iter().any(|&x| x > 0), "Luma table seems empty");
            // assert!(test_case.expected_chroma_dqt.iter().any(|&x| x > 0), "Chroma table seems empty");
        }
    }
}
EOF

echo "Script finished. Check $RUST_TEST_FILE"
