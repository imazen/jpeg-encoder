#!/bin/bash

# --- Determine Script Directory ---
SCRIPT_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
echo "Running dct.sh from script directory: $SCRIPT_DIR"

# --- Configuration ---
# List of input image source patterns. Paths are relative to SCRIPT_DIR
SOURCE_PATTERNS=(
    "jxl-chessboard testdata/jxl/chessboard/*.png"
    "jxl-blending testdata/jxl/blending/*.png"
    "raw.pixls testdata/external/raw.pixls/*.png"
    "wesaturate-64px testdata/external/wesaturate/64px/*.png"
    "wesaturate-500px testdata/external/wesaturate/500px/*.png"
    "wide-gamut-tests testdata/external/wide-gamut-tests/*.png"
)
# Directory to store cjpegli output, relative to SCRIPT_DIR
CJPEGLI_OUTPUT_DIR="cjpegli_results"
# Rust test file path relative to SCRIPT_DIR
RUST_TEST_FILE="../src/jpegli/reference_test_data.rs"

DISTANCES=(0 0.5 1 1.4 2.3 3.2 4.3 7.4 13 25) # Add more distances as needed

DOCKER_IMAGE="imazen/jpeg-tools:main"
# --- End Configuration ---

set -e # Exit on errors

# --- Helper Function to Find/Call cjpegli ---
# Sets CJPEGLI_CMD variable to the command needed to run cjpegli
find_and_set_cjpegli_cmd() {
    echo "Searching for cjpegli..."
    if command -v cjpegli >/dev/null 2>&1; then
        echo "Found cjpegli in PATH."
        CJPEGLI_CMD="cjpegli"
    # Check relative to script directory
    elif [ -x "$SCRIPT_DIR/../tools/cjpegli" ]; then
        echo "Found cjpegli in $SCRIPT_DIR/../tools/."
        # Use absolute path to avoid issues if script changes directory later
        CJPEGLI_CMD="$SCRIPT_DIR/../tools/cjpegli"
    else
        echo "cjpegli not found locally. Checking for Docker..."
        if command -v docker >/dev/null 2>&1; then
            echo "Found Docker. Will attempt to use '$DOCKER_IMAGE'."
            # Map workspace root (assuming script is run from somewhere within it)
            # or map SCRIPT_DIR for inputs and outputs relative to script
            # Use --user to avoid creating files as root
            # Map SCRIPT_DIR to /work, and WORKDIR becomes /work
            CJPEGLI_CMD="docker run --rm -u $(id -u):$(id -g) -v "$SCRIPT_DIR":/work -w /work $DOCKER_IMAGE cjpegli"
            # Optional: Check if image exists, pull if needed
            # if ! docker image inspect "$DOCKER_IMAGE" &> /dev/null; then
            #    echo "Pulling docker image $DOCKER_IMAGE..."
            #    docker pull "$DOCKER_IMAGE"
            # fi
        else
            echo "Error: cjpegli not found in PATH, $SCRIPT_DIR/../tools/, and Docker is not available."
            exit 1
        fi
    fi
    echo "Using command: $CJPEGLI_CMD"
}

# --- 1. Check Prerequisites (Python only now) ---
echo "Checking prerequisites..."
MISSING_TOOLS=""
command -v python3 >/dev/null 2>&1 || MISSING_TOOLS+="python3 "

if [ ! -z "$MISSING_TOOLS" ]; then
    echo "The following tools are missing: $MISSING_TOOLS"
    read -p "Attempt to install them using apt? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        sudo apt-get update && sudo apt-get install -y python3
    else
        echo "Please install the missing tools and run the script again."
        exit 1
    fi
fi
echo "Prerequisites met."

# --- 2. Set cjpegli Command ---
find_and_set_cjpegli_cmd # Sets the global CJPEGLI_CMD variable

# --- 3. Setup Output File ---
# Construct absolute path for Rust file
ABS_RUST_TEST_FILE=$(readlink -f "$SCRIPT_DIR/$RUST_TEST_FILE")
ABS_CJPEGLI_OUTPUT_DIR=$(readlink -f "$SCRIPT_DIR/$CJPEGLI_OUTPUT_DIR")
echo "Setting up output file: $ABS_RUST_TEST_FILE"
echo "Ensuring cjpegli output directory exists: $ABS_CJPEGLI_OUTPUT_DIR"
mkdir -p "$ABS_CJPEGLI_OUTPUT_DIR"

# Write Rust file header (OVERWRITE the file)
cat << 'EOF' > "$ABS_RUST_TEST_FILE"
// Generated by dct.sh and extract_dqt.py. DO NOT EDIT.

// Assuming quantization tables are needed for comparison
// use crate::quantization::QuantizationTable;

#[derive(Debug)]
pub struct ReferenceQuantTestData {
    pub source_group: &'static str,
    pub input_filename: &'static str,
    pub input_format: &'static str, // Format of the *original* input
    pub input_data: &'static [u8],  // Bytes of the *original* input file via include_bytes!
    pub cjpegli_distance: f32,
    pub cjpegli_output_data: &'static [u8], // Bytes of the cjpegli *output* JPEG file via include_bytes!
    pub expected_luma_dqt: [u16; 64],
    pub expected_chroma1_dqt: Option<[u16; 64]>, // Renamed
    pub expected_chroma2_dqt: Option<[u16; 64]>, // Added optional second chroma table
}

pub const REFERENCE_QUANT_TEST_DATA: &[ReferenceQuantTestData] = &[
EOF
echo "Header written to $ABS_RUST_TEST_FILE"

# --- 4. Process Source Patterns for Each Distance ---
echo "Processing source image patterns for multiple distances..."
FIRST_ENTRY=true
# Outer loop for distances
for distance in "${DISTANCES[@]}"; do
    echo "--- Processing for Distance: $distance ---"
    # Inner loop for image patterns (original loop)
    for pattern_entry in "${SOURCE_PATTERNS[@]}"; do
        # Split entry into subfolder name and path pattern
        read -r subfolder path_pattern <<<"$pattern_entry"

        # Construct full path pattern relative to script dir
        full_path_pattern="$SCRIPT_DIR/$path_pattern"
        echo "  Processing group '$subfolder' with pattern '$full_path_pattern'..."

        # Check if the directory exists
        pattern_dir=$(dirname "$full_path_pattern")
        if [ ! -d "$pattern_dir" ]; then
            echo "    Warning: Source directory not found: '$pattern_dir'. Skipping group '$subfolder'." >&2
            continue
        fi

        # Use a safer for loop with globbing
        shopt -s nullglob # Ensure loop doesn't run if no files match
        file_count=0
        for img_path in $full_path_pattern; do
            file_count=$((file_count + 1))
            echo "    DEBUG: Processing found img_path='$img_path'"
            if [ ! -f "$img_path" ]; then
                echo "    Warning: Found path is not a file: '$img_path'. Skipping." >&2
                continue
            fi

            img_basename=$(basename "$img_path")
            img_extension="${img_basename##*.}"
            img_name_no_ext="${img_basename%.*}"

            # Path for input include_bytes! relative from the target Rust file to the original image path
            abs_img_path=$(readlink -f "$img_path")
            abs_rust_file_dir=$(dirname "$ABS_RUST_TEST_FILE")
            relative_input_include_path=$(python3 -c "import os.path; print(os.path.relpath('$abs_img_path', '$abs_rust_file_dir'))")

            # Define output JPEG filename relative to SCRIPT_DIR, including group and distance
            output_jpeg_subdir="$ABS_CJPEGLI_OUTPUT_DIR/$subfolder"
            mkdir -p "$output_jpeg_subdir"
            output_jpeg_filename="${img_name_no_ext}_d${distance}.jpg"
            output_jpeg_path="$output_jpeg_subdir/$output_jpeg_filename"

            # Delete output JPEG if it exists from a previous run
            rm -f "$output_jpeg_path"

            echo "    Processing '$img_path' -> '$output_jpeg_path' (input include path: '$relative_input_include_path')..."

            # Encode using the original image path and current distance
            if [[ "$CJPEGLI_CMD" == docker* ]]; then
                # Paths relative to SCRIPT_DIR for docker volume mapping
                docker_input_path=$(python3 -c "import os.path; print(os.path.relpath('$abs_img_path', '$SCRIPT_DIR'))")
                docker_output_path="$CJPEGLI_OUTPUT_DIR/$subfolder/$output_jpeg_filename" # Path inside container /work
                echo "      Encoding (Docker) '$docker_input_path' -> '$docker_output_path' with cjpegli (distance $distance)..."
                eval "$CJPEGLI_CMD "--distance $distance" "$docker_input_path" "$docker_output_path""
            else
                cjpegli_input_path="$img_path" # Use original path for local execution
                echo "      Encoding (Local) '$cjpegli_input_path' -> '$output_jpeg_path' with cjpegli (distance $distance)..."
                eval $CJPEGLI_CMD --distance "$distance" "$cjpegli_input_path" "$output_jpeg_path"
            fi
            # Check cjpegli exit code
            if [ $? -ne 0 ]; then
                echo "    Error: cjpegli command failed for input '$img_path' at distance $distance. Exiting." >&2
                rm -f "$output_jpeg_path" # Clean up potentially partial file
                exit 1 # Exit script on failure
            fi

            echo "      Encoding complete: '$output_jpeg_path'"

            # Check if output JPEG exists before extracting
            if [ ! -f "$output_jpeg_path" ]; then
                echo "    Error: Output JPEG '$output_jpeg_path' not found after cjpegli ran. Exiting." >&2
                exit 1 # Exit script on failure
            fi

            # Calculate path for cjpegli output include_bytes!
            abs_output_jpeg_path=$(readlink -f "$output_jpeg_path")
            relative_cjpegli_include_path=$(python3 -c "import os.path; print(os.path.relpath('$abs_output_jpeg_path', '$abs_rust_file_dir'))")

            # Extract DQT using the current distance and generated JPEG
            PYTHON_SCRIPT_PATH="$SCRIPT_DIR/extract_dqt.py"
            echo "      Extracting DQT using $PYTHON_SCRIPT_PATH and generating Rust struct entry (cjpegli include: $relative_cjpegli_include_path)..."
            # Append comma BEFORE the next entry (if not the first)
            if [ "$FIRST_ENTRY" = true ]; then
                FIRST_ENTRY=false
            else
                echo "," >> "$ABS_RUST_TEST_FILE"
            fi
            # Pass both relative paths to the python script (input first, then cjpegli output)
            python3 "$PYTHON_SCRIPT_PATH" "$output_jpeg_path" "$relative_input_include_path" "$distance" "$img_basename" "$img_extension" "$subfolder" "$relative_cjpegli_include_path" >> "$ABS_RUST_TEST_FILE"
            # Check python script exit code
            if [ $? -ne 0 ]; then
                 echo "    Error: extract_dqt.py failed for '$output_jpeg_path' at distance $distance. Check script errors above. Exiting." >&2
                 exit 1 # Exit script on failure
            fi

            # DO NOT Clean up temporary JPEG anymore
            # rm -f "$output_jpeg_path"

            echo "    Finished processing '$img_path' for distance $distance."
        done || echo "    Note: No files found matching pattern '$full_path_pattern' in group '$subfolder'."

    done # End inner loop (patterns)
done # End outer loop (distances)
echo "Finished processing all patterns for all distances."

# --- 5. Create/Update DQT Extractor Script ---
PYTHON_SCRIPT_PATH="$SCRIPT_DIR/extract_dqt.py"


# --- 6. Finalize Rust File ---
echo "Finalizing Rust test file..."
# Append the closing elements for the array and the tests module
cat << 'EOF' >> "$ABS_RUST_TEST_FILE"
]; // Close the main data array

// Ensure the tests module wraps the test function
#[cfg(test)]
mod tests {
    use super::*;

    // Example test - implement actual comparison logic here
    #[test]
    fn test_reference_quantization_tables_exist() {
        assert!(!REFERENCE_QUANT_TEST_DATA.is_empty(), "No reference test data found.");
        for test_case in REFERENCE_QUANT_TEST_DATA {
            println!("Checking reference data for {} (source: {}, distance: {:.1})...",
                     test_case.input_filename, test_case.source_group, test_case.cjpegli_distance);
            assert!(test_case.input_data.len() > 0, "Input data is empty for {}", test_case.input_filename);
            assert!(test_case.cjpegli_output_data.len() > 0, "cjpegli output data is empty for {}", test_case.input_filename);
            assert_eq!(test_case.expected_luma_dqt.len(), 64);
            assert_eq!(test_case.expected_chroma1_dqt.len(), 64); // Check renamed field
            // Check chroma2 only if it exists
            if let Some(chroma2_table) = test_case.expected_chroma2_dqt {
                assert_eq!(chroma2_table.len(), 64, "Chroma2 table has incorrect size for {}", test_case.input_filename);
            }
            // Check a few values to ensure they're not all zero
            // Allow tables to be all zero if extraction failed, maybe add a check for filename?
            // assert!(test_case.expected_luma_dqt.iter().any(|&x| x > 0), "Luma table seems empty");
            // assert!(test_case.expected_chroma_dqt.iter().any(|&x| x > 0), "Chroma table seems empty");
        }
    }
}
EOF

echo "Script finished. Check $ABS_RUST_TEST_FILE and $ABS_CJPEGLI_OUTPUT_DIR"
