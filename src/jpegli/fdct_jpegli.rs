#[cfg(test)]
mod tests {
    use super::*; // Use super to bring items from parent module into scope

    #[test]
    #[ignore] // Requires reference values from C++ jpegli
    fn test_float_dct_basic() {
        // Sample 8x8 block data (level-shifted: pixel_u8 as f32 - 128.0)
        // Example: A simple gradient or constant block
        let input_pixels: [f32; 64] = [
            -128.0, -112.0, -96.0, -80.0, -64.0, -48.0, -32.0, -16.0,
            -112.0, -96.0, -80.0, -64.0, -48.0, -32.0, -16.0,   0.0,
            -96.0, -80.0, -64.0, -48.0, -32.0, -16.0,   0.0,  16.0,
            -80.0, -64.0, -48.0, -32.0, -16.0,   0.0,  16.0,  32.0,
            -64.0, -48.0, -32.0, -16.0,   0.0,  16.0,  32.0,  48.0,
            -48.0, -32.0, -16.0,   0.0,  16.0,  32.0,  48.0,  64.0,
            -32.0, -16.0,   0.0,  16.0,  32.0,  48.0,  64.0,  80.0,
            -16.0,   0.0,  16.0,  32.0,  48.0,  64.0,  80.0,  96.0,
        ]; // Replace with actual test data
        let mut coeffs = [0.0f32; 64];
        let mut scratch = [0.0f32; 64];

        forward_dct_float(&input_pixels, &mut coeffs, &mut scratch);

        // Reference coefficients obtained from running jpegli C++
        // on the same input_pixels data.
        let expected_coeffs: [f32; 64] = [
            // Fill with reference values...
            0.0; 64 // Placeholder
        ];

        // Compare coeffs with expected_coeffs (allow for small floating point differences)
        let epsilon = 1e-4;
        for i in 0..64 {
            assert!((coeffs[i] - expected_coeffs[i]).abs() < epsilon,
                "Mismatch at index {}: expected {}, got {}",
                 i, expected_coeffs[i], coeffs[i]);
        }
    }
}

// Constants and functions for Jpegli Float DCT implementation
// Based on lib/jpegli/dct-inl.h

// Constants for DCT implementation. Generated by the following snippet:
// for i in range(N // 2):
//    print(1.0 / (2 * math.cos((i + 0.5) * math.pi / N)), end=", ")
mod float_dct_constants {
// WcMultipliers<8>
pub const WC_MULTIPLIERS_8: [f32; 4] = [
    0.5097955791041592,
    0.6013448869350453,
    0.8999762231364156,
    2.5629154477415055,
];
pub const SQRT2: f32 = 1.41421356237f32;
pub const INV_8: f32 = 1.0 / 8.0;
}

fn transpose_8x8_block(input: &[f32; 64], output: &mut [f32; 64]) {
// Basic scalar transpose
for i in 0..8 {
    for j in 0..8 {
        output[j * 8 + i] = input[i * 8 + j];
    }
}
}

fn add_reverse<const N_HALF: usize>(a_in1: &[f32], a_in2: &[f32], a_out: &mut [f32]) {
// N_HALF corresponds to N / 2 in the C++ code
// The C++ code operates on 8-element vectors per loop iteration.
// This scalar version processes element by element within the rows.
assert_eq!(a_in2.len(), N_HALF * 8);
assert_eq!(a_out.len(), N_HALF * 8);
for i in 0..N_HALF {
    for k in 0..8 {
        // Corrected index for a_in2 slice: (N_HALF - 1 - i) * 8 + k
        let idx2 = (N_HALF - 1 - i) * 8 + k;
        a_out[i * 8 + k] = a_in1[i * 8 + k] + a_in2[idx2];
    }
}
}

fn sub_reverse<const N_HALF: usize>(a_in1: &[f32], a_in2: &[f32], a_out: &mut [f32]) {
// N_HALF corresponds to N / 2 in the C++ code
assert_eq!(a_in2.len(), N_HALF * 8);
assert_eq!(a_out.len(), N_HALF * 8);
for i in 0..N_HALF {
    for k in 0..8 {
         // Corrected index for a_in2 slice: (N_HALF - 1 - i) * 8 + k
        let idx2 = (N_HALF - 1 - i) * 8 + k;
        a_out[i * 8 + k] = a_in1[i * 8 + k] - a_in2[idx2];
    }
}
}

fn multiply<const N_HALF: usize>(
coeff_second_half: &mut [f32],
multipliers: &[f32]
) {
// Check if multipliers array has enough elements
assert!(multipliers.len() >= N_HALF);
for i in 0..N_HALF {
     for k in 0..8 {
        // Indexing relative to the start of the second half slice
        coeff_second_half[i * 8 + k] *= multipliers[i];
    }
}
}

fn b<const N: usize>(coeff: &mut [f32]) {
// N here corresponds to N/2 in the C++ B<N/2> call site context
// (e.g. called with N=4 when processing N=8 DCT)
let sqrt2 = float_dct_constants::SQRT2;

// Assert that the input slice has the expected length based on N (N rows of 8 elements)
assert_eq!(coeff.len(), N * 8, "Input slice length mismatch in fn b");

for k in 0..8 {
    coeff[0 * 8 + k] = coeff[0 * 8 + k] * sqrt2 + coeff[1 * 8 + k];
}
for i in 1..(N - 1) {
    for k in 0..8 {
        coeff[i * 8 + k] += coeff[(i + 1) * 8 + k];
    }
}
}

fn inverse_even_odd<const N: usize>(a_in: &[f32], a_out: &mut [f32]) {
assert_eq!(a_in.len(), N * 8, "Input slice length mismatch in fn inverse_even_odd");
for i in 0..(N / 2) {
    for k in 0..8 {
         a_out[2 * i * 8 + k] = a_in[i * 8 + k];
    }
}
for i in (N / 2)..N {
     for k in 0..8 {
        a_out[(2 * (i - N / 2) + 1) * 8 + k] = a_in[i * 8 + k];
    }
}
}

// Recursive DCT implementation structure
trait DCT1DImplTrait {
fn compute(mem: &mut [f32]);
}

struct DCT1DImpl<const N: usize>;

impl DCT1DImplTrait for DCT1DImpl<1> {
fn compute(_mem: &mut [f32]) {
    // Base case: N=1 DCT is identity
}
}

impl DCT1DImplTrait for DCT1DImpl<2> {
fn compute(mem: &mut [f32]) {
    // Operates on two rows (16 elements total)
    for k in 0..8 {
        let in1 = mem[0 * 8 + k];
        let in2 = mem[1 * 8 + k];
        mem[0 * 8 + k] = in1 + in2;
        mem[1 * 8 + k] = in1 - in2;
    }
}
}

// Generic implementation for N > 2 (power of 2)
// Needs explicit specialization or handling for N=4, N=8 etc.
// Let's implement N=8 directly based on the recursive calls.
impl DCT1DImplTrait for DCT1DImpl<8> {
fn compute(mem: &mut [f32]) { // mem is [f32; 64]
    let mut tmp = [0.0f32; 64];
    {
        let (tmp_first_half, tmp_second_half) = tmp.split_at_mut(32);

        // First level recursion (N=8 -> N=4)
        let (mem_first_half, mem_second_half) = mem.split_at_mut(32);

        add_reverse::<4>(mem_first_half, mem_second_half, tmp_first_half);
        DCT1DImpl::<4>::compute(tmp_first_half); // Operates on tmp_first_half

        sub_reverse::<4>(mem_first_half, mem_second_half, tmp_second_half);

        // Call multiply only on the second half, passing N/2 and multipliers
        multiply::<4>(tmp_second_half, &float_dct_constants::WC_MULTIPLIERS_8);

        // Second recursion operates on tmp_second_half
        DCT1DImpl::<4>::compute(tmp_second_half);
        b::<4>(&mut tmp[32..64]); // Re-enable call
    }
    // tmp is fully available again here
    inverse_even_odd::<8>(&tmp, mem);
}
}

// We need DCT1DImpl<4> for the recursion
impl DCT1DImplTrait for DCT1DImpl<4> {
 fn compute(mem: &mut [f32]) { // mem is [f32; 32]
    let mut tmp = [0.0f32; 32];

    // Second level recursion (N=4 -> N=2)
    let (mem_first_half, mem_second_half) = mem.split_at_mut(16);
    let (tmp_first_half, tmp_second_half) = tmp.split_at_mut(16);

    add_reverse::<2>(mem_first_half, mem_second_half, tmp_first_half);
    DCT1DImpl::<2>::compute(tmp_first_half); // Base case N=2

    sub_reverse::<2>(mem_first_half, mem_second_half, tmp_second_half);
    DCT1DImpl::<2>::compute(tmp_second_half); // Base case N=2
    b::<2>(tmp_second_half); // N=2 means N/2 from C++

    inverse_even_odd::<4>(&tmp, mem);
}
}

fn dct_1d(pixels: &[f32], output: &mut [f32]) {
// Assumes pixels is 64 element row/column block, output is 64 element block
// Performs 8 parallel 1D DCTs of size 8
let mut tmp = [0.0f32; 64];

// Load - In C++ this loads columns into tmp using LoadFromBlock
// In Rust, assuming input `pixels` is already arranged correctly for the first 1D pass (row-wise)
// For the second pass (column-wise), the transposed data is used.
// Let's simplify and assume `pixels` is the 64-element block to process.
 tmp.copy_from_slice(pixels);

// Process 8 columns/rows in place within tmp
DCT1DImpl::<8>::compute(&mut tmp);

// Scale and Store - In C++ uses StoreToBlockAndScale
let mul = float_dct_constants::INV_8;
for i in 0..64 {
     output[i] = tmp[i] * mul;
}
}

/// Performs a forward DCT on an 8x8 block using floating-point arithmetic
/// based on the jpegli implementation.
///
/// * `pixels`: Input 8x8 block (64 elements, row-major). Should be level-shifted (centered around 0.0).
/// * `coefficients`: Output 8x8 block (64 elements, row-major) for DCT coefficients.
/// * `scratch_space`: A temporary buffer of 64 f32 elements.
pub fn forward_dct_float(pixels: &[f32; 64], coefficients: &mut [f32; 64], scratch_space: &mut [f32; 64]) {
// 1. DCT1D on rows
dct_1d(pixels, scratch_space);

// 2. Transpose
transpose_8x8_block(scratch_space, coefficients);

// 3. DCT1D on columns (using the transposed block as input)
dct_1d(coefficients, scratch_space);

// 4. Transpose back
transpose_8x8_block(scratch_space, coefficients);
}
